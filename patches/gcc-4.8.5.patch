diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 2a4475b..639d69c 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -862,7 +862,7 @@ RTL_ERROR_H = rtl-error.h $(RTL_H) $(DIAGNOSTIC_CORE_H)
 READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h
 PARAMS_H = params.h params.def
 BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def \
-	gtm-builtins.def sanitizer.def
+	gtm-builtins.def sanitizer.def hls-builtins.def
 INTERNAL_FN_DEF = internal-fn.def
 INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)
 TREE_H = coretypes.h tree.h all-tree.def tree.def c-family/c-common.def \
@@ -1305,6 +1305,7 @@ OBJS = \
 	mcf.o \
 	mode-switching.o \
 	modulo-sched.o \
+	mpc-pass.o \
 	omega.o \
 	omp-low.o \
 	optabs.o \
@@ -2537,6 +2538,11 @@ omp-low.o : omp-low.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
    $(TREE_FLOW_H) $(FLAGS_H) $(EXPR_H) $(DIAGNOSTIC_CORE_H) \
    $(TREE_PASS_H) $(GGC_H) $(EXCEPT_H) $(SPLAY_TREE_H) $(OPTABS_H) \
    $(CFGLOOP_H) tree-iterator.h gt-omp-low.h
+mpc-pass.o : mpc-pass.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) $(GIMPLE_H) $(TREE_INLINE_H) langhooks.h $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TIMEVAR_H) $(FLAGS_H) $(EXPR_H) $(TOPLEV_H) tree-pass.h \
+   $(GGC_H) except.h $(SPLAY_TREE_H) $(OPTABS_H) $(CFGLOOP_H) \
+   tree-iterator.h
 tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \
    coretypes.h $(TREE_H) $(TREE_PRETTY_PRINT_H)
 omega.o : omega.c $(OMEGA_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h \
@@ -3744,6 +3750,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \
   $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \
   $(srcdir)/tree-parloops.c \
   $(srcdir)/omp-low.c \
+  $(srcdir)/mpc-pass.c \
   $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \
   $(srcdir)/cgraphclones.c \
   $(srcdir)/tree-ssa-propagate.c \
diff --git a/gcc/builtin-types.def b/gcc/builtin-types.def
index 3ef2d1b..ec6af2b 100644
--- a/gcc/builtin-types.def
+++ b/gcc/builtin-types.def
@@ -230,8 +230,14 @@ DEF_FUNCTION_TYPE_1 (BT_FN_ULONGLONG_ULONGLONG, BT_ULONGLONG, BT_ULONGLONG)
 DEF_FUNCTION_TYPE_1 (BT_FN_UINT16_UINT16, BT_UINT16, BT_UINT16)
 DEF_FUNCTION_TYPE_1 (BT_FN_UINT32_UINT32, BT_UINT32, BT_UINT32)
 DEF_FUNCTION_TYPE_1 (BT_FN_UINT64_UINT64, BT_UINT64, BT_UINT64)
+/* MPC HLS BEGIN */
+DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)
+/* MPC HLS END */
 
 DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)
+/* MPC OMP BEGIN */
+DEF_POINTER_TYPE (BT_PTR_FN_PTR_PTR, BT_FN_PTR_PTR)
+/* MPC OMP END */
 
 DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_INT, BT_VOID, BT_PTR, BT_INT)
 DEF_FUNCTION_TYPE_2 (BT_FN_STRING_STRING_CONST_STRING,
@@ -423,6 +429,9 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I2_INT, BT_VOID, BT_VOLATILE_PTR, BT_I2, BT
 DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I4_INT, BT_VOID, BT_VOLATILE_PTR, BT_I4, BT_INT)
 DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I8_INT, BT_VOID, BT_VOLATILE_PTR, BT_I8, BT_INT)
 DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I16_INT, BT_VOID, BT_VOLATILE_PTR, BT_I16, BT_INT)
+/* MPC OMP BEGIN */
+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_INT_OMPFN_PTR, BT_VOID, BT_INT, BT_PTR_FN_PTR_PTR, BT_PTR)
+/* MPC OMP END */
 
 DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_FILEPTR,
 		     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_FILEPTR)
@@ -446,6 +455,10 @@ DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_VPTR_PTR_INT, BT_VOID, BT_SIZE,
 		     BT_VOLATILE_PTR, BT_PTR, BT_INT)
 DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_CONST_VPTR_PTR_INT, BT_VOID, BT_SIZE,
 		     BT_CONST_VOLATILE_PTR, BT_PTR, BT_INT)
+/* MPC OMP BEGIN */
+DEF_FUNCTION_TYPE_4 (BT_FN_VOID_INT_OMPFN_PTR_INT, BT_VOID, BT_INT, BT_PTR_FN_PTR_PTR,
+		     BT_PTR, BT_INT)
+/* MPC OMP END */
 
 DEF_FUNCTION_TYPE_5 (BT_FN_INT_STRING_INT_SIZE_CONST_STRING_VALIST_ARG,
 		     BT_INT, BT_STRING, BT_INT, BT_SIZE, BT_CONST_STRING,
diff --git a/gcc/builtins.def b/gcc/builtins.def
index d5afe0d..8aae9ca 100644
--- a/gcc/builtins.def
+++ b/gcc/builtins.def
@@ -141,6 +141,16 @@ along with GCC; see the file COPYING3.  If not see
                false, true, true, ATTRS, false, \
 	       (flag_openmp || flag_tree_parallelize_loops))
 
+/* MPC OMP BEGIN */
+/* Builtin used by the implementation of MPC OpenMP.  None of these are
+   actually implemented in the compiler; they're all in the MPC library.  */
+#undef DEF_MPC_BUILTIN
+#define DEF_MPC_BUILTIN(ENUM, NAME, TYPE, ATTRS) \
+  DEF_BUILTIN (ENUM, "__builtin_" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \
+               false, true, true, ATTRS, false, \
+	       (flag_openmp || flag_tree_parallelize_loops))
+/* MPC OMP END */
+
 /* Builtin used by the implementation of GNU TM.  These
    functions are mapped to the actual implementation of the STM library. */
 #undef DEF_TM_BUILTIN
@@ -834,6 +844,10 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, "LINE", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)
 /* OpenMP builtins.  */
 #include "omp-builtins.def"
 
+/* MPC HLS BEGIN */
+#include "hls-builtins.def"
+/* MPC HLS END */
+
 /* GTM builtins. */
 #include "gtm-builtins.def"
 
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index f41ec9c..8c253d2 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -469,6 +469,12 @@ const struct c_common_resword c_common_reswords[] =
   { "__signed",		RID_SIGNED,	0 },
   { "__signed__",	RID_SIGNED,	0 },
   { "__thread",		RID_THREAD,	0 },
+  /* MPC begin */
+  { "__task",		RID_TASK,	0 },
+  { "__process",		RID_PROCESS,	0 },
+  { "__openmp",		RID_OPENMP,	0 },
+ 
+  /* MPC end */
   { "__transaction_atomic", RID_TRANSACTION_ATOMIC, 0 },
   { "__transaction_relaxed", RID_TRANSACTION_RELAXED, 0 },
   { "__transaction_cancel", RID_TRANSACTION_CANCEL, 0 },
@@ -11383,6 +11389,11 @@ keyword_is_storage_class_specifier (enum rid keyword)
     case RID_AUTO:
     case RID_MUTABLE:
     case RID_THREAD:
+		/* MPC TLS BEGIN */
+	case RID_PROCESS:
+	case RID_TASK:
+	case RID_OPENMP:
+		/* MPC TLS END */
       return true;
     default:
       return false;
diff --git a/gcc/c-family/c-common.h b/gcc/c-family/c-common.h
index 4014651..5bf4feb 100644
--- a/gcc/c-family/c-common.h
+++ b/gcc/c-family/c-common.h
@@ -68,6 +68,9 @@ enum rid
   RID_VOLATILE, RID_SIGNED,  RID_AUTO,  RID_RESTRICT,
   RID_NORETURN,
 
+  /* MPC Extension */
+  RID_PROCESS, RID_TASK,RID_OPENMP,
+
   /* C extensions */
   RID_COMPLEX, RID_THREAD, RID_SAT,
 
diff --git a/gcc/c-family/c-cppbuiltin.c b/gcc/c-family/c-cppbuiltin.c
index 3e210d9..6bd3b03 100644
--- a/gcc/c-family/c-cppbuiltin.c
+++ b/gcc/c-family/c-cppbuiltin.c
@@ -893,8 +893,14 @@ c_cpp_builtins (cpp_reader *pfile)
   else if (flag_stack_protect == 1)
     cpp_define (pfile, "__SSP__=1");
 
+  /* MPC OMP BEGIN */
+#if 0
   if (flag_openmp)
     cpp_define (pfile, "_OPENMP=201107");
+#endif
+  if (flag_openmp)
+    cpp_define (pfile, "_OPENMP=201107");
+/* MPC OMP END */
 
   if (int128_integer_type_node != NULL_TREE)
     builtin_define_type_sizeof ("__SIZEOF_INT128__",
diff --git a/gcc/c-family/c-omp.c b/gcc/c-family/c-omp.c
index f05b60a..1b5a2d2 100644
--- a/gcc/c-family/c-omp.c
+++ b/gcc/c-family/c-omp.c
@@ -76,7 +76,12 @@ c_finish_omp_barrier (location_t loc)
 {
   tree x;
 
-  x = builtin_decl_explicit (BUILT_IN_GOMP_BARRIER);
+  /* MPC OMP begin */
+#if 0
+  x = builtin_decl_explicit(BUILT_IN_GOMP_BARRIER);
+#endif
+  x = builtin_decl_explicit(BUILT_IN_MPC_BARRIER);
+  /* MPC OMP end */
   x = build_call_expr_loc (loc, x, 0);
   add_stmt (x);
 }
@@ -89,8 +94,12 @@ void
 c_finish_omp_taskwait (location_t loc)
 {
   tree x;
-
-  x = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);
+  /* MPC OMP BEGIN */
+  #if 0
+  	x = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);
+  #endif
+  x = builtin_decl_explicit (BUILT_IN_MPC_TASKWAIT);
+  /* MPC OMP END */
   x = build_call_expr_loc (loc, x, 0);
   add_stmt (x);
 }
@@ -103,8 +112,12 @@ void
 c_finish_omp_taskyield (location_t loc)
 {
   tree x;
-
-  x = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD);
+  /* MPC OMP BEGIN */
+  #if 0
+  	x = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD); 
+  #endif
+  x = builtin_decl_explicit (BUILT_IN_MPC_TASKYIELD);
+  /* MPC OMP END */
   x = build_call_expr_loc (loc, x, 0);
   add_stmt (x);
 }
@@ -259,7 +272,12 @@ c_finish_omp_flush (location_t loc)
 {
   tree x;
 
+  /* MPC OMP begin */
+#if 0
   x = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);
+#endif
+  x = builtin_decl_explicit (BUILT_IN_MPC_FLUSH);
+/* MPC OMP end */
   x = build_call_expr_loc (loc, x, 0);
   add_stmt (x);
 }
diff --git a/gcc/c-family/c-opts.c b/gcc/c-family/c-opts.c
index 30de1e1..a40771a 100644
--- a/gcc/c-family/c-opts.c
+++ b/gcc/c-family/c-opts.c
@@ -43,6 +43,8 @@ along with GCC; see the file COPYING3.  If not see
 				   TARGET_OPTF.  */
 #include "tm_p.h"		/* For C_COMMON_OVERRIDE_OPTIONS.  */
 
+#include <sys/time.h>
+
 #ifndef DOLLARS_IN_IDENTIFIERS
 # define DOLLARS_IN_IDENTIFIERS true
 #endif
@@ -1341,6 +1343,66 @@ c_finish_options (void)
 
   include_cursor = 0;
   push_command_line_include ();
+
+
+	/* MPC_BEGIN */
+	if( !(cpp_get_options (parse_in)->lang == CLK_ASM) && getenv("MPC_DYN_PRIV_ENABLED") )
+	{
+		pch_cpp_save_state ();
+		
+		struct timeval tv;
+		gettimeofday( &tv, NULL);
+		
+		srand( getpid());
+		int rnd[4];
+		rnd[0] = rand();
+		rnd[1] = (int)tv.tv_sec;
+		rnd[2] = (int)tv.tv_usec;
+		srand(rnd[2] + rnd[0]);
+		rnd[3] = rand();;
+		
+		char fname[20];
+		char file_cont[500];
+		
+		snprintf(fname, 20, "/tmp/tmp-gcc-XXXXXX" );
+		snprintf(file_cont, 500, "void _%d%d%d%d(){}", rnd[0], rnd[1], rnd[2], rnd[3] );
+		
+		int fd = mkstemp(fname);
+		
+		if( fd < 0 )
+		{
+			perror("mkstemp");
+			abort();
+		}
+		
+		int to_w = strlen( file_cont );
+		int ret = 0;
+		
+		
+		while( (ret = write(fd, file_cont, to_w) ) )
+		{
+			if( ret < 0 )
+			{
+				if( errno == EAGAIN )
+					continue;
+				perror("write");
+				abort();
+			}
+			
+			to_w -= ret;
+			
+			if( to_w <= 0 )
+				break;
+		}
+		
+		
+		close( fd );
+		
+		cpp_push_include (parse_in, fname);
+		
+		unlink( fname );
+	}
+	/* MPC_END */
 }
 
 /* Give CPP the next file given by -include, if any.  */
diff --git a/gcc/c-family/c-pragma.c b/gcc/c-family/c-pragma.c
index cd90433..5217d15 100644
--- a/gcc/c-family/c-pragma.c
+++ b/gcc/c-family/c-pragma.c
@@ -1351,6 +1351,30 @@ init_pragma (void)
 				      omp_pragmas[i].id, true, true);
     }
 
+  /* MPC HLS BEGIN */
+  if (flag_mpc_hls && !flag_preprocess_only)
+    {
+      struct mpc_hls_pragma_def { const char *name; unsigned int id; };
+      static const struct mpc_hls_pragma_def mpc_hls_pragmas[] = {
+	{ "node",    PRAGMA_HLS_NODE },
+	{ "numa",    PRAGMA_HLS_NUMA },
+	{ "socket",  PRAGMA_HLS_SOCKET },
+	{ "cache",   PRAGMA_HLS_CACHE },
+	{ "core",    PRAGMA_HLS_CORE },
+	{ "single",  PRAGMA_HLS_SINGLE },
+	{ "barrier", PRAGMA_HLS_BARRIER },
+      } ;
+
+      const int n_mpc_hls_pragmas = sizeof (mpc_hls_pragmas) / 
+	sizeof (*mpc_hls_pragmas);
+      int i;
+
+      for (i = 0; i < n_mpc_hls_pragmas; ++i)
+	cpp_register_deferred_pragma (parse_in, "hls", mpc_hls_pragmas[i].name,
+				      mpc_hls_pragmas[i].id, true, true);
+    }
+  /* MPC HLS END */
+  
   if (!flag_preprocess_only)
     cpp_register_deferred_pragma (parse_in, "GCC", "pch_preprocess",
 				  PRAGMA_GCC_PCH_PREPROCESS, false, false);
diff --git a/gcc/c-family/c-pragma.h b/gcc/c-family/c-pragma.h
index 41215db..0cc5d10 100644
--- a/gcc/c-family/c-pragma.h
+++ b/gcc/c-family/c-pragma.h
@@ -44,7 +44,15 @@ typedef enum pragma_kind {
   PRAGMA_OMP_TASKWAIT,
   PRAGMA_OMP_TASKYIELD,
   PRAGMA_OMP_THREADPRIVATE,
-
+  /* MPC HLS BEGIN */
+  PRAGMA_HLS_NODE,
+  PRAGMA_HLS_NUMA,
+  PRAGMA_HLS_SOCKET,
+  PRAGMA_HLS_CACHE,
+  PRAGMA_HLS_CORE,
+  PRAGMA_HLS_SINGLE,
+  PRAGMA_HLS_BARRIER,
+  /* MPC HLS END */
   PRAGMA_GCC_PCH_PREPROCESS,
 
   PRAGMA_FIRST_EXTERNAL
diff --git a/gcc/c-family/c.opt b/gcc/c-family/c.opt
index 4da80b0..c6b489e 100644
--- a/gcc/c-family/c.opt
+++ b/gcc/c-family/c.opt
@@ -490,6 +490,12 @@ Wmissing-declarations
 C ObjC C++ ObjC++ Var(warn_missing_declarations) Warning
 Warn about global functions without previous declarations
 
+; MPC HLS BEGIN 
+Wmpc
+C C++ Var(warn_mpc) Warning LangEnabledBy(C C++, Wall)
+Warn about MPC-related and thread-safety issues
+; MPC HLS END
+
 Wmissing-field-initializers
 C ObjC C++ ObjC++ Var(warn_missing_field_initializers) Warning EnabledBy(Wextra)
 Warn about missing fields in struct initializers
@@ -984,6 +990,27 @@ flax-vector-conversions
 C ObjC C++ ObjC++ Var(flag_lax_vector_conversions)
 Allow implicit conversions between vectors with differing numbers of subparts and/or differing element types.
 
+; MPC TLS BEGIN 
+fmpc-privatize
+C C++ Var(flag_mpc_privatize)
+Privatize every global variable to make MPI codes MPC compliant.
+
+fmpi-privatize
+C C++ Var(flag_mpi_privatize)
+Privatize every global variable to make MPI codes MPC compliant using standard TLS mechanism.
+; MPC TLS END 
+
+; MPC HLS BEGIN
+fhls
+C C++ Var(flag_mpc_hls)
+Enable Hierarchical Local Storage (HLS) directives
+
+fhls-verbose
+C C++ Var(flag_mpc_hls_verbose)
+Enable verbose output for Hierarchical Local Storage (HLS) directives
+; MPC HLS END
+
+
 fms-extensions
 C ObjC C++ ObjC++ Var(flag_ms_extensions)
 Don't warn about uses of Microsoft extensions
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index a9108e7..d85a350 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -1962,13 +1962,24 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,
     {
       /* Only variables can be thread-local, and all declarations must
 	 agree on this property.  */
-      if (C_DECL_THREADPRIVATE_P (olddecl) && !DECL_THREAD_LOCAL_P (newdecl))
+     /* MPC HLS BEGIN */
+#if 0
+    if (C_DECL_THREADPRIVATE_P (olddecl) && !DECL_THREAD_LOCAL_P (newdecl))
+#endif
+	  /* newdecl can be modified by mpc-privatize */
+    if (C_DECL_THREADPRIVATE_P (olddecl))
 	{
 	  /* Nothing to check.  Since OLDDECL is marked threadprivate
 	     and NEWDECL does not have a thread-local attribute, we
 	     will merge the threadprivate attribute into NEWDECL.  */
 	  ;
 	}
+	else if (DECL_TLS_MODEL(olddecl) >= TLS_MODEL_HLS_NODE)
+	{
+	  /* same as above but for HLS variables */
+	  ;
+	}
+      /* MPC HLS END */
       else if (DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl))
 	{
 	  if (DECL_THREAD_LOCAL_P (newdecl))
@@ -2260,6 +2271,14 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)
       C_DECL_THREADPRIVATE_P (newdecl) = 1;
     }
 
+	/* MPC HLS BEGIN */
+  /* merge the HLS attribute */
+  if (TREE_CODE (olddecl) == VAR_DECL && DECL_TLS_MODEL (olddecl) >= TLS_MODEL_HLS_NODE )
+    {
+      DECL_TLS_MODEL (newdecl) = DECL_TLS_MODEL (olddecl);
+    }
+/* MPC HLS END */
+	
   if (CODE_CONTAINS_STRUCT (TREE_CODE (olddecl), TS_DECL_WITH_VIS))
     {
       /* Merge the section attribute.
@@ -3848,6 +3867,8 @@ quals_from_declspecs (const struct c_declspecs *specs)
 	      && !specs->complex_p
 	      && !specs->inline_p
 	      && !specs->noreturn_p
+	      && !specs->task_p
+	      && !specs->process_p
 	      && !specs->thread_p);
   return quals;
 }
@@ -4162,6 +4183,44 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,
     record_inline_static (input_location, current_function_decl,
 			  decl, csi_modifiable);
 
+/* MPC TLS BEGIN */
+#if 1
+  if ( flag_mpi_privatize && 
+      TREE_CODE(decl) == VAR_DECL && 
+      ( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) && 
+      !DECL_IN_SYSTEM_HEADER(decl) && 
+      ( !TREE_READONLY( decl ) || !(initializer_constant_valid_p (decl, TREE_TYPE (decl))) ) && 
+      !DECL_THREAD_LOCAL_P(decl) &&
+	  strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&
+	  strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0
+      ) {
+    fprintf( stderr, 
+	"(Front-end C) Automatic privatization to TLS (variable %s in file %s line %d)\n",
+	lang_hooks.decl_printable_name (decl,2), 
+	DECL_SOURCE_FILE(decl),
+	DECL_SOURCE_LINE(decl) ) ;
+    DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
+  }
+  if ( flag_mpc_privatize && 
+      TREE_CODE(decl) == VAR_DECL && 
+      ( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) && 
+      !DECL_IN_SYSTEM_HEADER(decl) && 
+      ( !TREE_READONLY( decl ) || !(initializer_constant_valid_p (decl, TREE_TYPE (decl))) ) && 
+      !DECL_THREAD_LOCAL_P(decl)  &&
+	  strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&
+	  strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0
+      ) {
+    fprintf( stderr, 
+	"(Front-end C) Automatic privatization to MPC task (variable %s in file %s line %d)\n",
+	lang_hooks.decl_printable_name (decl,2), 
+	DECL_SOURCE_FILE(decl),
+	DECL_SOURCE_LINE(decl) ) ;
+    DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_TASK ;
+  }
+#endif
+/* MPC TLS END */
+
+
   if (c_dialect_objc () 
       && (TREE_CODE (decl) == VAR_DECL
           || TREE_CODE (decl) == FUNCTION_DECL))
@@ -4909,6 +4968,9 @@ grokdeclarator (const struct c_declarator *declarator,
 {
   tree type = declspecs->type;
   bool threadp = declspecs->thread_p;
+  bool taskp = declspecs->task_p;
+  bool processp = declspecs->process_p;
+  bool openmpp = declspecs->openmp_p;
   enum c_storage_class storage_class = declspecs->storage_class;
   int constp;
   int restrictp;
@@ -6169,8 +6231,22 @@ grokdeclarator (const struct c_declarator *declarator,
 
 	if (threadp)
 	  DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
+	/* MPC TLS BEGIN */
+	if(flag_mpc_privatize)
+	{
+		if(threadp)
+			DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_THREAD;
+		else if(taskp)
+			DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_TASK;
+		else if(processp)
+			DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_PROCESS;
+		else if(openmpp)
+			DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_OPENMP;
+	}
+	/* MPC TLS END */
       }
 
+		
     if ((storage_class == csc_extern
 	 || (storage_class == csc_none
 	     && TREE_CODE (type) == FUNCTION_TYPE
@@ -8818,6 +8894,11 @@ build_null_declspecs (void)
   ret->inline_p = false;
   ret->noreturn_p = false;
   ret->thread_p = false;
+  /* MPC TLS BEGIN */
+  ret->task_p = false;
+  ret->process_p = false;
+  ret->openmp_p = false;
+  /* MPC TLS END */
   ret->const_p = false;
   ret->volatile_p = false;
   ret->restrict_p = false;
@@ -9617,6 +9698,50 @@ declspecs_add_scspec (source_location loc,
 	  specs->locations[cdw_thread] = loc;
 	}
       break;
+	/* MPC TLS BEGIN */
+	case RID_PROCESS:
+      dupe = specs->process_p;
+      if (specs->storage_class == csc_auto)
+	error ("%<__process%> used with %<auto%>");
+      else if (specs->storage_class == csc_register)
+	error ("%<__process%> used with %<register%>");
+      else if (specs->storage_class == csc_typedef)
+	error ("%<__process%> used with %<typedef%>");
+      else
+	{
+	  specs->process_p = true;
+	  specs->locations[cdw_process] = loc;
+	}
+	  break;
+	case RID_TASK:
+      dupe = specs->task_p;
+      if (specs->storage_class == csc_auto)
+	error ("%<__task%> used with %<auto%>");
+      else if (specs->storage_class == csc_register)
+	error ("%<__task%> used with %<register%>");
+      else if (specs->storage_class == csc_typedef)
+	error ("%<__task%> used with %<typedef%>");
+      else
+	{
+	  specs->task_p = true;
+	  specs->locations[cdw_task] = loc;
+	}
+	  break;
+	case RID_OPENMP:
+      dupe = specs->openmp_p;
+      if (specs->storage_class == csc_auto)
+	error ("%<__openmp%> used with %<auto%>");
+      else if (specs->storage_class == csc_register)
+	error ("%<__openmp%> used with %<register%>");
+      else if (specs->storage_class == csc_typedef)
+	error ("%<__openmp%> used with %<typedef%>");
+      else
+	{
+	  specs->openmp_p = true;
+	  specs->locations[cdw_task] = loc;
+	}
+	  break;
+	/* MPC TLS END */
     case RID_AUTO:
       n = csc_auto;
       break;
@@ -9625,6 +9750,14 @@ declspecs_add_scspec (source_location loc,
       /* Diagnose "__thread extern".  */
       if (specs->thread_p)
 	error ("%<__thread%> before %<extern%>");
+	  /* MPC TLS BEGIN */
+	  else if(specs->task_p)
+	error ("%<__task%> before %<extern%>");
+	  else if(specs->process_p)
+	error ("%<__process%> before %<extern%>");
+	  else if(specs->openmp_p)
+	error ("%<__process%> before %<extern%>");
+	  /* MPC TLS END */
       break;
     case RID_REGISTER:
       n = csc_register;
@@ -9634,6 +9767,14 @@ declspecs_add_scspec (source_location loc,
       /* Diagnose "__thread static".  */
       if (specs->thread_p)
 	error ("%<__thread%> before %<static%>");
+	  /* MPC TLS BEGIN */
+	  else if(specs->task_p)
+	error ("%<__task%> before %<static%>");
+	  else if(specs->process_p)
+	error ("%<__process%> before %<static%>");
+	  else if(specs->openmp_p)
+	error ("%<__process%> before %<static%>");
+	  /* MPC TLS END */
       break;
     case RID_TYPEDEF:
       n = csc_typedef;
@@ -9655,11 +9796,23 @@ declspecs_add_scspec (source_location loc,
 	{
 	  specs->storage_class = n;
 	  specs->locations[cdw_storage_class] = loc;
+	  /* MPC TLS BEGIN */
+#if 0
 	  if (n != csc_extern && n != csc_static && specs->thread_p)
-	    {
+	  {
 	      error ("%<__thread%> used with %qE", scspec);
 	      specs->thread_p = false;
+	  }
+#endif
+	  if (n != csc_extern && n != csc_static && (specs->thread_p || specs->process_p || specs->task_p || specs->openmp_p))
+	    {
+	      error ("%<__openmp>, %<__thread%>, %<__task%> or %<__process%> used with %qE", scspec);
+	      specs->thread_p = false;
+	      specs->task_p = false;
+	      specs->process_p = false;
+	      specs->openmp_p = false;
 	    }
+	  /* MPC TLS END */
 	}
     }
   return specs;
@@ -10040,8 +10193,7 @@ collect_all_refs (const char *source_file)
 
 /* Iterate over all global declarations and call CALLBACK.  */
 
-static void
-for_each_global_decl (void (*callback) (tree decl))
+void for_each_global_decl (void (*callback) (tree decl))
 {
   tree t;
   tree decls;
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index 2153273..07aeeda 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -624,6 +624,11 @@ c_token_starts_declspecs (c_token *token)
 	case RID_NORETURN:
 	case RID_AUTO:
 	case RID_THREAD:
+	/* MPC TLS BEGIN */
+	case RID_TASK:
+	case RID_PROCESS:
+	case RID_OPENMP:
+	/* MPC TLS END */
 	case RID_UNSIGNED:
 	case RID_LONG:
 	case RID_INT128:
@@ -1186,6 +1191,12 @@ static void c_parser_omp_flush (c_parser *);
 static void c_parser_omp_taskwait (c_parser *);
 static void c_parser_omp_taskyield (c_parser *);
 
+/* MPC HLS BEGIN */
+static void c_parser_hls_scope(c_parser *);
+static void c_parser_hls_single(c_parser *);
+static void c_parser_hls_barrier(c_parser *);
+/* MPC HLS END */
+
 enum pragma_context { pragma_external, pragma_stmt, pragma_compound };
 static bool c_parser_pragma (c_parser *, enum pragma_context);
 
@@ -2097,6 +2108,11 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,
 	case RID_NORETURN:
 	case RID_AUTO:
 	case RID_THREAD:
+	/* MPC TLS BEGIN */
+	case RID_PROCESS:
+	case RID_TASK:
+	case RID_OPENMP:
+	/* MPC TLS END */
 	  if (!scspec_ok)
 	    goto out;
 	  attrs_ok = true;
@@ -2952,8 +2968,8 @@ c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,
 	       || c_parser_peek_token (parser)->id_kind == C_ID_CLASSNAME))
 	  || c_parser_peek_token (parser)->id_kind == C_ID_ID))
     {
-      struct c_declarator *inner
-	= build_id_declarator (c_parser_peek_token (parser)->value);
+	  struct c_declarator *inner
+       = build_id_declarator (c_parser_peek_token (parser)->value);
       *seen_id = true;
       inner->id_loc = c_parser_peek_token (parser)->location;
       c_parser_consume_token (parser);
@@ -3452,6 +3468,11 @@ c_parser_attribute_any_word (c_parser *parser)
 	case RID_RESTRICT:
 	case RID_COMPLEX:
 	case RID_THREAD:
+	/* MPC TLS BEGIN */
+	case RID_TASK:
+	case RID_PROCESS:
+	case RID_OPENMP:
+	/* MPC TLS END */
 	case RID_INT:
 	case RID_CHAR:
 	case RID_FLOAT:
@@ -3721,7 +3742,7 @@ c_parser_initializer (c_parser *parser)
       ret = c_parser_expr_no_commas (parser, NULL);
       if (TREE_CODE (ret.value) != STRING_CST
 	  && TREE_CODE (ret.value) != COMPOUND_LITERAL_EXPR)
-	ret = default_function_array_read_conversion (loc, ret);
+       ret = default_function_array_read_conversion (loc, ret);
       return ret;
     }
 }
@@ -8608,7 +8629,33 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)
       c_parser_error (parser, "%<#pragma GCC pch_preprocess%> must be first");
       c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);
       return false;
+	
+	/* MPC HLS BEGIN */
+
+    case PRAGMA_HLS_NODE:
+    case PRAGMA_HLS_NUMA:
+    case PRAGMA_HLS_SOCKET:
+    case PRAGMA_HLS_CACHE:
+   case PRAGMA_HLS_CORE:
+      c_parser_hls_scope (parser);
+      return false ;
+
+    case PRAGMA_HLS_SINGLE:
+      c_parser_hls_single (parser);
+      return false ;
+
+    case PRAGMA_HLS_BARRIER:
+      if (context != pragma_compound)
+	{
+	  if (context == pragma_stmt)
+	    c_parser_error (parser, "%<#pragma hls barrier%> may only be "
+			    "used in compound statements");
+	  goto bad_stmt;
+	}
+      c_parser_hls_barrier (parser);
+      return false ;
 
+      /* MPC HLS END */
     default:
       if (id < PRAGMA_FIRST_EXTERNAL)
 	{
@@ -10626,7 +10673,14 @@ c_parser_omp_threadprivate (c_parser *parser)
 	error_at (loc, "%<threadprivate%> %qE has incomplete type", v);
       else
 	{
+	  /* MPC OMP BEGIN */
+		#if 0
 	  if (! DECL_THREAD_LOCAL_P (v))
+		#endif
+		/* Even if this variable is already a TLS, it should be at the
+	     * lowest level (OpenMP in MPC) */
+		if (DECL_TLS_MODEL (v) != TLS_MODEL_MPC_OPENMP)
+	      /* MPC OMP END */
 	    {
 	      DECL_TLS_MODEL (v) = decl_default_tls_model (v);
 	      /* If rtl has been already set for this var, call
@@ -10854,6 +10908,241 @@ c_parser_transaction_cancel(c_parser *parser)
   return build1 (NOP_EXPR, void_type_node, error_mark_node);
 }
 
+
+
+/* MPC HLS BEGIN */
+
+static void c_parser_hls_scope(c_parser *parser) 
+{
+  tree vars, t;
+  enum pragma_kind p_kind;
+  char hls_string[32];
+  enum tls_model tls_type = TLS_MODEL_NONE;
+  int hls_level = 0 ;
+  location_t loc ;
+
+  p_kind = c_parser_peek_token (parser)->pragma_kind;
+  loc = c_parser_peek_token (parser)->location;
+  c_parser_consume_pragma (parser);
+ 
+  /* get variables */
+  vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);
+  
+  /* check if there is a level clause */
+  if ( c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL) ) {
+	  if ( c_parser_next_token_is (parser, CPP_NAME) ) {
+		  const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);
+		  if (strcmp ("level", p) == 0) {
+			  tree t ;
+			  c_parser_consume_token (parser);
+			  c_parser_require (parser, CPP_OPEN_PAREN, "expected %<(%>");
+			  t = c_parser_expr_no_commas (parser, NULL).value;
+			  if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE) {
+				  hls_level = tree_low_cst(t,0);
+			  }else{
+				  c_parser_error (parser, "expected integer expression");
+			  }
+			  if ( hls_level <= 0 ) {
+				  c_parser_error (parser, "HLS: level should be strictly positive");
+				  hls_level = 0 ;
+			  }
+			  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, "expected %<)%>");
+		  }else {
+			  c_parser_error (parser, "HLS: expected %<level%> clause or empty");
+		  }
+	  }else{
+		  c_parser_error (parser, "HLS: expected %<level%> clause or empty");
+	  }
+  }
+  c_parser_skip_to_pragma_eol (parser);
+
+  /* set hls scope and level */
+  switch (p_kind)
+  {
+	  case PRAGMA_HLS_NODE:
+		  tls_type = TLS_MODEL_HLS_NODE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope node") ;
+		  sprintf ( hls_string, "node" );
+		  break;
+	  case PRAGMA_HLS_NUMA:
+		  if ( hls_level > 2 ) {
+			  warning_at (loc, 0, "HLS: max level is 2 for scope numa");
+			  hls_level = 2 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_1 ;
+		  sprintf ( hls_string, "numa level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_SOCKET:
+		  tls_type = TLS_MODEL_HLS_SOCKET ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "socket" );
+		  break;
+	  case PRAGMA_HLS_CACHE:
+		  if ( hls_level > 4 ) {
+			  warning_at (loc, 0, "HLS: max level is 3 for scope cache");
+			  hls_level = 3 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 3 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_3 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_1 ;
+		  sprintf ( hls_string, "cache level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_CORE:
+		  tls_type = TLS_MODEL_HLS_CORE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "core" );
+		  break;
+	  default:
+		  gcc_unreachable ();
+  }
+
+  /* Mark every variable in VARS to be assigned HLS
+     with the corresponding level.  */
+  for (t = vars; t; t = TREE_CHAIN (t))
+  {
+	  tree v = TREE_PURPOSE (t);
+
+	  if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+	  else if (! TREE_STATIC (v) && ! DECL_EXTERNAL (v))
+		  error ("automatic variable %qE cannot be %<HLS-%s%>", v, hls_string);
+	  else if (! COMPLETE_TYPE_P (TREE_TYPE (v))) 
+		  error ("variable %<HLS-%s%> %qE has incomplete type", hls_string, v);
+	  else if (TREE_USED (v) && DECL_TLS_MODEL(v) != tls_type)
+		  error ("%qE declared %<HLS-%s%> after first use", v, hls_string);
+	  else 
+	  {
+		  DECL_TLS_MODEL (v) = tls_type;
+		  if ( flag_mpc_hls_verbose ) {
+			  fprintf( stderr , "HLS: Privatization to scope %s of variable %s (file %s line %d)\n", 
+					  hls_string, IDENTIFIER_POINTER( DECL_NAME(v) ), DECL_SOURCE_FILE(v), DECL_SOURCE_LINE(v) ) ;
+		  } 
+	  }
+  }
+}
+
+static void c_parser_hls_barrier(c_parser *parser) 
+{
+  tree vars, t, x, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, larger_tls_type = TLS_MODEL_HLS_CORE;
+  
+  loc = c_parser_peek_token (parser)->location;
+  c_parser_consume_pragma (parser);
+
+  /* get the larger tls type */
+  vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+
+      if (TREE_CODE (v) != VAR_DECL)
+        error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+        error ("%qD is not declared HLS", v);
+      else if ( tls_type < larger_tls_type )
+        larger_tls_type = tls_type ;
+    } 
+
+  c_parser_skip_to_pragma_eol (parser);
+  
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE ) ;
+  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_BARRIER);
+  x = build_call_expr (x, 1, arg);
+  add_stmt (x);
+  SET_EXPR_LOCATION (x, loc);
+}
+
+
+static void c_parser_hls_single(c_parser *parser) 
+{
+  tree vars, t, x, cond, then_block, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, previous_tls_type = TLS_MODEL_NONE;
+  char clause_nowait = 0 ;
+
+  loc = c_parser_peek_token (parser)->location;
+  c_parser_consume_pragma (parser);
+
+  /* check all vars have the same HLS scope
+	 and store this scope in tls_model */
+  vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+      if ( t == vars )
+        previous_tls_type = tls_type ;
+
+      if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+		  error ("%qD is not declared HLS", v);
+      else if ( tls_type != previous_tls_type )
+		  error ("%qD has incorrect HLS scope", v);
+    } 
+
+  /* get nowait clause */
+  if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL)) {
+	  if (c_parser_next_token_is (parser, CPP_NAME)) {
+		  const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);
+		  if (!strcmp ("nowait", p)) {
+			  clause_nowait = 1 ;
+			  c_parser_consume_token (parser);
+		  }else
+			  c_parser_error (parser, "HLS: expected %<nowait%> clause or empty");
+	  }else{
+		  c_parser_error (parser, "HLS: expected %<nowait%> clause or empty");
+	  }
+  }
+	  
+  c_parser_skip_to_pragma_eol (parser);
+  
+  
+  /* get single body */
+  then_block = push_stmt_list ();
+  c_parser_statement (parser);
+  if ( !clause_nowait ) {
+	  /* in case of blocking single, add a call at the end of the
+	     then block to exit the barrier entered when evaluating
+	     the condition of the if */
+	  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE );
+	  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_SINGLE_DONE);
+	  x = build_call_expr (x, 1, arg);
+	  SET_EXPR_LOCATION (x, loc);
+	  add_stmt (x) ;
+  }
+  then_block = pop_stmt_list (then_block);
+  
+  /* build call to hls_single */
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE );
+  cond = builtin_decl_explicit(clause_nowait ? BUILT_IN_MPC_HLS_SINGLE_NOWAIT : BUILT_IN_MPC_HLS_SINGLE);
+  cond = build_call_expr (cond, 1, arg);
+  SET_EXPR_LOCATION (cond, loc);
+  
+  /* add the if statement */
+  /* if ( hls_single() ) then { block in single ; hls_single_end() ; } */
+  x = build3 (COND_EXPR, void_type_node, cond, then_block, NULL);
+  SET_EXPR_LOCATION (x, loc);
+  add_stmt (x);
+}
+
+/* MPC HLS END */
+
 /* Parse a single source file.  */
 
 void
diff --git a/gcc/c/c-tree.h b/gcc/c/c-tree.h
index 1e6e68a..27e36bc 100644
--- a/gcc/c/c-tree.h
+++ b/gcc/c/c-tree.h
@@ -241,6 +241,11 @@ enum c_declspec_word {
   cdw_inline,
   cdw_noreturn,
   cdw_thread,
+  /* MPC TLS BEGIN */
+  cdw_process,
+  cdw_task,
+  cdw_openmp,
+  /* MPC TLS END */
   cdw_const,
   cdw_volatile,
   cdw_restrict,
@@ -322,6 +327,14 @@ struct c_declspecs {
   BOOL_BITFIELD noreturn_p : 1;
   /* Whether "__thread" was specified.  */
   BOOL_BITFIELD thread_p : 1;
+  /* MPC TLS BEGIN */
+  /* Whether "__process" was specified.  */
+  BOOL_BITFIELD task_p : 1;
+  /* Whether "__task" was specified.  */
+  BOOL_BITFIELD process_p : 1;
+  /* Whether "__openmp" was specified.  */
+  BOOL_BITFIELD openmp_p : 1;
+  /* MPC TLS END */
   /* Whether "const" was specified.  */
   BOOL_BITFIELD const_p : 1;
   /* Whether "volatile" was specified.  */
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
index a608fb6..3e0e008 100644
--- a/gcc/c/c-typeck.c
+++ b/gcc/c/c-typeck.c
@@ -3839,6 +3839,7 @@ build_unary_op (location_t location,
 	  goto return_build_unary_op;
 	}
 
+	  
       val = build1 (ADDR_EXPR, argtype, arg);
 
       ret = val;
@@ -5779,7 +5780,7 @@ store_init_value (location_t init_loc, tree decl, tree init, tree origtype)
   if (init)
     npc = null_pointer_constant_p (init);
   value = digest_init (init_loc, type, init, origtype, npc,
-      		       true, TREE_STATIC (decl));
+      		       true, getenv("MPC_DYN_PRIV_ENABLED")?0:TREE_STATIC( decl ));
 
   /* Store the expression if valid; else report error.  */
 
@@ -6262,8 +6263,11 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,
 	       && !initializer_constant_valid_p (inside_init,
 						 TREE_TYPE (inside_init)))
 	{
-	  error_init ("initializer element is not constant");
-	  inside_init = error_mark_node;
+	  if( !getenv("MPC_DYN_PRIV_ENABLED") )
+	  {
+		  error_init ("initializer element is not constant");
+		  inside_init = error_mark_node;
+	  }
 	}
       else if (require_constant && !maybe_const)
 	pedwarn_init (init_loc, 0,
@@ -6299,22 +6303,25 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,
       /* Check to see if we have already given an error message.  */
       if (inside_init == error_mark_node)
 	;
-      else if (require_constant && !TREE_CONSTANT (inside_init))
-	{
-	  error_init ("initializer element is not constant");
-	  inside_init = error_mark_node;
-	}
-      else if (require_constant
-	       && !initializer_constant_valid_p (inside_init,
-						 TREE_TYPE (inside_init)))
-	{
-	  error_init ("initializer element is not computable at load time");
-	  inside_init = error_mark_node;
+     else
+     {
+		 if( !getenv("MPC_DYN_PRIV_ENABLED") )
+		 {
+		 
+				if (require_constant && !TREE_CONSTANT (inside_init))
+				{
+					error_init ("initializer element is not constant");
+					inside_init = error_mark_node;
+				}
+				else if (require_constant && !initializer_constant_valid_p (inside_init, TREE_TYPE (inside_init)))
+				{
+					error_init ("initializer element is not computable at load time");
+					inside_init = error_mark_node;
+				}
+				else if (require_constant && !maybe_const)
+					pedwarn_init (init_loc, 0, "initializer element is not a constant expression");
+		}
 	}
-      else if (require_constant && !maybe_const)
-	pedwarn_init (init_loc, 0,
-		      "initializer element is not a constant expression");
-
       return inside_init;
     }
 
@@ -7785,8 +7792,11 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,
     {
       if (require_constant_value)
 	{
-	  error_init ("initializer element is not constant");
-	  value = error_mark_node;
+		if( !getenv("MPC_DYN_PRIV_ENABLED") )
+		{
+			error_init ("initializer element is not constant");
+			value = error_mark_node;
+		}
 	}
       else if (require_constant_elements)
 	pedwarn (input_location, 0,
@@ -10801,7 +10811,12 @@ c_finish_omp_clauses (tree clauses)
 	    {
 	      const char *share_name = NULL;
 
+	      /* MPC BEGIN */
+		  #if 0
 	      if (TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))
+	      #endif
+	      if (TREE_CODE (t) == VAR_DECL && DECL_MPC_THREAD_LOCAL_P (t))
+	      /* MPC END */
 		share_name = "threadprivate";
 	      else switch (c_omp_predetermined_sharing (t))
 		{
diff --git a/gcc/cgraphbuild.c b/gcc/cgraphbuild.c
index 8869f52..ff6d451 100644
--- a/gcc/cgraphbuild.c
+++ b/gcc/cgraphbuild.c
@@ -62,6 +62,8 @@ record_reference (tree *tp, int *walk_subtrees, void *data)
   switch (TREE_CODE (t))
     {
     case VAR_DECL:
+		printf("Handle reference to variable\n");
+		break;
     case FUNCTION_DECL:
       gcc_unreachable ();
       break;
diff --git a/gcc/common.opt b/gcc/common.opt
index ec4cafc..a3749a3 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -2259,6 +2259,12 @@ fverbose-asm
 Common Report Var(flag_verbose_asm)
 Add extra commentary to assembler output
 
+; MPC OMP begin
+fopenmp-verbose
+Common Report Var(flag_openmp_verbose)
+Add extra information about the OpenMP transformation
+; MPC OMP end 
+
 fvisibility=
 Common Joined RejectNegative Enum(symbol_visibility) Var(default_visibility) Init(VISIBILITY_DEFAULT)
 -fvisibility=[default|internal|hidden|protected]	Set the default symbol visibility
diff --git a/gcc/config/i386/i386-protos.h b/gcc/config/i386/i386-protos.h
index 602e6fc..35b18e6 100644
--- a/gcc/config/i386/i386-protos.h
+++ b/gcc/config/i386/i386-protos.h
@@ -223,6 +223,24 @@ extern unsigned int ix86_get_callcvt (const_tree);
 
 extern rtx ix86_tls_module_base (void);
 
+/* MPC TLS BEGIN */
+extern rtx ix86_tls_get_addr__openmp_scope (void);
+extern rtx ix86_tls_get_addr__task_scope (void);
+extern rtx ix86_tls_get_addr__process_scope (void);
+extern rtx ix86_tls_get_addr__thread_scope (void);
+/* MPC TLS END */
+
+/* MPC HLS BEGIN */
+extern rtx ix86_tls_get_addr__node_scope (void);
+extern rtx ix86_tls_get_addr__numa_level_2_scope (void);
+extern rtx ix86_tls_get_addr__numa_level_1_scope (void);
+extern rtx ix86_tls_get_addr__socket_scope (void);
+extern rtx ix86_tls_get_addr__cache_level_3_scope (void);
+extern rtx ix86_tls_get_addr__cache_level_2_scope (void);
+extern rtx ix86_tls_get_addr__cache_level_1_scope (void);
+extern rtx ix86_tls_get_addr__core_scope (void);
+/* MPC HLS END */
+
 extern void ix86_expand_vector_init (bool, rtx, rtx);
 extern void ix86_expand_vector_set (bool, rtx, rtx, int);
 extern void ix86_expand_vector_extract (bool, rtx, rtx, int);
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 40dec96..0c83239 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -12748,7 +12748,11 @@ static GTY(()) rtx ix86_tls_symbol;
 static rtx
 ix86_tls_get_addr (void)
 {
-  if (!ix86_tls_symbol)
+  /* MPC TLS BEGIN */
+#if 0
+  if (!ix86_tls_symbol) 
+#endif
+  /* MPC TLS END */
     {
       const char *sym
 	= ((TARGET_ANY_GNU_TLS && !TARGET_64BIT)
@@ -12760,6 +12764,188 @@ ix86_tls_get_addr (void)
   return ix86_tls_symbol;
 }
 
+/* MPC TLS BEGIN */
+rtx
+ix86_tls_get_addr__openmp_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_openmp"
+					    : "__extls_get_addr_openmp");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__process_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_process"
+					    : "__extls_get_addr_process");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__task_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_task"
+					    : "__extls_get_addr_task");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__thread_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_thread"
+					    : "__extls_get_addr_thread");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__node_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_node"
+					    : "__extls_get_addr_node");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__numa_level_2_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_numa_level_2"
+					    : "__extls_get_addr_numa_level_2");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__numa_level_1_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_numa_level_1"
+					    : "__extls_get_addr_numa_level_1");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__socket_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_socket"
+					    : "__extls_get_addr_socket");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__cache_level_3_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_cache_level_3"
+					    : "__extls_get_addr_cache_level_3");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__cache_level_2_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_cache_level_2"
+					    : "__extls_get_addr_cache_level_2");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__cache_level_1_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_cache_level_1"
+					    : "__extls_get_addr_cache_level_1");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__core_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_core"
+					    : "__extls_get_addr_core");
+    }
+
+  return ix86_tls_symbol;
+}
+  /* MPC TLS END */
+  
 /* Construct the SYMBOL_REF for the _TLS_MODULE_BASE_ symbol.  */
 
 static GTY(()) rtx ix86_tls_module_base_symbol;
@@ -12790,9 +12976,106 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)
   rtx pic = NULL_RTX, tp = NULL_RTX;
   enum machine_mode tp_mode = Pmode;
   int type;
-
+/* MPC HLS BEGIN */
+  rtx (*gen_tls_mpc_routine_32)(rtx,rtx) = NULL;
+  rtx (*gen_tls_mpc_routine_64)(rtx,rtx) = NULL;
   switch (model)
     {
+	case TLS_MODEL_MPC_PROCESS:
+		gen_tls_mpc_routine_64 = &gen_tls_mpc_process_64 ;
+		gen_tls_mpc_routine_32 = &gen_tls_mpc_process_32 ;
+		break;
+	case TLS_MODEL_MPC_TASK:
+		gen_tls_mpc_routine_64 = &gen_tls_mpc_task_64 ;
+		gen_tls_mpc_routine_32 = &gen_tls_mpc_task_32 ;
+		break;
+	case TLS_MODEL_MPC_THREAD:
+		gen_tls_mpc_routine_64 = &gen_tls_mpc_thread_64 ;
+		gen_tls_mpc_routine_32 = &gen_tls_mpc_thread_32 ;
+		break;
+	case TLS_MODEL_MPC_OPENMP:
+		gen_tls_mpc_routine_64 = &gen_tls_mpc_openmp_64 ;
+		gen_tls_mpc_routine_32 = &gen_tls_mpc_openmp_32 ;
+		break;
+    case TLS_MODEL_HLS_NODE:
+	  gen_tls_mpc_routine_64 = &gen_tls_hls_node_64 ;
+	  gen_tls_mpc_routine_32 = &gen_tls_hls_node_32 ;
+	  break;
+    case TLS_MODEL_HLS_NUMA_LEVEL_2:
+	  gen_tls_mpc_routine_64 = &gen_tls_hls_numa_level_2_64 ;
+	  gen_tls_mpc_routine_32 = &gen_tls_hls_numa_level_2_32 ;
+	  break;
+    case TLS_MODEL_HLS_NUMA_LEVEL_1:
+	  gen_tls_mpc_routine_64 = &gen_tls_hls_numa_level_1_64 ;
+	  gen_tls_mpc_routine_32 = &gen_tls_hls_numa_level_1_32 ;
+	  break;
+    case TLS_MODEL_HLS_SOCKET:
+	  gen_tls_mpc_routine_64 = &gen_tls_hls_socket_64 ;
+	  gen_tls_mpc_routine_32 = &gen_tls_hls_socket_32 ;
+	  break;
+    case TLS_MODEL_HLS_CACHE_LEVEL_3:
+	  gen_tls_mpc_routine_64 = &gen_tls_hls_cache_level_3_64 ;
+	  gen_tls_mpc_routine_32 = &gen_tls_hls_cache_level_3_32 ;
+	  break;
+    case TLS_MODEL_HLS_CACHE_LEVEL_2:
+	  gen_tls_mpc_routine_64 = &gen_tls_hls_cache_level_2_64 ;
+	  gen_tls_mpc_routine_32 = &gen_tls_hls_cache_level_2_32 ;
+	  break;
+    case TLS_MODEL_HLS_CACHE_LEVEL_1:
+	  gen_tls_mpc_routine_64 = &gen_tls_hls_cache_level_1_64 ;
+	  gen_tls_mpc_routine_32 = &gen_tls_hls_cache_level_1_32 ;
+	  break;
+    case TLS_MODEL_HLS_CORE:
+	  gen_tls_mpc_routine_64 = &gen_tls_hls_core_64 ;
+	  gen_tls_mpc_routine_32 = &gen_tls_hls_core_32 ;
+	  break;
+	default:
+	  ;
+	}
+/* MPC HLS END */
+  switch (model)
+    {
+	/* MPC TLS BEGIN */
+	case TLS_MODEL_MPC_PROCESS:
+	case TLS_MODEL_MPC_TASK:
+	case TLS_MODEL_MPC_THREAD:
+	case TLS_MODEL_MPC_OPENMP:
+    case TLS_MODEL_HLS_NODE:
+    case TLS_MODEL_HLS_NUMA_LEVEL_2:
+    case TLS_MODEL_HLS_NUMA_LEVEL_1:
+    case TLS_MODEL_HLS_SOCKET:
+    case TLS_MODEL_HLS_CACHE_LEVEL_3:
+    case TLS_MODEL_HLS_CACHE_LEVEL_2:
+    case TLS_MODEL_HLS_CACHE_LEVEL_1:
+    case TLS_MODEL_HLS_CORE:
+      dest = gen_reg_rtx (Pmode);
+      tp = TARGET_GNU2_TLS ? get_thread_pointer (Pmode, true) : 0;
+
+      if (TARGET_64BIT && ! TARGET_GNU2_TLS)
+	{
+	  rtx rax = gen_rtx_REG (Pmode, AX_REG), insns;
+
+	  start_sequence ();
+	  emit_call_insn (gen_tls_mpc_routine_64 (rax, x));
+	  insns = get_insns ();
+	  end_sequence ();
+
+	  RTL_CONST_CALL_P (insns) = 1;
+	  emit_libcall_block (insns, dest, rax, x);
+	}
+      else if (TARGET_64BIT && TARGET_GNU2_TLS)
+	emit_insn (gen_tls_mpc_routine_64 (dest, x));
+      else
+	emit_insn (gen_tls_mpc_routine_32 (dest, x));
+
+      if (TARGET_GNU2_TLS)
+	{
+	  dest = force_reg (Pmode, gen_rtx_PLUS (Pmode, tp, dest));
+
+	  set_unique_reg_note (get_last_insn (), REG_EQUIV, x);
+	}
+      break;
+      /* MPC TLS END */
     case TLS_MODEL_GLOBAL_DYNAMIC:
       dest = gen_reg_rtx (Pmode);
 
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index c08a224..5395567 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -12695,6 +12695,344 @@
      (clobber (match_scratch:SI 5))
      (clobber (reg:CC FLAGS_REG))])])
 
+;; MPC TLS BEGIN
+(define_expand "tls_mpc_openmp_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__openmp_scope();
+})
+
+(define_expand "tls_mpc_process_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__process_scope();
+})
+
+(define_expand "tls_mpc_thread_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__thread_scope();
+})
+
+(define_expand "tls_mpc_task_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__task_scope();
+})
+
+(define_expand "tls_hls_node_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__node_scope();
+})
+
+(define_expand "tls_hls_numa_level_2_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__numa_level_2_scope();
+})
+
+(define_expand "tls_hls_numa_level_1_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__numa_level_1_scope();
+})
+
+(define_expand "tls_hls_socket_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__socket_scope();
+})
+
+(define_expand "tls_hls_cache_level_3_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__cache_level_3_scope();
+})
+
+(define_expand "tls_hls_cache_level_2_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__cache_level_2_scope();
+})
+
+(define_expand "tls_hls_cache_level_1_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__cache_level_1_scope();
+})
+
+(define_expand "tls_hls_core_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__core_scope();
+})
+;; MPC TLS END
+
 (define_insn "*tls_global_dynamic_64_<mode>"
   [(set (match_operand:P 0 "register_operand" "=a")
 	(call:P
@@ -12728,6 +13066,194 @@
 	       UNSPEC_TLS_GD)])]
   "TARGET_64BIT")
 
+
+;; MPC TLS BEGIN
+(define_expand "tls_mpc_openmp_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__openmp_scope ();
+})
+
+(define_expand "tls_mpc_process_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__process_scope ();
+})
+
+(define_expand "tls_mpc_task_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__task_scope ();
+})
+
+(define_expand "tls_mpc_thread_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__thread_scope ();
+})
+
+(define_expand "tls_hls_node_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__node_scope ();
+})
+(define_expand "tls_hls_numa_level_2_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__numa_level_2_scope ();
+})
+(define_expand "tls_hls_numa_level_1_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__numa_level_1_scope ();
+})
+(define_expand "tls_hls_socket_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__socket_scope ();
+})
+(define_expand "tls_hls_cache_level_3_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__cache_level_3_scope ();
+})
+(define_expand "tls_hls_cache_level_2_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__cache_level_2_scope ();
+})
+(define_expand "tls_hls_cache_level_1_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__cache_level_1_scope ();
+})
+(define_expand "tls_hls_core_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__core_scope ();
+})
+;; MPC TLS END
+
 (define_insn "*tls_local_dynamic_base_32_gnu"
   [(set (match_operand:SI 0 "register_operand" "=a")
 	(unspec:SI
diff --git a/gcc/coretypes.h b/gcc/coretypes.h
index 320b4dd..35fabce 100644
--- a/gcc/coretypes.h
+++ b/gcc/coretypes.h
@@ -107,7 +107,23 @@ enum tls_model {
   TLS_MODEL_GLOBAL_DYNAMIC = TLS_MODEL_REAL,
   TLS_MODEL_LOCAL_DYNAMIC,
   TLS_MODEL_INITIAL_EXEC,
-  TLS_MODEL_LOCAL_EXEC
+  TLS_MODEL_LOCAL_EXEC,
+  /* MPC TLS BEGIN */
+  TLS_MODEL_MPC_OPENMP,
+  TLS_MODEL_MPC_THREAD,
+  TLS_MODEL_MPC_TASK,
+  TLS_MODEL_MPC_PROCESS,
+  /* MPC TLS END */
+  /* MPC HLS BEGIN */
+  TLS_MODEL_HLS_NODE,
+  TLS_MODEL_HLS_NUMA_LEVEL_2,
+  TLS_MODEL_HLS_NUMA_LEVEL_1,
+  TLS_MODEL_HLS_SOCKET,
+  TLS_MODEL_HLS_CACHE_LEVEL_3,
+  TLS_MODEL_HLS_CACHE_LEVEL_2,
+  TLS_MODEL_HLS_CACHE_LEVEL_1,
+  TLS_MODEL_HLS_CORE
+  /* MPC HLS END */
 };
 
 /* Types of unwind/exception handling info that can be generated.  */
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index b0b79f8..315290f 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -5771,6 +5771,10 @@ extern tree nonlambda_method_basetype		(void);
 extern void maybe_add_lambda_conv_op            (tree);
 extern bool is_lambda_ignored_entity            (tree);
 
+/* MPC HLS BEGIN */
+extern void finish_hls_scope			(tree vars);
+/* MPC HLS END */
+
 /* in tree.c */
 extern int cp_tree_operand_length		(const_tree);
 void cp_free_lang_data 				(tree t);
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 6faf3fd..77a8f7b 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -1892,6 +1892,17 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)
 	      DECL_TLS_MODEL (newdecl) = DECL_TLS_MODEL (olddecl);
 	      CP_DECL_THREADPRIVATE_P (newdecl) = 1;
 	    }
+	    /* MPC HLS BEGIN */
+	  if (DECL_LANG_SPECIFIC (olddecl)
+	      && DECL_TLS_MODEL (olddecl) >= TLS_MODEL_HLS_NODE )
+	    {
+	      /* Allocate a LANG_SPECIFIC structure for NEWDECL, if needed.  */
+	      if (!DECL_LANG_SPECIFIC (newdecl))
+		retrofit_lang_decl (newdecl);
+
+	      DECL_TLS_MODEL (newdecl) = DECL_TLS_MODEL (olddecl);
+	    }
+           /* MPC HLS END */
 	}
 
       /* Do this after calling `merge_types' so that default
@@ -2549,7 +2560,12 @@ redeclaration_error_message (tree newdecl, tree olddecl)
 	   && DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl)
 	   && (! DECL_LANG_SPECIFIC (olddecl)
 	       || ! CP_DECL_THREADPRIVATE_P (olddecl)
+	       || DECL_THREAD_LOCAL_P (newdecl))
+	       /* MPC HLS BEGIN */
+	   && (! DECL_LANG_SPECIFIC (olddecl)
+	       || ! DECL_TLS_MODEL (olddecl) >= TLS_MODEL_HLS_NODE 
 	       || DECL_THREAD_LOCAL_P (newdecl)))
+/* MPC HLS END */
     {
       /* Only variables can be thread-local, and all declarations must
 	 agree on this property.  */
@@ -4533,6 +4550,46 @@ start_decl (const cp_declarator *declarator,
       && lookup_attribute ("noinline", DECL_ATTRIBUTES (decl)))
     warning (0, "inline function %q+D given attribute noinline", decl);
 
+/* MPC TLS BEGIN */
+  if ( flag_mpi_privatize &&
+	TREE_CODE(decl) == VAR_DECL &&
+	( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) &&
+	!DECL_IN_SYSTEM_HEADER(decl) &&
+	!TREE_READONLY( decl ) &&
+	!TREE_CONSTANT( decl ) &&
+	!DECL_THREAD_LOCAL_P(decl) &&
+    strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&
+	strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0
+  ) {
+    fprintf( stderr,
+      "(Front-end C++) Automatic privatization to TLS "
+      "(variable %s in file %s line %d)\n",
+      lang_decl_name( decl, 2 , 0),
+      DECL_SOURCE_FILE(decl),
+      DECL_SOURCE_LINE(decl) ) ;
+    DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
+  }
+  if ( flag_mpc_privatize &&
+	TREE_CODE(decl) == VAR_DECL &&
+	( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) &&
+	!DECL_IN_SYSTEM_HEADER(decl) &&
+	!TREE_READONLY( decl ) &&
+	!TREE_CONSTANT( decl ) &&
+	DECL_TLS_MODEL(decl) != TLS_MODEL_MPC_TASK &&
+	!DECL_THREAD_LOCAL_P(decl) &&
+    strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&
+	strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0
+  ) {
+		fprintf( stderr,
+		  "(Front-end C++) Automatic privatization to MPC task "
+		  "(variable %s in file %s line %d)\n",
+		  lang_decl_name( decl, 2 , 0),
+		  DECL_SOURCE_FILE(decl),
+		  DECL_SOURCE_LINE(decl) ) ;
+		DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_TASK ;
+  }
+  /* MPC TLS END */
+  
   if (TYPE_P (context) && COMPLETE_TYPE_P (complete_type (context)))
     {
       if (TREE_CODE (decl) == VAR_DECL)
@@ -6122,6 +6179,20 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
       && (DECL_INITIAL (decl) || init))
     DECL_INITIALIZED_IN_CLASS_P (decl) = 1;
 
+  /* MPC BEGIN */
+  if ( flag_mpc_privatize && 
+      (DECL_TLS_MODEL(decl) == TLS_MODEL_MPC_TASK) && 
+      (TREE_READONLY( decl ) || TREE_CONSTANT( decl ) ) ) 
+  {
+    fprintf( stderr, "(Front-end C++) Automatic un-privatization from MPC task"
+        "(variable %s in file %s line %d)\n",
+        lang_decl_name( decl, 2 , 0),
+        DECL_SOURCE_FILE(decl),
+        DECL_SOURCE_LINE(decl) ) ;
+    DECL_TLS_MODEL(decl) = TLS_MODEL_NONE ;
+  }
+  /* MPC END */
+
   if (TREE_CODE (decl) != FUNCTION_DECL
       && (auto_node = type_uses_auto (type)))
     {
@@ -6518,6 +6589,20 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
     TREE_READONLY (decl) = 1;
 
   invoke_plugin_callbacks (PLUGIN_FINISH_DECL, decl);
+  
+  /* MPC TLS BEGIN */
+	  if ( flag_mpc_privatize && 
+			  (DECL_TLS_MODEL(decl) == TLS_MODEL_MPC_TASK) && 
+			  (TREE_READONLY( decl ) || TREE_CONSTANT( decl ) ) ) 
+	  {
+		  fprintf( stderr, "(Front-end C++)-DECL Automatic unprivating from MPC task"
+	  		"(variable %s in file %s line %d)\n",
+				  lang_decl_name( decl, 2 , 0),
+	  			  DECL_SOURCE_FILE(decl),
+				  DECL_SOURCE_LINE(decl) ) ;
+		  DECL_TLS_MODEL(decl) = TLS_MODEL_NONE ;
+	  }
+  /* MPC TLS END */
 }
 
 /* Returns a declaration for a VAR_DECL as if:
@@ -6670,6 +6755,24 @@ get_thread_atexit_node (void)
   return decay_conversion (atexit_fndecl, tf_warning_or_error);
 }
 
+/* MPC BEGIN */
+static tree
+get_thread_mpc_atexit_node(void)
+{
+  /* The declaration for `__cxa_thread_atexit' is:
+
+     int __cxa_thread_atexit (void (*)(void *), void *, void *) */
+  tree fn_type = build_function_type_list (integer_type_node,
+					   get_atexit_fn_ptr_type (),
+					   ptr_type_node, ptr_type_node,
+					   NULL_TREE);
+
+  /* Now, build the function declaration.  */
+  tree atexit_fndecl = build_library_fn_ptr ("__cxa_thread_mpc_atexit", fn_type);
+  return decay_conversion (atexit_fndecl, tf_warning_or_error);
+}
+/* MPC END */
+
 /* Returns the __dso_handle VAR_DECL.  */
 
 static tree
@@ -6821,11 +6924,21 @@ register_dtor_fn (tree decl)
   /* Call atexit with the cleanup function.  */
   mark_used (cleanup);
   cleanup = build_address (cleanup);
-
+  
+  /* MPC BEGIN */
+  if(flag_mpc_privatize 
+		  && DECL_TLS_MODEL(decl) == TLS_MODEL_MPC_TASK) 
+  {
+	  atex_node = get_thread_mpc_atexit_node();
+  }
+  else
+  {
   if (DECL_THREAD_LOCAL_P (decl))
     atex_node = get_thread_atexit_node ();
   else
     atex_node = get_atexit_node ();
+  }
+  /*MPC END */
 
   if (use_dtor)
     {
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 1a604a4..6a089b2 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -970,7 +970,42 @@ grokfield (const cp_declarator *declarator,
 	    }
 	}
     }
-
+    
+/* MPC TLS BEGIN */
+  if ( flag_mpi_privatize &&
+	TREE_CODE(value) == VAR_DECL &&
+	( TREE_STATIC( value ) || DECL_EXTERNAL(value) ) &&
+	!DECL_IN_SYSTEM_HEADER(value) &&
+	!TREE_READONLY( value ) &&
+	!TREE_CONSTANT( value ) &&
+	!DECL_THREAD_LOCAL_P(value)
+  ) {
+    fprintf( stderr,
+      "(Front-end C++) Automatic privatization to TLS "
+      "(variable %s in file %s line %d)\n",
+      lang_decl_name( value, 2 , 0),
+      DECL_SOURCE_FILE(value),
+      DECL_SOURCE_LINE(value) ) ;
+      DECL_TLS_MODEL (value) = decl_default_tls_model (value);
+  }
+  if ( flag_mpc_privatize &&
+	TREE_CODE(value) == VAR_DECL &&
+	( TREE_STATIC( value ) || DECL_EXTERNAL(value) ) &&
+	!DECL_IN_SYSTEM_HEADER(value) &&
+	!TREE_READONLY( value ) &&
+	!TREE_CONSTANT( value ) &&
+	!DECL_THREAD_LOCAL_P(value)
+  ) {
+		fprintf( stderr,
+		  "(Front-end C++) Automatic privatization to MPC task "
+		  "(variable %s in file %s line %d)\n",
+		  lang_decl_name( value, 2 , 0),
+		  DECL_SOURCE_FILE(value),
+		  DECL_SOURCE_LINE(value) ) ;
+		DECL_TLS_MODEL(value) = TLS_MODEL_MPC_TASK ;
+  }
+  /* MPC TLS END */
+  
   if (processing_template_decl
       && (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == FUNCTION_DECL))
     {
@@ -992,8 +1027,22 @@ grokfield (const cp_declarator *declarator,
     {
     case VAR_DECL:
       finish_static_data_member_decl (value, init, init_const_expr_p,
-				      asmspec_tree, flags);
-      return value;
+			  asmspec_tree, flags);
+	  /* MPC TLS BEGIN */
+	  if ( flag_mpc_privatize && 
+			  (DECL_TLS_MODEL(value) == TLS_MODEL_MPC_TASK) && 
+			  (TREE_READONLY( value ) || TREE_CONSTANT( value ) ) ) 
+	  {
+		  fprintf( stderr,
+				  "(Front-end C++) Automatic un-privatization from MPC task "
+				  "(variable %s in file %s line %d)\n",
+				  lang_decl_name( value, 2 , 0),
+				  DECL_SOURCE_FILE(value),
+				  DECL_SOURCE_LINE(value) ) ;
+		  DECL_TLS_MODEL(value) = TLS_MODEL_NONE ;
+	  }
+	  /* MPC TLS END */
+	  return value;
 
     case FIELD_DECL:
       if (asmspec)
@@ -3923,7 +3974,19 @@ handle_tls_init (void)
   DECL_ARTIFICIAL (guard) = true;
   DECL_IGNORED_P (guard) = true;
   TREE_USED (guard) = true;
+  /* MPC BEGIN */
+  #if 0
   DECL_TLS_MODEL (guard) = decl_default_tls_model (guard);
+  #endif
+  if(flag_mpc_privatize)
+  {
+    DECL_TLS_MODEL (guard) = TLS_MODEL_MPC_TASK;
+  }
+  else
+  {
+    DECL_TLS_MODEL (guard) = decl_default_tls_model (guard);
+  }
+  /* MPC END */
   pushdecl_top_level_and_finish (guard, NULL_TREE);
 
   tree fn = get_local_tls_init_fn ();
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 6d8bef4..5741ab1 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -22934,7 +22934,6 @@ set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,
 			     cp_decl_spec ds, cp_token *token)
 {
   gcc_assert (ds < ds_last);
-
   if (decl_specs == NULL)
     return;
 
@@ -22944,7 +22943,7 @@ set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,
     {
       decl_specs->locations[ds] = location;
       if (ds == ds_thread)
-	decl_specs->gnu_thread_keyword_p = token_is__thread (token);
+		decl_specs->gnu_thread_keyword_p = token_is__thread (token);
     }
   else
     {
@@ -27826,6 +27825,267 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)
     SET_EXPR_LOCATION (stmt, pragma_tok->location);
 }
 
+
+
+/* MPC HLS BEGIN */
+static void
+cp_parser_hls_scope(cp_parser *parser, cp_token *pragma_tok)
+{
+  tree vars,t;
+  char hls_string[32];
+  enum tls_model tls_type;
+  const unsigned int id = pragma_tok->pragma_kind;
+  const location_t loc = pragma_tok->location;
+  int hls_level = 0 ;
+
+  /* get variables */
+  vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);
+
+  /* check if there is a level clause */
+  if ( cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL) ) {
+	  if ( cp_lexer_next_token_is (parser->lexer, CPP_NAME) ) {
+		  tree id = cp_lexer_peek_token (parser->lexer)->u.value;
+		  const char *p = IDENTIFIER_POINTER (id);
+		  if (strcmp ("level", p) == 0) {
+			  tree t;
+			  cp_lexer_consume_token (parser->lexer);
+			  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);
+			  t = cp_parser_constant_expression (parser, false, NULL);
+			  t = fold_non_dependent_expr (t);
+			  if (INTEGRAL_TYPE_P (TREE_TYPE (t))) {
+				  hls_level = tree_low_cst(t,0);
+				  if ( hls_level <= 0 ) {
+					  cp_parser_error (parser, "HLS: level should be strictly positive");
+					  hls_level = 0 ;
+					  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+				  }else{
+					  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);
+				  }
+			  }else{
+				  cp_parser_error (parser,"HLS: level argument needs positive constant integer expression");
+				  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+			  }
+		  }else{
+			  cp_parser_error (parser, "HLS: expected %<level%> clause or empty");
+			  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+		  }
+	  }else{
+		  cp_parser_error (parser, "HLS: expected %<level%> clause or empty");
+		  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+	  }
+  }
+
+  cp_parser_require_pragma_eol (parser, pragma_tok);
+
+  switch (id)
+  {
+	  case PRAGMA_HLS_NODE:
+		  tls_type = TLS_MODEL_HLS_NODE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope node") ;
+		  sprintf ( hls_string, "node" );
+		  break;
+	  case PRAGMA_HLS_NUMA:
+		  if ( hls_level > 2 ) {
+			  warning_at (loc, 0, "HLS: max level is 2 for scope numa");
+			  hls_level = 2 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_1 ;
+		  sprintf ( hls_string, "numa level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_SOCKET:
+		  tls_type = TLS_MODEL_HLS_SOCKET ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "socket" );
+		  break;
+	  case PRAGMA_HLS_CACHE:
+		  if ( hls_level > 4 ) {
+			  warning_at (loc, 0, "HLS: max level is 3 for scope cache");
+			  hls_level = 3 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 3 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_3 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_1 ;
+		  sprintf ( hls_string, "cache level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_CORE:
+		  tls_type = TLS_MODEL_HLS_CORE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "core" );
+		  break;
+	  default:
+		  gcc_unreachable ();
+  }
+
+  /* Mark every variable in VARS to be assigned HLS
+	 with the corresponding level.  */
+  for (t = vars; t; t = TREE_CHAIN (t))
+  {
+	  tree v = TREE_PURPOSE (t);
+
+	  if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+      else if (! TREE_STATIC (v) && ! DECL_EXTERNAL (v))
+		  error ("automatic variable %qE cannot be %<HLS-%s%>", v, hls_string);
+      else if (! COMPLETE_TYPE_P (TREE_TYPE (v))) 
+		  error ("variable %<HLS-%s%> %qE has incomplete type", hls_string, v);
+      else if (TREE_USED (v) && DECL_TLS_MODEL(v) != tls_type ) 
+		  error ("%qE declared %<HLS-%s%> after first use", v, hls_string);
+      else if (TREE_STATIC (v) && TYPE_P (CP_DECL_CONTEXT (v))
+	       && CP_DECL_CONTEXT (v) != current_class_type)
+		  error ("%<HLS-%s%> %qE directive not "
+	       "in %qT definition", hls_string, v, CP_DECL_CONTEXT (v));
+      else 
+	  {
+		  /* Allocate a LANG_SPECIFIC structure for V, if needed.  */
+		  if (DECL_LANG_SPECIFIC (v) == NULL)
+		  {
+			  retrofit_lang_decl (v);
+
+			  /* Make sure that DECL_DISCRIMINATOR_P continues to be true
+				 after the allocation of the lang_decl structure.  */
+			  if (DECL_DISCRIMINATOR_P (v))
+				  DECL_LANG_SPECIFIC (v)->u.base.u2sel = 1;
+		  }
+		  DECL_TLS_MODEL (v) = tls_type ;
+		  {
+			  /* If rtl has been already set for this var, call
+				 make_decl_rtl once again, so that encode_section_info
+				 has a chance to look at the new decl flags.  */
+			  if (DECL_RTL_SET_P (v))
+				  make_decl_rtl (v);
+		  }
+		  if ( flag_mpc_hls_verbose ) {
+			  fprintf( stderr , "HLS: Privatization to %s scope of variable %s (file %s line %d)\n",
+					  hls_string, IDENTIFIER_POINTER( DECL_NAME(v) ),
+					  DECL_SOURCE_FILE(v), DECL_SOURCE_LINE(v) ) ;
+		  } 
+	  }
+	}
+}
+
+static void
+cp_parser_hls_barrier(cp_parser *parser, cp_token *pragma_tok)
+{
+  tree vars, t, x, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, larger_tls_type = TLS_MODEL_NONE;
+
+  larger_tls_type = TLS_MODEL_HLS_CORE ;
+  
+  loc = pragma_tok->location;
+
+  /* get the larger tls type */
+  vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+
+      if (TREE_CODE (v) != VAR_DECL)
+        error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+        error ("%qD is not declared HLS", v);
+      else if ( tls_type < larger_tls_type )
+        larger_tls_type = tls_type ;
+    } 
+
+  cp_parser_require_pragma_eol (parser, pragma_tok);
+  
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE ) ;
+  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_BARRIER);
+  x = build_call_expr (x, 1, arg);
+  add_stmt (x);
+  SET_EXPR_LOCATION (x, loc);
+}
+
+static void
+cp_parser_hls_single(cp_parser *parser, cp_token *pragma_tok) {
+  tree vars, t, x, cond, then_block, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, previous_tls_type = TLS_MODEL_NONE;
+  char clause_nowait = 0 ;
+
+  loc = pragma_tok->location;
+
+  /* check all vars have the same HLS scope
+	 and store this scope in tls_model */
+  vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+      if ( t == vars )
+        previous_tls_type = tls_type ;
+
+      if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+		  error ("%qD is not declared HLS", v);
+      else if ( tls_type != previous_tls_type )
+		  error ("%qD has incorrect HLS scope", v);
+    } 
+
+  /* get nowait clause */
+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)) {
+	  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)) {
+		  tree id = cp_lexer_peek_token (parser->lexer)->u.value;
+		  const char *p = IDENTIFIER_POINTER (id);
+		  if (!strcmp ("nowait", p)) {
+			  clause_nowait = 1 ;
+			  cp_lexer_consume_token (parser->lexer);
+		  }else{
+			  cp_parser_error (parser, "expected %<nowait%> clause or empty");
+			  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+		  }
+	  }else{
+		  cp_parser_error (parser, "expected %<nowait%> clause or empty");
+		  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+	  }
+  }
+	  
+  cp_parser_require_pragma_eol (parser, pragma_tok);
+
+  /* get single body */
+  then_block = push_stmt_list ();
+  cp_parser_statement (parser, NULL_TREE, false, NULL);
+  if ( !clause_nowait ) {
+	  /* in case of blocking single, add a call at the end of the
+	     then block to exit the barrier entered when evaluating
+	     the condition of the if */
+	  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE );
+	  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_SINGLE_DONE);
+	  x = build_call_expr (x, 1, arg);
+	  SET_EXPR_LOCATION (x, loc);
+	  add_stmt (x) ;
+  }
+  then_block = pop_stmt_list (then_block);
+  
+  /* add the if statement */
+  /* if ( hls_single() ) then { then_block ; hls_single_done(); } */
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE ) ;
+  cond = builtin_decl_explicit(clause_nowait ? BUILT_IN_MPC_HLS_SINGLE_NOWAIT : BUILT_IN_MPC_HLS_SINGLE);
+  cond = build_call_expr (cond, 1, arg);
+  SET_EXPR_LOCATION (cond, loc);
+  x = build3 (COND_EXPR, void_type_node, cond, then_block, NULL);
+  SET_EXPR_LOCATION (x, loc);
+  add_stmt (x);
+}
+
+/* MPC HLS END */
+
 /* Transactional Memory parsing routines.  */
 
 /* Parse a transaction attribute.
@@ -28267,7 +28527,25 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)
 		"%<#pragma omp section%> may only be used in "
 		"%<#pragma omp sections%> construct");
       break;
+	/* MPC HLS BEGIN */
+
+    case PRAGMA_HLS_NODE:
+    case PRAGMA_HLS_NUMA:
+    case PRAGMA_HLS_SOCKET:
+    case PRAGMA_HLS_CACHE:
+    case PRAGMA_HLS_CORE:
+      cp_parser_hls_scope (parser, pragma_tok);
+      return false ;
+
+    case PRAGMA_HLS_BARRIER:
+      cp_parser_hls_barrier (parser, pragma_tok);
+      return false ;
+
+    case PRAGMA_HLS_SINGLE:
+      cp_parser_hls_single (parser, pragma_tok);
+      return false ;
 
+      /* MPC HLS END */
     default:
       gcc_assert (id >= PRAGMA_FIRST_EXTERNAL);
       c_invoke_pragma_handler (id);
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index b833b07..84c757b 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -4466,7 +4466,12 @@ finish_omp_threadprivate (tree vars)
 
 	  if (! DECL_THREAD_LOCAL_P (v))
 	    {
+			/* MPC OMP BEGIN */
+			#if 0
 	      DECL_TLS_MODEL (v) = decl_default_tls_model (v);
+			#endif
+	      DECL_TLS_MODEL (v) = TLS_MODEL_MPC_OPENMP ;
+			/* MPC OMP END */
 	      /* If rtl has been already set for this var, call
 		 make_decl_rtl once again, so that encode_section_info
 		 has a chance to look at the new decl flags.  */
@@ -5094,7 +5099,10 @@ finish_omp_atomic (enum tree_code code, enum tree_code opcode, tree lhs,
 void
 finish_omp_barrier (void)
 {
+ #if 0
   tree fn = builtin_decl_explicit (BUILT_IN_GOMP_BARRIER);
+#endif
+  tree fn = builtin_decl_explicit (BUILT_IN_MPC_BARRIER);
   vec<tree, va_gc> *vec = make_tree_vector ();
   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);
   release_tree_vector (vec);
@@ -5104,7 +5112,10 @@ finish_omp_barrier (void)
 void
 finish_omp_flush (void)
 {
+  #if 0
   tree fn = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);
+  #endif
+  tree fn = builtin_decl_explicit (BUILT_IN_MPC_FLUSH);
   vec<tree, va_gc> *vec = make_tree_vector ();
   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);
   release_tree_vector (vec);
@@ -5114,7 +5125,10 @@ finish_omp_flush (void)
 void
 finish_omp_taskwait (void)
 {
-  tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);
+  #if 0
+  	tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);
+  #endif
+  tree fn = builtin_decl_explicit (BUILT_IN_MPC_TASKWAIT);
   vec<tree, va_gc> *vec = make_tree_vector ();
   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);
   release_tree_vector (vec);
@@ -5124,7 +5138,10 @@ finish_omp_taskwait (void)
 void
 finish_omp_taskyield (void)
 {
-  tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD);
+  #if 0
+  	tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD);
+  #endif
+  tree fn = builtin_decl_explicit (BUILT_IN_MPC_TASKYIELD);
   vec<tree, va_gc> *vec = make_tree_vector ();
   tree stmt = finish_call_expr (fn, &vec, false, false, tf_warning_or_error);
   release_tree_vector (vec);
diff --git a/gcc/fortran/Make-lang.in b/gcc/fortran/Make-lang.in
index 8c9e7ea..ecc57a9 100644
--- a/gcc/fortran/Make-lang.in
+++ b/gcc/fortran/Make-lang.in
@@ -58,7 +58,7 @@ F95_PARSER_OBJS = fortran/arith.o fortran/array.o fortran/bbt.o \
     fortran/iresolve.o fortran/match.o fortran/matchexp.o fortran/misc.o \
     fortran/module.o fortran/openmp.o fortran/options.o fortran/parse.o \
     fortran/primary.o fortran/resolve.o fortran/scanner.o fortran/simplify.o \
-    fortran/st.o fortran/symbol.o fortran/target-memory.o
+    fortran/st.o fortran/symbol.o fortran/target-memory.o fortran/hls.o
 
 F95_OBJS = $(F95_PARSER_OBJS) $(FORTRAN_TARGET_OBJS) \
     fortran/convert.o fortran/dependency.o fortran/f95-lang.o \
diff --git a/gcc/fortran/f95-lang.c b/gcc/fortran/f95-lang.c
index 60d790b..7e3eb37 100644
--- a/gcc/fortran/f95-lang.c
+++ b/gcc/fortran/f95-lang.c
@@ -1019,14 +1019,36 @@ gfc_init_builtin_functions (void)
 #include "../sync-builtins.def"
 #undef DEF_SYNC_BUILTIN
 
+/* MPC HLS BEGIN */
+  if (gfc_option.flag_hls)
+  {
+#undef DEF_MPC_BUILTIN
+#define DEF_MPC_BUILTIN(code, name, type, attr) \
+	  gfc_define_builtin ("__builtin_" name, builtin_types[type], \
+			  code, name, attr == ATTR_CONST_NOTHROW_LIST);
+#include "../hls-builtins.def"
+#undef DEF_MPC_BUILTIN
+  }
+  /* MPC HLS END */
+  
   if (gfc_option.gfc_flag_openmp || flag_tree_parallelize_loops)
     {
 #undef DEF_GOMP_BUILTIN
 #define DEF_GOMP_BUILTIN(code, name, type, attr) \
       gfc_define_builtin ("__builtin_" name, builtin_types[type], \
 			  code, name, attr);
+			  
+/* MPC OMP BEGIN */
+#undef DEF_MPC_BUILTIN
+#define DEF_MPC_BUILTIN(code, name, type, attr) \
+      gfc_define_builtin ("__builtin_" name, builtin_types[type], \
+			  code, name, attr == ATTR_CONST_NOTHROW_LIST);
+/* MPC OMP END */
 #include "../omp-builtins.def"
 #undef DEF_GOMP_BUILTIN
+/* MPC OMP BEGIN */
+#undef DEF_MPC_BUILTIN
+/* MPC OMP END */
     }
 
   gfc_define_builtin ("__builtin_trap", builtin_types[BT_FN_VOID],
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index 2428b51..44b1db4 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -219,6 +219,12 @@ typedef enum
   ST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,
   ST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION, ST_OMP_SINGLE,
   ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE, ST_OMP_TASK, ST_OMP_END_TASK,
+  /* MPC HLS BEGIN */
+  ST_HLS_SCOPE,
+  ST_HLS_SINGLE,
+  ST_HLS_END_SINGLE,
+  ST_HLS_BARRIER,
+  /* MPC HLS END */
   ST_OMP_TASKWAIT, ST_OMP_TASKYIELD, ST_PROCEDURE, ST_GENERIC, ST_CRITICAL,
   ST_END_CRITICAL, ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_NONE
 }
@@ -585,6 +591,14 @@ typedef enum
 }
 init_local_integer;
 
+/* MPC HLS BEGIN */
+typedef enum gfc_hls_scope
+{
+	HLS_SCOPE_NONE, HLS_SCOPE_NODE, HLS_SCOPE_NUMA,
+	HLS_SCOPE_SOCKET, HLS_SCOPE_CACHE, HLS_SCOPE_CORE
+} gfc_hls_scope ;
+/* MPC HLS END */
+
 typedef enum
 {
   GFC_FCOARRAY_NONE = 0,
@@ -704,6 +718,11 @@ typedef struct
     implied_index:1, subref_array_pointer:1, proc_pointer:1, asynchronous:1,
     contiguous:1;
 
+ /* MPC HLS BEGIN */
+  ENUM_BITFIELD (gfc_hls_scope) hls_scope:4;
+  unsigned hls_level:2;
+  /* MPC HLS END */
+  
   /* For CLASS containers, the pointer attribute is sometimes set internally
      even though it was not directly specified.  In this case, keep the
      "real" (original) value here.  */
@@ -1290,6 +1309,10 @@ typedef struct gfc_common_head
 {
   locus where;
   char use_assoc, saved, threadprivate;
+  /* MPC HLS BEGIN */
+  gfc_hls_scope hls_scope;
+  unsigned int hls_level;
+  /* MPC HLS END */
   char name[GFC_MAX_SYMBOL_LEN + 1];
   struct gfc_symbol *head;
   const char* binding_label;
@@ -2108,7 +2131,11 @@ typedef enum
   EXEC_OMP_SECTIONS, EXEC_OMP_SINGLE, EXEC_OMP_WORKSHARE,
   EXEC_OMP_ATOMIC, EXEC_OMP_BARRIER, EXEC_OMP_END_NOWAIT,
   EXEC_OMP_END_SINGLE, EXEC_OMP_TASK, EXEC_OMP_TASKWAIT,
-  EXEC_OMP_TASKYIELD
+  EXEC_OMP_TASKYIELD,
+  /* MPC HLS BEGIN */
+  EXEC_HLS_BARRIER, EXEC_HLS_SINGLE, EXEC_HLS_SINGLE_NOWAIT,
+  EXEC_HLS_END_SINGLE
+  /* MPC HLS END */
 }
 gfc_exec_op;
 
@@ -2172,6 +2199,13 @@ typedef struct gfc_code
     gfc_namelist *omp_namelist;
     bool omp_bool;
     gfc_omp_atomic_op omp_atomic;
+     /* MPC HLS BEGIN */
+	struct 
+	{
+		gfc_hls_scope scope;
+		unsigned int level;
+	} hls ;
+	/* MPC HLS END */
   }
   ext;		/* Points to additional structures required by statement */
 
@@ -2306,7 +2340,14 @@ typedef struct
   int fpe;
   int rtcheck;
   gfc_fcoarray coarray;
-
+  /* MPC GLOBAL BEGIN */
+  //~ int warn_mpc;
+  //~ int flag_mpc_privatize;
+  /* MPC GLOBAL END */
+  /* MPC HLS BEGIN */
+  int flag_hls;
+  int flag_hls_verbose;
+  /* MPC HLS END */
   int warn_std;
   int allow_std;
   int convert;
@@ -2570,6 +2611,11 @@ gfc_try gfc_add_protected (symbol_attribute *, const char *, locus *);
 gfc_try gfc_add_result (symbol_attribute *, const char *, locus *);
 gfc_try gfc_add_save (symbol_attribute *, save_state, const char *, locus *);
 gfc_try gfc_add_threadprivate (symbol_attribute *, const char *, locus *);
+
+/* MPC HLS BEGIN */
+gfc_try gfc_add_hls_scope (symbol_attribute *, const char *, locus *, gfc_hls_scope, unsigned int);
+/* MPC HLS END */
+
 gfc_try gfc_add_saved_common (symbol_attribute *, locus *);
 gfc_try gfc_add_target (symbol_attribute *, locus *);
 gfc_try gfc_add_dummy (symbol_attribute *, const char *, locus *);
diff --git a/gcc/fortran/hls.c b/gcc/fortran/hls.c
new file mode 100644
index 0000000..e5cc93e
--- /dev/null
+++ b/gcc/fortran/hls.c
@@ -0,0 +1,440 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "flags.h"
+#include "gfortran.h"
+#include "match.h"
+#include "parse.h"
+#include "pointer-set.h"
+#include "target.h"
+#include "toplev.h"
+#include "tree.h"
+#include "trans.h"
+#include "trans-stmt.h"
+
+
+static match gfc_match_hls_eos (void)
+{
+  locus old_loc;
+  char c;
+
+  old_loc = gfc_current_locus;
+  gfc_gobble_whitespace ();
+
+  c = gfc_next_ascii_char ();
+  switch (c)
+    {
+    case '!':
+      do
+	c = gfc_next_ascii_char ();
+      while (c != '\n');
+      /* Fall through */
+
+    case '\n':
+      return MATCH_YES;
+    }
+
+  gfc_current_locus = old_loc;
+  return MATCH_NO;
+}
+
+static match gfc_match_hls_scope (gfc_hls_scope scope)
+{
+  char n[GFC_MAX_SYMBOL_LEN+1];
+  gfc_symbol *sym;
+  match m;
+  gfc_symtree *st;
+  gfc_expr *expr_level;
+  int level = 1;
+  locus old_loc = gfc_current_locus; 
+  locus loc_var_list, loc_after_level ;
+  int level_clause_found = 0 ;
+  
+  m = gfc_match (" (");
+  if (m != MATCH_YES)
+    return m;
+
+  loc_var_list = gfc_current_locus;
+
+  /* skip variables */
+  while (1) {
+	  if ( gfc_match_symbol (&sym, 0) != MATCH_YES
+		&& ( gfc_match (" / %n /", n) != MATCH_YES || n[0] == '\0' ) )
+		  goto syntax ;
+	  m = gfc_match_char (',') ;
+	  if ( m == MATCH_ERROR )
+		  goto syntax; 
+	  if ( m == MATCH_YES ) {
+		  continue;
+	  }
+	  m = gfc_match_char (')') ;
+	  if ( m == MATCH_ERROR )
+		  goto syntax; 
+	  if ( m == MATCH_YES ) {
+		  break;
+	  }
+  }
+
+  m = gfc_match (" level ( %e ) ", &expr_level);
+  if ( m == MATCH_ERROR )
+	  goto syntax;
+  if ( m == MATCH_YES ) {
+	  level_clause_found = 1 ;
+	  /* level clause present */
+	  gfc_extract_int(expr_level, &level);
+	  if ( level <= 0 ) {
+		  gfc_error("HLS: level should contain a positive integer at %C");
+		  goto cleanup;
+	  }
+	  gfc_free_expr(expr_level);
+	  switch (scope){
+		  case HLS_SCOPE_NONE:
+			  gfc_error("HLS: scope cannot be none at %C");
+			  goto cleanup;
+		  case HLS_SCOPE_NODE:
+		  case HLS_SCOPE_SOCKET:
+		  case HLS_SCOPE_CORE:
+			  gfc_error("HLS: level clause not valid for scopes node, socket and core at %C");
+			  goto cleanup;
+		  case HLS_SCOPE_NUMA:
+			  if ( level > 2 ) {
+				  gfc_error("HLS: level is at most 2 for scope NUMA at %C");
+				  goto cleanup;
+			  }
+			  break;
+		  case HLS_SCOPE_CACHE:
+			  if ( level > 3 ) {
+				  gfc_error("HLS: level is at most 3 for scope CACHE at %C");
+				  goto cleanup;
+			  }
+			  break ;
+	  }
+	  loc_after_level = gfc_current_locus ;
+  }
+  
+  /* go back to variables list */
+  gfc_current_locus = loc_var_list ;
+   
+  for (;;)
+    {
+      m = gfc_match_symbol (&sym, 0);
+      switch (m)
+	{
+	case MATCH_YES:
+	  if (sym->attr.in_common)
+	    gfc_error_now ("HLS variable at %C is an element of "
+			   "a COMMON block");
+	  else if (gfc_add_hls_scope (&sym->attr, sym->name,
+		   &sym->declared_at, scope, level) == FAILURE)
+	    goto cleanup;
+	  goto next_item;
+	case MATCH_NO:
+	  break;
+	case MATCH_ERROR:
+	  goto cleanup;
+	}
+
+      m = gfc_match (" / %n /", n);
+      if (m == MATCH_ERROR)
+	goto cleanup;
+      if (m == MATCH_NO || n[0] == '\0')
+	goto syntax;
+
+      st = gfc_find_symtree (gfc_current_ns->common_root, n);
+      if (st == NULL)
+	{
+	  gfc_error ("COMMON block /%s/ not found at %C", n);
+	  goto cleanup;
+	}
+      st->n.common->hls_scope = scope;
+      for (sym = st->n.common->head; sym; sym = sym->common_next)
+	if (gfc_add_hls_scope (&sym->attr, sym->name,
+				   &sym->declared_at, scope, level) == FAILURE)
+	  goto cleanup;
+
+    next_item:
+      if (gfc_match_char (')') == MATCH_YES)
+	break;
+      if (gfc_match_char (',') != MATCH_YES)
+	goto syntax;
+    }
+
+  /* skip level clause if found */
+  if ( level_clause_found == 1 ) 
+	  gfc_current_locus = loc_after_level ;
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in !$HLS list at %C");
+
+cleanup:
+  gfc_current_locus = old_loc;
+  return MATCH_ERROR;
+}
+
+match gfc_match_hls_node (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_NODE ) ;
+}
+
+match gfc_match_hls_numa (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_NUMA ) ;
+}
+
+match gfc_match_hls_socket (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_SOCKET ) ;
+}
+
+match gfc_match_hls_cache (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_CACHE ) ;
+}
+
+match gfc_match_hls_core (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_CORE ) ;
+}
+
+match gfc_match_hls_single (void)
+{
+  locus old_loc;
+  bool nowait ;
+  char n[GFC_MAX_SYMBOL_LEN+1];
+  gfc_symbol *sym;
+  match m;
+  gfc_symtree *st;
+  gfc_hls_scope scope = HLS_SCOPE_NONE ;
+  unsigned int level = 1;
+
+  old_loc = gfc_current_locus;
+
+  m = gfc_match (" (");
+  if (m != MATCH_YES)
+	  return m;
+
+  for (;;)
+  {
+	  m = gfc_match_symbol (&sym, 0);
+	  switch (m)
+	  {
+		  case MATCH_YES:
+			  if ( sym->attr.hls_scope == HLS_SCOPE_NONE )
+				  gfc_error_now ("variable at %C has not been declared HLS");
+			  else if ( scope != HLS_SCOPE_NONE )
+			  {
+				  if ( sym->attr.hls_scope != scope || sym->attr.hls_level != level )
+					  gfc_error_now ("variable at %C has incorrect HLS scope");
+			  }else{
+				  scope = sym->attr.hls_scope ;
+				  level = sym->attr.hls_level ;
+			  }
+			  goto next_item;
+		  case MATCH_NO:
+			  break;
+		  case MATCH_ERROR:
+			  goto cleanup;
+	  }
+
+	  m = gfc_match (" / %n /", n);
+	  if (m == MATCH_ERROR)
+		  goto cleanup;
+	  if (m == MATCH_NO || n[0] == '\0')
+		  goto syntax;
+
+	  st = gfc_find_symtree (gfc_current_ns->common_root, n);
+	  if (st == NULL)
+	  {
+		  gfc_error ("COMMON block /%s/ not found at %C", n);
+		  goto cleanup;
+	  }
+	  if ( st->n.common->hls_scope == HLS_SCOPE_NONE )
+	  {
+		  gfc_error_now ("variable at %C has not been declared HLS");
+		  goto next_item;
+	  }else if ( scope != HLS_SCOPE_NONE )
+	  {
+		  if ( st->n.common->hls_scope != scope || st->n.common->hls_level != level )
+			  gfc_error_now ("variable at %C has incorrect HLS scope");
+	  }else{
+		  scope = st->n.common->hls_scope ;
+		  level = st->n.common->hls_level ;
+	  }
+
+next_item:
+	  if (gfc_match_char (')') == MATCH_YES)
+		  break;
+	  if (gfc_match_char (',') != MATCH_YES)
+		  goto syntax;
+  }
+
+    
+  nowait = gfc_match ("% nowait") == MATCH_YES ;
+
+  if (gfc_match_hls_eos () != MATCH_YES)
+	  return MATCH_ERROR;
+
+  if ( nowait )
+ 	 new_st.op = EXEC_HLS_SINGLE_NOWAIT;
+  else
+	 new_st.op = EXEC_HLS_SINGLE;
+  new_st.ext.hls.scope = scope ;
+  new_st.ext.hls.level = level ;
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in !$HLS SINGLE at %C");
+
+cleanup:
+  gfc_current_locus = old_loc;
+  return MATCH_ERROR;
+}
+
+match gfc_match_hls_end_single (void)
+{
+  if (gfc_match_hls_eos () != MATCH_YES)
+	  return MATCH_ERROR;
+
+  new_st.op = EXEC_HLS_END_SINGLE;
+  return MATCH_YES;
+}
+
+match gfc_match_hls_barrier (void)
+{
+  locus old_loc;
+  char n[GFC_MAX_SYMBOL_LEN+1];
+  gfc_symbol *sym;
+  match m;
+  gfc_symtree *st;
+  gfc_hls_scope min_scope = HLS_SCOPE_CORE ;
+  unsigned int max_level = 1;
+
+  old_loc = gfc_current_locus;
+
+  m = gfc_match (" (");
+  if (m != MATCH_YES)
+	  return m;
+
+  for (;;)
+  {
+	  m = gfc_match_symbol (&sym, 0);
+	  switch (m)
+	  {
+		  case MATCH_YES:
+			  if ( sym->attr.hls_scope == HLS_SCOPE_NONE )
+				  gfc_error_now ("variable at %C has not been declared HLS");
+			  else if ( sym->attr.hls_scope < min_scope ) {
+				  min_scope = sym->attr.hls_scope ;
+				  max_level = sym->attr.hls_level ;
+			  }
+			  else if ( sym->attr.hls_scope == min_scope && sym->attr.hls_level > max_level )
+				  max_level = sym->attr.hls_level ;
+			  goto next_item;
+		  case MATCH_NO:
+			  break;
+		  case MATCH_ERROR:
+			  goto cleanup;
+	  }
+
+	  m = gfc_match (" / %n /", n);
+	  if (m == MATCH_ERROR)
+		  goto cleanup;
+	  if (m == MATCH_NO || n[0] == '\0')
+		  goto syntax;
+
+	  st = gfc_find_symtree (gfc_current_ns->common_root, n);
+	  if (st == NULL)
+	  {
+		  gfc_error ("COMMON block /%s/ not found at %C", n);
+		  goto cleanup;
+	  }
+	  if ( st->n.common->hls_scope == HLS_SCOPE_NONE )
+	  {
+		  gfc_error_now ("variable at %C has not been declared HLS");
+		  goto next_item;
+	  }else if ( st->n.common->hls_scope < min_scope ) {
+		  min_scope = st->n.common->hls_scope ;
+		  max_level = st->n.common->hls_level ;
+	  }
+	  else if ( st->n.common->hls_scope == min_scope && st->n.common->hls_level > max_level )
+		  max_level = st->n.common->hls_level ;
+
+next_item:
+	  if (gfc_match_char (')') == MATCH_YES)
+		  break;
+	  if (gfc_match_char (',') != MATCH_YES)
+		  goto syntax;
+  }
+  
+  if (gfc_match_hls_eos () != MATCH_YES)
+	  return MATCH_ERROR;
+  new_st.op = EXEC_HLS_BARRIER;
+  new_st.ext.hls.scope = min_scope ;
+  new_st.ext.hls.level = max_level ;
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in !$HLS BARRIER at %C");
+
+cleanup:
+  gfc_current_locus = old_loc;
+  return MATCH_ERROR;
+}
+
+tree gfc_trans_hls_directive (gfc_code *code)
+{
+  tree arg, call_hls, then_block, cond;
+  bool nowait = true ;
+  stmtblock_t stmt_block;
+  const gfc_hls_scope scope = code->ext.hls.scope ;
+  const unsigned int level = code->ext.hls.level ;
+  unsigned int hls_scope_with_level ;
+ 
+  hls_scope_with_level = scope - HLS_SCOPE_NODE ;
+
+  if ( scope == HLS_SCOPE_NUMA )
+	  hls_scope_with_level += 2 - level ;
+  else if ( scope > HLS_SCOPE_NUMA )
+	  hls_scope_with_level += 1 ;
+
+  if ( scope == HLS_SCOPE_CACHE )
+	  hls_scope_with_level += 3 - level ;
+  else if ( scope > HLS_SCOPE_CACHE )
+	  hls_scope_with_level += 2 ;
+
+  arg = build_int_cst ( integer_type_node, hls_scope_with_level );
+
+  switch (code->op)
+    {
+    case EXEC_HLS_BARRIER:
+		call_hls = builtin_decl_explicit(BUILT_IN_MPC_HLS_BARRIER);
+		call_hls = build_call_expr (call_hls, 1, arg);
+		return call_hls;
+	case EXEC_HLS_SINGLE:
+		nowait = false ;
+	case EXEC_HLS_SINGLE_NOWAIT:
+		pushlevel ();
+		then_block = gfc_trans_code (code->block->next);
+		if ( !nowait ) {
+			call_hls = builtin_decl_explicit(BUILT_IN_MPC_HLS_SINGLE_DONE);
+			call_hls = build_call_expr (call_hls, 1, arg);
+			stmt_block.head = then_block;
+			stmt_block.has_scope = 1;
+			gfc_add_expr_to_block ( &stmt_block, call_hls) ;
+		}
+		if (TREE_CODE (then_block) != BIND_EXPR)
+		{
+			tree block = poplevel (1, 0);
+			then_block = build3_v (BIND_EXPR, NULL, then_block, block);
+		}
+		else
+			poplevel (0, 0);
+		call_hls = builtin_decl_explicit(nowait?BUILT_IN_MPC_HLS_SINGLE_NOWAIT:BUILT_IN_MPC_HLS_SINGLE);
+		call_hls = build_call_expr (call_hls, 1, arg);
+		cond = build3 (COND_EXPR, void_type_node, call_hls, then_block, NULL);
+		return cond ;
+    default:
+      gcc_unreachable ();
+    }
+}
diff --git a/gcc/fortran/lang.opt b/gcc/fortran/lang.opt
index fbe8a1b..4bfd558 100644
--- a/gcc/fortran/lang.opt
+++ b/gcc/fortran/lang.opt
@@ -237,6 +237,12 @@ Wfunction-elimination
 Fortran Warning
 Warn about function call elimination
 
+; MPC GLOBAL BEGIN
+;Wmpc
+;Fortran Warning
+;Warn about MPC and thread-safety issues
+; MPC GLOBAL END
+
 Wimplicit-interface
 Fortran Warning
 Warn about calls with implicit interface
@@ -341,6 +347,16 @@ fblas-matmul-limit=
 Fortran RejectNegative Joined UInteger
 -fblas-matmul-limit=<n>	Size of the smallest matrix for which matmul will use BLAS
 
+; MPC TLS BEGIN 
+fhls
+Fortran
+Enable Hierarchical Local Storage (HLS) directives
+
+fhls-verbose
+Fortran
+Enable verbose output for Hierarchical Local Storage (HLS) directives
+; MPC TLS END 
+
 fcheck-array-temporaries
 Fortran
 Produce a warning at runtime if a array temporary has been created for a procedure argument
@@ -505,6 +521,12 @@ fmodule-private
 Fortran
 Set default accessibility of module entities to PRIVATE.
 
+; MPC TLS BEGIN 
+fmpc-privatize
+Fortran
+Privatize every global variable to make MPI codes MPC compliant.
+; MPC TLS END 
+
 fopenmp
 Fortran
 ; Documented in C
diff --git a/gcc/fortran/match.h b/gcc/fortran/match.h
index 48aa405..469241f 100644
--- a/gcc/fortran/match.h
+++ b/gcc/fortran/match.h
@@ -190,6 +190,17 @@ match gfc_match_target (void);
 match gfc_match_value (void);
 match gfc_match_volatile (void);
 
+/* MPC HLS BEGIN */
+match gfc_match_hls_node (void);
+match gfc_match_hls_numa (void);
+match gfc_match_hls_socket (void);
+match gfc_match_hls_core (void);
+match gfc_match_hls_cache (void);
+match gfc_match_hls_single (void);
+match gfc_match_hls_end_single (void);
+match gfc_match_hls_barrier (void);
+/* MPC HLS END */
+
 /* decl.c.  */
 
 /* Fortran 2003 c interop.
diff --git a/gcc/fortran/options.c b/gcc/fortran/options.c
index fba1a3f..e500dba 100644
--- a/gcc/fortran/options.c
+++ b/gcc/fortran/options.c
@@ -162,6 +162,17 @@ gfc_init_options (unsigned int decoded_options_count,
   gfc_option.flag_frontend_optimize = -1;
   
   gfc_option.fpe = 0;
+  
+  /* MPC GLOBAL BEGIN */
+  //~ gfc_option.warn_mpc = 0 ;
+  //~ gfc_option.flag_mpc_privatize = 0 ;
+  /* MPC GLOBAL END */
+
+  /* MPC HLS BEGIN */
+  gfc_option.flag_hls = 0 ;
+  gfc_option.flag_hls_verbose = 0 ;
+  /* MPC HLS END */
+  
   gfc_option.rtcheck = 0;
   gfc_option.coarray = GFC_FCOARRAY_NONE;
 
@@ -475,6 +486,13 @@ set_Wall (int setting)
   gfc_option.warn_unused_dummy_argument = setting;
   gfc_option.warn_target_lifetime = setting;
 
+  /* MPC TLS BEGIN */
+  /* Uncomment the following assignment to enable -Wmpc w/ -Wall */
+  #if 0
+    gfc_option.warn_mpc = setting;
+  #endif
+  /* MPC TLS END */
+  
   warn_return_type = setting;
   warn_uninitialized = setting;
   warn_maybe_uninitialized = setting;
@@ -701,7 +719,13 @@ gfc_handle_option (size_t scode, const char *arg, int value,
     case OPT_Wtabs:
       gfc_option.warn_tabs = value;
       break;
-
+    
+    /* MPC GLOBAL BEGIN */
+    case OPT_Wmpc:
+      //~ gfc_option.warn_mpc = value ;
+      break ;
+    /* MPC GLOBAL END */
+    
     case OPT_Wtarget_lifetime:
       gfc_option.warn_target_lifetime = value;
       break;
@@ -804,7 +828,22 @@ gfc_handle_option (size_t scode, const char *arg, int value,
     case OPT_ffree_form:
       gfc_option.source_form = FORM_FREE;
       break;
+	
+	/* MPC TLS BEGIN */
+    case OPT_fmpc_privatize:
+      //~ gfc_option.flag_mpc_privatize = value ;
+      break ;
+      /* MPC TLS END */
 
+    /* MPC HLS BEGIN */
+    case OPT_fhls:
+      gfc_option.flag_hls = value;
+      break;
+    case OPT_fhls_verbose:
+      gfc_option.flag_hls_verbose = value;
+      break;
+    /* MPC HLS END */
+    
     case OPT_fopenmp:
       gfc_option.gfc_flag_openmp = value;
       break;
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index f748fe3..bdb03d4 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -638,6 +638,69 @@ decode_omp_directive (void)
   return ST_NONE;
 }
 
+/* MPC BEGIN */
+static gfc_statement
+decode_hls_directive (void)
+{
+  locus old_locus;
+  char c;
+
+#ifdef GFC_DEBUG
+  gfc_symbol_state ();
+#endif
+
+  gfc_clear_error ();	/* Clear any pending errors.  */
+  gfc_clear_warning ();	/* Clear any pending warnings.  */
+
+  if (gfc_pure (NULL))
+    {
+      gfc_error_now ("HLS directives at %C may not appear in PURE "
+		     "or ELEMENTAL procedures");
+      gfc_error_recovery ();
+      return ST_NONE;
+    }
+
+  old_locus = gfc_current_locus;
+
+  /* return statement not used here */
+  c = gfc_peek_ascii_char ();
+
+  switch (c)
+    {
+	case 'b':
+		match ( "barrier", gfc_match_hls_barrier, ST_HLS_BARRIER);
+		break;
+	case 'c':
+		match ( "cache", gfc_match_hls_cache, ST_HLS_SCOPE);
+		match ( "core", gfc_match_hls_core, ST_HLS_SCOPE);
+		break;
+	case 'e':
+		match ( "end single", gfc_match_hls_end_single, ST_HLS_END_SINGLE);
+		break;
+    case 'n':
+		match ( "node", gfc_match_hls_node, ST_HLS_SCOPE);
+		match ( "numa", gfc_match_hls_numa, ST_HLS_SCOPE);
+		break;
+	case 's':
+		match ( "socket", gfc_match_hls_socket, ST_HLS_SCOPE);
+		match ( "single", gfc_match_hls_single, ST_HLS_SINGLE);
+		break;
+	}
+
+  /* All else has failed, so give up.  See if any of the matchers has
+     stored an error message of some sort.  */
+
+  if (gfc_error_check () == 0)
+    gfc_error_now ("Unclassifiable HLS directive at %C");
+
+  reject_statement ();
+
+  gfc_error_recovery ();
+
+  return ST_NONE;
+}
+/* MPC END */
+
 static gfc_statement
 decode_gcc_attribute (void)
 {
@@ -674,7 +737,7 @@ next_free (void)
 {
   match m;
   int i, cnt, at_bol;
-  char c;
+  char c, directive[5];
 
   at_bol = gfc_at_bol ();
   gfc_gobble_whitespace ();
@@ -752,19 +815,40 @@ next_free (void)
 	  return decode_gcc_attribute ();
 
 	}
+      /* MPC BEGIN */
+	 #if 0
       else if (c == '$' && gfc_option.gfc_flag_openmp)
+      #endif
+    /* MPC END */
+      else if (c == '$' && (gfc_option.gfc_flag_openmp || gfc_option.flag_hls))
 	{
 	  int i;
 
 	  c = gfc_next_ascii_char ();
 	  for (i = 0; i < 4; i++, c = gfc_next_ascii_char ())
+	   /* MPC BEGIN */
+	  #if 0
 	    gcc_assert (c == "$omp"[i]);
-
+	  #endif
+	  directive[i] = c;
+	   directive[4] = 0 ;
+	  gcc_assert ( strcmp(directive,"$omp") == 0 || strcmp(directive,"$hls") == 0 );
+	  /* MPC END */
 	  gcc_assert (c == ' ' || c == '\t');
 	  gfc_gobble_whitespace ();
 	  if (last_was_use_stmt)
 	    use_modules ();
-	  return decode_omp_directive ();
+	   /* MPC BEGIN */
+	  #if 0
+		return decode_omp_directive ();
+	  #endif
+	  if ( strcmp(directive,"$hls") == 0 )
+		 return decode_hls_directive() ;
+	  else if ( strcmp(directive,"$omp") == 0 )
+	     return decode_omp_directive() ;
+
+          gcc_assert ( 0 ) ;
+	  /* MPC HLS END */
 	}
 
       gcc_unreachable (); 
@@ -841,11 +925,18 @@ next_fixed (void)
 
 	      return decode_gcc_attribute ();
 	    }
-	  else if (c == '$' && gfc_option.gfc_flag_openmp)
+	   /* MPC BEGIN */
+	 #if 0
+      else if (c == '$' && gfc_option.gfc_flag_openmp)
+      #endif
+      else if (c == '$' && (gfc_option.gfc_flag_openmp || gfc_option.flag_hls))
 	    {
+			char directive[5];
 	      for (i = 0; i < 4; i++, c = gfc_next_char_literal (NONSTRING))
-		gcc_assert ((char) gfc_wide_tolower (c) == "$omp"[i]);
-
+				directive[i] = (char) gfc_wide_tolower ( c );/*gcc_assert ((char) gfc_wide_tolower (c) == "$omp"[i]);*/
+		  directive[4] = 0;
+		  gcc_assert ( strcmp(directive,"$omp") == 0 || strcmp(directive,"$hls") == 0 );
+		  /* MPC END */
 	      if (c != ' ' && c != '0')
 		{
 		  gfc_buffer_error (0);
@@ -854,7 +945,13 @@ next_fixed (void)
 		}
 	      if (last_was_use_stmt)
 		use_modules ();
-	      return decode_omp_directive ();
+	     /* MPC BEGIN */
+	      /* return decode_omp_directive (); */
+	      if ( strcmp(directive,"$omp") == 0 ) 
+	        return decode_omp_directive() ;
+	      else if ( strcmp(directive,"$hls") == 0 )
+			return decode_hls_directive() ;
+		/* MPC END */
 	    }
 	  /* FALLTHROUGH */
 
@@ -1013,7 +1110,7 @@ next_statement (void)
   case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \
   case ST_OMP_BARRIER: case ST_OMP_TASKWAIT: case ST_OMP_TASKYIELD: \
   case ST_ERROR_STOP: case ST_SYNC_ALL: case ST_SYNC_IMAGES: \
-  case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK
+  case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK: case ST_HLS_BARRIER /* MPC HLS */
 
 /* Statements that mark other executable statements.  */
 
@@ -1025,14 +1122,14 @@ next_statement (void)
   case ST_OMP_CRITICAL: case ST_OMP_MASTER: case ST_OMP_SINGLE: \
   case ST_OMP_DO: case ST_OMP_PARALLEL_DO: case ST_OMP_ATOMIC: \
   case ST_OMP_WORKSHARE: case ST_OMP_PARALLEL_WORKSHARE: \
-  case ST_OMP_TASK: case ST_CRITICAL
+  case ST_OMP_TASK: case ST_CRITICAL: case ST_HLS_SINGLE /* MPC HLS */
 
 /* Declaration statements */
 
 #define case_decl case ST_ATTR_DECL: case ST_COMMON: case ST_DATA_DECL: \
   case ST_EQUIVALENCE: case ST_NAMELIST: case ST_STATEMENT_FUNCTION: \
   case ST_TYPE: case ST_INTERFACE: case ST_OMP_THREADPRIVATE: \
-  case ST_PROCEDURE
+  case ST_PROCEDURE: case ST_HLS_SCOPE /* MPC HLS */
 
 /* Block end statements.  Errors associated with interchanging these
    are detected in gfc_match_end().  */
@@ -1613,6 +1710,22 @@ gfc_ascii_statement (gfc_statement st)
     case ST_OMP_WORKSHARE:
       p = "!$OMP WORKSHARE";
       break;
+      
+    /* MPC HLS BEGIN */
+    case ST_HLS_SCOPE:
+      p = "!$HLS";
+      break;
+    case ST_HLS_SINGLE:
+      p = "!$HLS SINGLE";
+      break;
+    case ST_HLS_END_SINGLE:
+      p = "!$HLS END SINGLE";
+      break;
+    case ST_HLS_BARRIER:
+      p = "!$HLS BARRIER";
+      break;
+    /* MPC HLS END */
+    
     default:
       gfc_internal_error ("gfc_ascii_statement(): Bad statement code");
     }
@@ -3786,6 +3899,34 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)
   pop_state ();
 }
 
+/* MPC HLS BEGIN */
+static void
+parse_hls_structured_block (gfc_statement hls_st)
+{
+  gfc_statement st;
+  gfc_code *cp, *np;
+  gfc_state_data s;
+
+  accept_statement (hls_st);
+
+  cp = gfc_state_stack->tail;
+  push_state (&s, COMP_HLS_STRUCTURED_BLOCK, NULL);
+  np = new_level (cp);
+  np->op = cp->op;
+  np->block = NULL;
+
+  st = parse_executable (ST_NONE);
+  if (st == ST_NONE)
+	  unexpected_eof ();
+  else if (st != ST_HLS_END_SINGLE)
+	unexpected_statement (st);
+
+  gfc_clear_new_st ();
+  gfc_commit_symbols ();
+  gfc_warning_check ();
+  pop_state ();
+}
+/* MPC HLS END */
 
 /* Accept a series of executable statements.  We return the first
    statement that doesn't fit to the caller.  Any block statements are
@@ -3911,7 +4052,13 @@ parse_executable (gfc_statement st)
 	case ST_OMP_ATOMIC:
 	  st = parse_omp_atomic ();
 	  continue;
-
+	  
+    /* MPC HLS BEGIN */
+	case ST_HLS_SINGLE:
+	  parse_hls_structured_block (st);
+	  break;
+	/* MPC HLS END */
+	
 	default:
 	  return st;
 	}
diff --git a/gcc/fortran/parse.h b/gcc/fortran/parse.h
index dbe3c49..53dc0b2 100644
--- a/gcc/fortran/parse.h
+++ b/gcc/fortran/parse.h
@@ -29,7 +29,8 @@ typedef enum
   COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_DERIVED_CONTAINS,
   COMP_BLOCK, COMP_ASSOCIATE, COMP_IF,
   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,
-  COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT
+  COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT,
+  COMP_HLS_STRUCTURED_BLOCK /* MPC HLS */
 }
 gfc_compile_state;
 
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index 2ba1cb2..d7f1a5b 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -9441,7 +9441,13 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)
 	case EXEC_OMP_TASKYIELD:
 	case EXEC_OMP_WORKSHARE:
 	  break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  break;
+	/* MPC HLS END */
+	
 	default:
 	  gfc_internal_error ("gfc_resolve_blocks(): Bad block type");
 	}
@@ -10511,7 +10517,14 @@ resolve_code (gfc_code *code, gfc_namespace *ns)
 	  gfc_resolve_omp_directive (code, ns);
 	  omp_workshare_flag = omp_workshare_save;
 	  break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_BARRIER:
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  break;
+	/* MPC HLS END */
+	
 	default:
 	  gfc_internal_error ("resolve_code(): Bad statement code");
 	}
@@ -13868,6 +13881,15 @@ resolve_symbol (gfc_symbol *sym)
 	      || sym->ns->proc_name->attr.flavor != FL_MODULE)))
     gfc_error ("Threadprivate at %L isn't SAVEd", &sym->declared_at);
 
+	/* MPC HLS BEGIN */
+  if (sym->attr.hls_scope && !sym->attr.save && !sym->ns->save_all
+      && (!sym->attr.in_common
+	  && sym->module == NULL
+	  && (sym->ns->proc_name == NULL
+	      || sym->ns->proc_name->attr.flavor != FL_MODULE)))
+    gfc_error ("HLS at %L isn't SAVEd", &sym->declared_at);
+  /* MPC HLS END */
+  
   /* If we have come this far we can apply default-initializers, as
      described in 14.7.5, to those variables that have not already
      been assigned one.  */
diff --git a/gcc/fortran/scanner.c b/gcc/fortran/scanner.c
index f714ed0..a76e681 100644
--- a/gcc/fortran/scanner.c
+++ b/gcc/fortran/scanner.c
@@ -62,7 +62,10 @@ gfc_directorylist;
 static gfc_directorylist *include_dirs, *intrinsic_modules_dirs;
 
 static gfc_file *file_head, *current_file;
-
+/* MPC HLS BEGIN */
+static int hls_flag;
+static locus hls_locus;
+/* MPC HLS END */
 static int continue_flag, end_flag, openmp_flag, gcc_attribute_flag;
 static int continue_count, continue_line;
 static locus openmp_locus;
@@ -812,6 +815,36 @@ skip_free_comments (void)
 		      next_char ();
 		      c = next_char ();
 		    }
+		    /* MPC HLS BEGIN */
+		  else if (c == 'h' || c == 'H')
+		    {
+		      if (((c = next_char ()) == 'l' || c == 'L')
+			  && ((c = next_char ()) == 's' || c == 'S'))
+			{
+			  if ((c = next_char ()) == ' ' || c == '\t'
+			      || continue_flag)
+			    {
+			      while (gfc_is_whitespace (c))
+				c = next_char ();
+			      if (c != '\n' && c != '!')
+				{
+				  hls_flag = 1;
+				  hls_locus = old_loc;
+				  gfc_current_locus = start;
+				  return false;
+				}
+			    }
+			  else
+			    gfc_warning_now ("!$HLS at %C starts a commented "
+					     "line as it neither is followed "
+					     "by a space nor is a "
+					     "continuation line");
+			}
+		      gfc_current_locus = old_loc;
+		      next_char ();
+		      c = next_char ();
+		    }
+                    /* MPC HLS END */
 		  if (continue_flag || c == ' ' || c == '\t')
 		    {
 		      gfc_current_locus = old_loc;
@@ -831,7 +864,10 @@ skip_free_comments (void)
 
   if (openmp_flag && at_bol)
     openmp_flag = 0;
-
+  /* MPC HLS BEGIN */
+  if (hls_flag && at_bol)
+    hls_flag = 0;
+/* MPC HLS END */
   gcc_attribute_flag = 0;
   gfc_current_locus = start;
   return false;
@@ -933,6 +969,32 @@ skip_fixed_comments (void)
 			    }
 			}
 		    }
+		     /* MPC HLS BEGIN */
+		  else if (c == 'h' || c == 'H')
+		    {
+		      if (((c = next_char ()) == 'l' || c == 'L')
+			  && ((c = next_char ()) == 's' || c == 'S'))
+			{
+			  c = next_char ();
+			  if (c != '\n'
+			      && ((hls_flag && continue_flag)
+				  || c == ' ' || c == '\t' || c == '0'))
+			    {
+			      do
+				c = next_char ();
+			      while (gfc_is_whitespace (c));
+			      if (c != '\n' && c != '!')
+				{
+				  /* Canonicalize to *$hls.  */
+				  *start.nextc = '*';
+				  hls_flag = 1;
+				  gfc_current_locus = start;
+				  return;
+				}
+			    }
+			}
+		    }
+		   /* MPC HLS END */
 		  else
 		    {
 		      int digit_seen = 0;
@@ -1005,6 +1067,9 @@ skip_fixed_comments (void)
     }
 
   openmp_flag = 0;
+  /* MPC HLS BEGIN */
+  hls_flag = 0;
+  /* MPC HLS END */
   gcc_attribute_flag = 0;
   gfc_current_locus = start;
 }
@@ -1034,6 +1099,9 @@ gfc_next_char_literal (gfc_instring in_string)
 {
   locus old_loc;
   int i, prev_openmp_flag;
+  /* MPC HLS BEGIN */
+  int prev_hls_flag;
+  /* MPC HLS END */
   gfc_char_t c;
 
   continue_flag = 0;
@@ -1049,6 +1117,9 @@ restart:
   if (gfc_current_form == FORM_FREE)
     {
       bool openmp_cond_flag;
+       /* MPC HLS BEGIN */
+      bool hls_cond_flag;
+      /* MPC HLS END */
 
       if (!in_string && c == '!')
 	{
@@ -1056,7 +1127,14 @@ restart:
 	      && memcmp (&gfc_current_locus, &gcc_attribute_locus,
 		 sizeof (gfc_current_locus)) == 0)
 	    goto done;
-
+	  
+	  /* MPC HLS BEGIN */
+	  if (hls_flag
+	      && memcmp (&gfc_current_locus, &hls_locus,
+		 sizeof (gfc_current_locus)) == 0)
+	    goto done;
+          /* MPC HLS END */
+          
 	  if (openmp_flag
 	      && memcmp (&gfc_current_locus, &openmp_locus,
 		 sizeof (gfc_current_locus)) == 0)
@@ -1117,6 +1195,9 @@ restart:
 	}
 
       prev_openmp_flag = openmp_flag;
+      /* MPC HLS BEGIN */
+      prev_hls_flag = hls_flag;
+      /* MPC HLS END */
       continue_flag = 1;
       if (c == '!')
 	skip_comment_line ();
@@ -1141,6 +1222,9 @@ restart:
 
       /* Now find where it continues. First eat any comment lines.  */
       openmp_cond_flag = skip_free_comments ();
+       /* MPC HLS BEGIN */
+      hls_cond_flag = openmp_cond_flag;
+      /* MPC HLS END */
 
       if (gfc_current_locus.lb != NULL
 	  && continue_line < gfc_linebuf_linenum (gfc_current_locus.lb))
@@ -1153,7 +1237,17 @@ restart:
 	  c = '&';
 	  goto done;
 	}
-
+	
+	   /* MPC HLS BEGIN */
+      if (prev_hls_flag != hls_flag)
+	{
+	  gfc_current_locus = old_loc;
+	  hls_flag = prev_hls_flag;
+	  c = '&';
+	  goto done;
+	}
+	/* MPC HLS END */
+	
       /* Now that we have a non-comment line, probe ahead for the
 	 first non-whitespace character.  If it is another '&', then
 	 reading starts at the next character, otherwise we must back
@@ -1176,7 +1270,21 @@ restart:
 	  while (gfc_is_whitespace (c))
 	    c = next_char ();
 	}
-
+	  
+	  /* MPC HLS BEGIN */
+      if (hls_flag)
+	{
+	  for (i = 0; i < 5; i++, c = next_char ())
+	    {
+	      gcc_assert (gfc_wide_tolower (c) == (unsigned char) "!$hls"[i]);
+	      if (i == 4)
+		old_loc = gfc_current_locus;
+	    }
+	  while (gfc_is_whitespace (c))
+	    c = next_char ();
+	}
+      /* MPC HLS END */
+      
       if (c != '&')
 	{
 	  if (in_string)
@@ -1190,6 +1298,10 @@ restart:
 	     continuation line only optionally.  */
 	  else if (openmp_flag || openmp_cond_flag)
 	    gfc_current_locus.nextc--;
+	   /* MPC HLS BEGIN */
+	  else if (hls_flag || hls_cond_flag)
+	    gfc_current_locus.nextc--;
+	  /* MPC HLS END */
 	  else
 	    {
 	      c = ' ';
@@ -1226,6 +1338,9 @@ restart:
 	}
 
       prev_openmp_flag = openmp_flag;
+      /* MPC HLS BEGIN */
+      prev_hls_flag = hls_flag;
+      /* MPC HLS END */
       continue_flag = 1;
       old_loc = gfc_current_locus;
 
@@ -1239,21 +1354,36 @@ restart:
 	  goto not_continuation;
 	}
 
-      if (!openmp_flag)
-	for (i = 0; i < 5; i++)
+     /* MPC HLS BEGIN */
+    if (hls_flag != prev_hls_flag)
+	{
+	  hls_flag = prev_hls_flag;
+	  goto not_continuation;
+	}
+
+    if (!openmp_flag && !hls_flag)
+	  for (i = 0; i < 5; i++)
 	  {
 	    c = next_char ();
 	    if (c != ' ')
 	      goto not_continuation;
 	  }
-      else
-	for (i = 0; i < 5; i++)
+    else if (openmp_flag)
+	  for (i = 0; i < 5; i++)
 	  {
 	    c = next_char ();
 	    if (gfc_wide_tolower (c) != (unsigned char) "*$omp"[i])
 	      goto not_continuation;
 	  }
-
+	else
+	  for (i = 0; i < 5; i++)
+	  {
+	    c = next_char ();
+	    if (gfc_wide_tolower (c) != (unsigned char) "*$hls"[i])
+	      goto not_continuation;
+	  }
+      /* MPC HLS END */
+      
       c = next_char ();
       if (c == '0' || c == ' ' || c == '\n')
 	goto not_continuation;
diff --git a/gcc/fortran/st.c b/gcc/fortran/st.c
index 836dac7..fadc77c 100644
--- a/gcc/fortran/st.c
+++ b/gcc/fortran/st.c
@@ -212,7 +212,14 @@ gfc_free_statement (gfc_code *p)
     case EXEC_OMP_TASKWAIT:
     case EXEC_OMP_TASKYIELD:
       break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_BARRIER:
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  break;
+	/* MPC HLS END */
+	
     default:
       gfc_internal_error ("gfc_free_statement(): Bad statement");
     }
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index 785f582..479e171 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -364,7 +364,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
     *asynchronous = "ASYNCHRONOUS", *codimension = "CODIMENSION",
     *contiguous = "CONTIGUOUS", *generic = "GENERIC";
   static const char *threadprivate = "THREADPRIVATE";
-
+/* MPC HLS BEGIN */
+  static const char *hls_scope = "HLS SCOPE";
+  static const char *hls_level = "HLS LEVEL";
+  /* MPC HLS END */
   const char *a1, *a2;
   int standard;
 
@@ -450,6 +453,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
   conf (dummy, entry);
   conf (dummy, intrinsic);
   conf (dummy, threadprivate);
+  /* MPC HLS BEGIN */
+  conf (dummy, hls_scope);
+  conf (dummy, hls_level);
+  /* MPC HLS END */
   conf (pointer, target);
   conf (pointer, intrinsic);
   conf (pointer, elemental);
@@ -492,6 +499,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
   conf (in_equivalence, entry);
   conf (in_equivalence, allocatable);
   conf (in_equivalence, threadprivate);
+  /* MPC HLS BEGIN */
+  conf (in_equivalence, hls_scope);
+  conf (in_equivalence, hls_level);
+  /* MPC HLS END */
 
   conf (dummy, result);
   conf (entry, result);
@@ -540,6 +551,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
   conf (cray_pointee, in_common);
   conf (cray_pointee, in_equivalence);
   conf (cray_pointee, threadprivate);
+  /* MPC HLS BEGIN */
+  conf (cray_pointee, hls_scope);
+  conf (cray_pointee, hls_level);
+  /* MPC HLS END */
 
   conf (data, dummy);
   conf (data, function);
@@ -626,6 +641,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
       conf2 (function);
       conf2 (subroutine);
       conf2 (threadprivate);
+      /* MPC HLS BEGIN */
+      conf2 (hls_scope);
+      conf2 (hls_level);
+      /* MPC HLS END */
 
       if (attr->access == ACCESS_PUBLIC || attr->access == ACCESS_PRIVATE)
 	{
@@ -667,6 +686,12 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
 	  conf2 (function);
 	  if (!attr->proc_pointer)
 	    conf2 (threadprivate);
+	  
+	  /* MPC HLS BEGIN */
+	  conf2 (hls_scope);
+	  conf2 (hls_level);
+	  /* MPC HLS END */
+	  
 	}
 
       if (!attr->proc_pointer)
@@ -686,6 +711,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
 	case PROC_DUMMY:
 	  conf2 (result);
 	  conf2 (threadprivate);
+	  /* MPC HLS BEGIN */
+	  conf2 (hls_scope);
+	  conf2 (hls_level);
+	  /* MPC HLS END */
 	  break;
 
 	default:
@@ -706,6 +735,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
       conf2 (function);
       conf2 (subroutine);
       conf2 (threadprivate);
+      /* MPC HLS BEGIN */
+      conf2 (hls_scope);
+      conf2 (hls_level);
+      /* MPC HLS END */
       conf2 (result);
 
       if (attr->intent != INTENT_UNKNOWN)
@@ -733,6 +766,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
       conf2 (volatile_);
       conf2 (asynchronous);
       conf2 (threadprivate);
+      /* MPC HLS BEGIN */
+      conf2 (hls_scope);
+      conf2 (hls_level);
+      /* MPC HLS END */
       conf2 (value);
       conf2 (codimension);
       conf2 (result);
@@ -905,6 +942,32 @@ gfc_add_codimension (symbol_attribute *attr, const char *name, locus *where)
   return check_conflict (attr, name, where);
 }
 
+/* MPC HLS BEGIN */
+gfc_try
+gfc_add_hls_scope (symbol_attribute *attr, const char *name, locus *where, gfc_hls_scope scope, unsigned int level)
+{
+  if (check_used (attr, name, where))
+    return FAILURE;
+
+  if (attr->hls_scope == scope) 
+    {
+      duplicate_attr ("HLS_SCOPE", where);
+      return FAILURE;
+    }
+  
+  if ( attr->hls_scope != HLS_SCOPE_NONE )
+    {
+      if (where == NULL)
+        where = &gfc_current_locus;
+      gfc_error ("Variable %s at %L already specified HLS", name, where);
+      return FAILURE;
+    }
+
+  attr->hls_scope = scope;
+  attr->hls_level = level;
+  return check_conflict (attr, name, where);
+}
+/* MPC HLS END */
 
 gfc_try
 gfc_add_dimension (symbol_attribute *attr, const char *name, locus *where)
@@ -1760,6 +1823,13 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)
   if (src->threadprivate
       && gfc_add_threadprivate (dest, NULL, where) == FAILURE)
     goto fail;
+    
+  /* MPC HLS BEGIN */
+  if (src->hls_scope != HLS_SCOPE_NONE
+      && gfc_add_hls_scope (dest, NULL, where, src->hls_scope, src->hls_level) == FAILURE)
+    goto fail;
+  /* MPC HLS END */
+    
   if (src->target && gfc_add_target (dest, where) == FAILURE)
     goto fail;
   if (src->dummy && gfc_add_dummy (dest, NULL, where) == FAILURE)
diff --git a/gcc/fortran/trans-common.c b/gcc/fortran/trans-common.c
index db0f385..deb6060 100644
--- a/gcc/fortran/trans-common.c
+++ b/gcc/fortran/trans-common.c
@@ -444,8 +444,88 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)
 
       gfc_set_decl_location (decl, &com->where);
 
+/* MPC OMP BEGIN */
+#if 0
       if (com->threadprivate)
 	DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
+#endif
+      if (com->threadprivate)
+      {
+	DECL_TLS_MODEL (decl) = TLS_MODEL_MPC_OPENMP ;
+	/* Verbose mode */
+	if ( flag_openmp_verbose && DECL_NAME(decl) ) 
+	{
+	  fprintf( stderr, "MPC-OPENMP: Found threadprivate variable %s (file %s line %d)\n"
+	      , IDENTIFIER_POINTER( DECL_NAME(decl) )
+	      , DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+	}
+      }
+/* MPC OMP END */
+/* MPC HLS BEGIN */
+      switch(com->hls_scope)
+      {
+        case HLS_SCOPE_NODE:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NODE ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope node of variable %s (file %s line %d)\n",
+              IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_NUMA:
+		  if ( com->hls_level == 1 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NUMA_LEVEL_1 ;
+		  else if ( com->hls_level == 2 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NUMA_LEVEL_2 ;
+		  else
+			gfc_internal_error ("HLS level for NUMA scope is invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope numa level %d of variable %s (file %s line %d)\n",
+              com->hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_SOCKET:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_SOCKET ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope socket of variable %s (file %s line %d)\n",
+              IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_CACHE:
+		  if ( com->hls_level == 1 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_1 ;
+		  else if ( com->hls_level == 2 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_2 ;
+		  else if ( com->hls_level == 3 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_3 ;
+		  else
+			gfc_internal_error ("HLS level for CACHE scope invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope cache level %d of variable %s (file %s line %d)\n",
+              com->hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_CORE:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CORE ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope core of variable %s (file %s line %d)\n",
+              IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_NONE:
+          /* do not privatize variables modified by hls or omp threadprivate pragmas */ 
+          if ( flag_mpc_privatize  && ! com->threadprivate ) {
+	fprintf( stderr, 
+	    "(Front-end Fortran) "
+	    "Automatic privatization to MPC task (variable %s in file %s line %d)\n",
+	    IDENTIFIER_POINTER( DECL_NAME(decl) ), 
+	    DECL_SOURCE_FILE(decl),
+	    DECL_SOURCE_LINE(decl) ) ;
+	DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_TASK ;
+      }
+        default:
+          break;
+      }
+	/* MPC HLS END */
 
       /* Place the back end declaration for this common block in
          GLOBAL_BINDING_LEVEL.  */
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index b473d66..e01ce26 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -606,9 +606,94 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)
     TREE_STATIC (decl) = 1;
 
   /* Handle threadprivate variables.  */
+  /* MPC OMP BEGIN */
+#if 0
   if (sym->attr.threadprivate
       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))
     DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
+#endif
+  if (sym->attr.threadprivate
+      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))
+  {
+    DECL_TLS_MODEL (decl) = TLS_MODEL_MPC_OPENMP ;
+
+    /* Verbose mode */
+    if ( flag_openmp_verbose && DECL_NAME(decl) ) 
+    {
+      fprintf( stderr, "MPC-OPENMP: Found threadprivate variable %s (file %s line %d)\n"
+	  , IDENTIFIER_POINTER( DECL_NAME(decl) )
+	 , DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+    }
+  }
+  /* MPC OMP END */
+  /* MPC HLS BEGIN */
+  if ( TREE_STATIC (decl) || DECL_EXTERNAL (decl) )
+    {
+      switch(sym->attr.hls_scope)
+      {
+        case HLS_SCOPE_NODE:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NODE ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope node of variable %s (file %s line %d)\n",
+            IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_NUMA:
+		  if ( sym->attr.hls_level == 1 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NUMA_LEVEL_1 ;
+		  else if ( sym->attr.hls_level == 2 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NUMA_LEVEL_2 ;
+		  else
+			internal_error ("HLS level for NUMA scope is invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope numa level %d of variable %s (file %s line %d)\n",
+			sym->attr.hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_SOCKET:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_SOCKET ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope socket of variable %s (file %s line %d)\n",
+            IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_CACHE:
+		  if ( sym->attr.hls_level == 1 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_1 ;
+		  else if ( sym->attr.hls_level == 2 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_2 ;
+		  else if ( sym->attr.hls_level == 3 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_3 ;
+		  else
+			internal_error ("HLS level for CACHE scope invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope cache level %d of variable %s (file %s line %d)\n",
+			sym->attr.hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_CORE:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CORE ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope core of variable %s (file %s line %d)\n",
+            IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_NONE:
+        default:
+	  break;
+      }
+
+      if ( flag_mpc_privatize && !sym->attr.threadprivate && !sym->attr.hls_scope) {
+        fprintf( stderr, 
+          "(Front-end Fortran) "
+          "Automatic privatization to MPC task (variable %s in file %s line %d)\n",
+          IDENTIFIER_POINTER( DECL_NAME(decl) ), 
+          DECL_SOURCE_FILE(decl),
+          DECL_SOURCE_LINE(decl) ) ;
+          DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_TASK ;
+      }
+    }
+  /* MPC HLS END */
 }
 
 
@@ -5534,7 +5619,11 @@ gfc_generate_function_code (gfc_namespace * ns)
   gfc_traverse_ns (ns, gfc_emit_parameter_debug_info);
 
   if (sym->attr.is_main_program)
+  {
+    /* force the main program to be noinline */
+    DECL_UNINLINABLE(fndecl) = 1;
     create_main_function (fndecl);
+  }
 
   current_procedure_symbol = previous_procedure_symbol;
 }
diff --git a/gcc/fortran/trans-openmp.c b/gcc/fortran/trans-openmp.c
index 7076e3b..4e410f7 100644
--- a/gcc/fortran/trans-openmp.c
+++ b/gcc/fortran/trans-openmp.c
@@ -1295,7 +1295,12 @@ gfc_trans_omp_atomic (gfc_code *code)
 static tree
 gfc_trans_omp_barrier (void)
 {
+  /* MPC OMP BEGIN */
+#if 0
   tree decl = builtin_decl_explicit (BUILT_IN_GOMP_BARRIER);
+#endif
+  tree decl = builtin_decl_explicit (BUILT_IN_MPC_BARRIER);
+/* MPC OMP END */
   return build_call_expr_loc (input_location, decl, 0);
 }
 
@@ -1566,7 +1571,12 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,
 static tree
 gfc_trans_omp_flush (void)
 {
+  /* MPC OMP BEGIN */
+#if 0
   tree decl = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);
+#endif
+  tree decl = builtin_decl_explicit (BUILT_IN_MPC_FLUSH);
+/* MPC OMP END */
   return build_call_expr_loc (input_location, decl, 0);
 }
 
@@ -1757,14 +1767,24 @@ gfc_trans_omp_task (gfc_code *code)
 static tree
 gfc_trans_omp_taskwait (void)
 {
-  tree decl = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);
+  /* MPC OMP BEGIN */
+  #if 0
+    tree decl = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);
+  #endif
+  tree decl = builtin_decl_explicit (BUILT_IN_MPC_TASKWAIT);
+  /* MPC OMP END */
   return build_call_expr_loc (input_location, decl, 0);
 }
 
 static tree
 gfc_trans_omp_taskyield (void)
 {
-  tree decl = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD);
+  /* MPC OMP BEGIN */
+  #if 0
+    tree decl = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD);
+  #endif
+  tree decl = builtin_decl_explicit (BUILT_IN_MPC_TASKYIELD);
+  /* MPC OMp END */
   return build_call_expr_loc (input_location, decl, 0);
 }
 
diff --git a/gcc/fortran/trans-stmt.h b/gcc/fortran/trans-stmt.h
index 415f76d..c08d197 100644
--- a/gcc/fortran/trans-stmt.h
+++ b/gcc/fortran/trans-stmt.h
@@ -64,6 +64,11 @@ tree gfc_trans_deallocate_array (tree);
 /* trans-openmp.c */
 tree gfc_trans_omp_directive (gfc_code *);
 
+/* MPC HLS BEGIN */
+/* hls.c */
+tree gfc_trans_hls_directive (gfc_code *);
+/* MPC HLS END */
+
 /* trans-io.c */
 tree gfc_trans_open (gfc_code *);
 tree gfc_trans_close (gfc_code *);
diff --git a/gcc/fortran/trans.c b/gcc/fortran/trans.c
index d7bdf26..935b353 100644
--- a/gcc/fortran/trans.c
+++ b/gcc/fortran/trans.c
@@ -1648,7 +1648,15 @@ trans_code (gfc_code * code, tree cond)
 	case EXEC_OMP_WORKSHARE:
 	  res = gfc_trans_omp_directive (code);
 	  break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_BARRIER:
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  res = gfc_trans_hls_directive (code);
+	  break;
+	/* MPC HLS END */
+	
 	default:
 	  internal_error ("gfc_trans_code(): Bad statement code");
 	}
diff --git a/gcc/fortran/types.def b/gcc/fortran/types.def
index e4cd1d1..7542d14 100644
--- a/gcc/fortran/types.def
+++ b/gcc/fortran/types.def
@@ -89,9 +89,14 @@ DEF_FUNCTION_TYPE_1 (BT_FN_VOID_VPTR, BT_VOID, BT_VOLATILE_PTR)
 DEF_FUNCTION_TYPE_1 (BT_FN_UINT_UINT, BT_UINT, BT_UINT)
 DEF_FUNCTION_TYPE_1 (BT_FN_PTR_PTR, BT_PTR, BT_PTR)
 DEF_FUNCTION_TYPE_1 (BT_FN_VOID_INT, BT_VOID, BT_INT)
-
+/* MPC HLS BEGIN */
+DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)
+/* MPC HLS END */
 
 DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)
+/* MPC OMP BEGIN */
+DEF_POINTER_TYPE (BT_PTR_FN_PTR_PTR, BT_FN_PTR_PTR)
+/* MPC OMP END */
 
 DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_LONGPTR_LONGPTR,
                      BT_BOOL, BT_PTR_LONG, BT_PTR_LONG)
@@ -149,6 +154,10 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I2_INT, BT_VOID, BT_VOLATILE_PTR, BT_I2, BT
 DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I4_INT, BT_VOID, BT_VOLATILE_PTR, BT_I4, BT_INT)
 DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I8_INT, BT_VOID, BT_VOLATILE_PTR, BT_I8, BT_INT)
 DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I16_INT, BT_VOID, BT_VOLATILE_PTR, BT_I16, BT_INT)
+/* MPC OMP BEGIN */
+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_INT_OMPFN_PTR, BT_VOID, BT_INT, BT_PTR_FN_PTR_PTR,
+		     BT_PTR)
+/* MPC OMP END */
 
 DEF_FUNCTION_TYPE_4 (BT_FN_VOID_OMPFN_PTR_UINT_UINT,
                      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)
@@ -158,6 +167,10 @@ DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_VPTR_PTR_INT, BT_VOID, BT_SIZE,
 		     BT_VOLATILE_PTR, BT_PTR, BT_INT)
 DEF_FUNCTION_TYPE_4 (BT_FN_VOID_SIZE_CONST_VPTR_PTR_INT, BT_VOID, BT_SIZE,
 		     BT_CONST_VOLATILE_PTR, BT_PTR, BT_INT)
+/* MPC OMP BEGIN */
+DEF_FUNCTION_TYPE_4 (BT_FN_VOID_INT_OMPFN_PTR_INT, BT_VOID, BT_INT, BT_PTR_FN_PTR_PTR,
+		     BT_PTR, BT_INT)
+/* MPC OMP END */
 
 DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,
                      BT_BOOL, BT_LONG, BT_LONG, BT_LONG,
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 74f88a7..147d0e5 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -731,6 +731,9 @@ proper position among the other output files.  */
 /* We pass any -flto flags on to the linker, which is expected
    to understand them.  In practice, this means it had better be collect2.  */
 /* %{e*} includes -export-dynamic; see comment in common.opt.  */
+
+/* MPC OMP begin */
+#if 0
 #ifndef LINK_COMMAND_SPEC
 #define LINK_COMMAND_SPEC "\
 %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
@@ -749,6 +752,26 @@ proper position among the other output files.  */
     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
     %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}"
 #endif
+#endif
+#ifndef LINK_COMMAND_SPEC
+#define LINK_COMMAND_SPEC "\
+%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
+    %(linker) " \
+    LINK_PLUGIN_SPEC \
+    "%{flto|flto=*:%<fcompare-debug*} \
+    %{flto} %{flto=*} %l " LINK_PIE_SPEC \
+   "%X %{o*} %{e*} %{N} %{n} %{r}\
+    %{s} %{t} %{u*} %{z} %{Z} %{!nostdlib:%{!nostartfiles:%S}}\
+    %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\
+    %{fgnu-tm:%:include(libitm.spec)%(link_itm)}\
+    %(mflib) " STACK_SPLIT_SPEC "\
+    %{fprofile-arcs|fprofile-generate*|coverage:-lgcov}\
+    %{fsanitize=address:" LIBASAN_SPEC "%{static:%ecannot specify -static with -fsanitize=address}}\
+    %{fsanitize=thread:" LIBTSAN_SPEC "}\
+    %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
+    %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}"
+#endif
+/* MPC OMP END */
 
 #ifndef LINK_LIBGCC_SPEC
 /* Generate -L options for startfile prefix list.  */
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index 52fbfc5..2864f92 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -5954,14 +5954,24 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)
   /* Threadprivate variables are predetermined.  */
   if (is_global_var (decl))
     {
+      /* MPC OMP BEGIN / MPC TLS BEGIN */
+#if 0
       if (DECL_THREAD_LOCAL_P (decl))
+#endif
+      if (DECL_MPC_THREAD_LOCAL_P (decl))
+      /* MPC OMP END / MPC TLS END */
 	return omp_notice_threadprivate_variable (ctx, decl, NULL_TREE);
 
       if (DECL_HAS_VALUE_EXPR_P (decl))
 	{
 	  tree value = get_base_address (DECL_VALUE_EXPR (decl));
 
+	  /* MPC OMP BEGIN / MPC TLS BEGIN */
+#if 0
 	  if (value && DECL_P (value) && DECL_THREAD_LOCAL_P (value))
+#endif
+	  if (value && DECL_P (value) && DECL_MPC_THREAD_LOCAL_P (value))
+	  /* MPC OMP END / MPC TLS END */
 	    return omp_notice_threadprivate_variable (ctx, decl, value);
 	}
     }
diff --git a/gcc/hls-builtins.def b/gcc/hls-builtins.def
new file mode 100644
index 0000000..638e2c8
--- /dev/null
+++ b/gcc/hls-builtins.def
@@ -0,0 +1,8 @@
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_BARRIER, "__extls_hls_barrier",
+		  BT_FN_VOID_INT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_SINGLE, "__extls_hls_single",
+		  BT_FN_BOOL_INT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_SINGLE_DONE, "__extls_hls_single_done",
+		  BT_FN_VOID_INT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_SINGLE_NOWAIT, "__extls_hls_single_nowait",
+		  BT_FN_BOOL_INT, ATTR_NOTHROW_LIST)
diff --git a/gcc/mpc-pass.c b/gcc/mpc-pass.c
new file mode 100644
index 0000000..254efb8
--- /dev/null
+++ b/gcc/mpc-pass.c
@@ -0,0 +1,303 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "tree-inline.h"
+#include "langhooks.h"
+#include "flags.h"
+#include "cgraph.h"
+#include "diagnostic.h"
+#include "timevar.h"
+#include "params.h"
+#include "fibheap.h"
+#include "intl.h"
+#include "tree-pass.h"
+#include "hashtab.h"
+#include "coverage.h"
+#include "ggc.h"
+#include "tree-flow.h"
+#include "rtl.h"
+#include "ipa-prop.h"
+
+extern struct varpool_node *varpool_nodes ;
+
+/* This pass is called only once: IPA pass */
+static unsigned int execute_mpc_warning_global_vars(void)
+{
+
+
+  return 0 ;
+}
+
+static bool gate_mpc_warning_global_vars (void)
+{
+  return warn_mpc != 0;
+}
+
+struct simple_ipa_opt_pass pass_mpc_warning_global_vars = 
+{
+ {
+  SIMPLE_IPA_PASS,
+  "mpcglobalvars",			/* name */
+  OPTGROUP_NONE,
+  gate_mpc_warning_global_vars,		/* gate */
+  execute_mpc_warning_global_vars,	/* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_EARLY_INLINING,			/* tv_id */
+  0,	                                /* properties_required */
+  0,				/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  TODO_dump_symtab 		        /* todo_flags_finish */
+ }
+};
+
+
+static int is_mpi = 0 ;
+static int is_mpc = 0 ;
+static int is_pthread = 0 ;
+static int is_mpc_thread = 0 ;
+static int is_sctk_thread = 0 ;
+
+
+static tree mpc_thread_mixing_1( tree * t_ptr, int * walk_subtrees ATTRIBUTE_UNUSED, void * s ATTRIBUTE_UNUSED) 
+{
+	tree t = *t_ptr ;
+	//return *t_ptr;
+
+  if ( TREE_CODE(t) == CALL_EXPR ) 
+  {
+    tree callee = get_callee_fndecl( t ) ;
+
+    if ( dump_file ) {
+      fprintf( dump_file, "\tCALL EXPR found\n" ) ;
+      if ( callee == NULL_TREE ) {
+	fprintf( dump_file, "\t -> Don't know the callee\n" ) ;
+      }
+    }
+
+    if ( callee != NULL_TREE && DECL_NAME( callee ) ) {
+      const char * name_callee = IDENTIFIER_POINTER( DECL_NAME( callee ) ) ;
+      if ( dump_file ) {
+	fprintf( dump_file, "\t -> name of the callee <%s>\n",
+	    name_callee ) ;
+      }
+
+      /* Check if this name is instance of MPC, MPI, pthread or mpc_thread */
+      if ( strncmp( name_callee, "MPI", 3 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of MPI\n" ) ;
+	}
+	is_mpi = 1 ;
+      }
+      if ( strncmp( name_callee, "MPC", 3 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of MPC\n" ) ;
+	}
+	is_mpc = 1 ;
+      }
+      if ( strncmp( name_callee, "pthread", 7 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of pthread\n" ) ;
+	}
+	is_pthread = 1 ;
+      }
+      if ( strncmp( name_callee, "mpc_thread", 10 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of MPC Thread\n" ) ;
+	}
+	is_mpc_thread = 1 ;
+      }
+      if ( strncmp( name_callee, "sctk_thread", 11 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of SCTK Thread\n" ) ;
+	}
+	is_sctk_thread = 1 ;
+      }
+
+    }
+  }
+	return NULL_TREE ;
+}
+
+static unsigned int execute_mpc_warning_thread_mixing(void)
+{
+
+	struct cgraph_node *node; 
+	//~ basic_block bb;
+	struct function *fun ;
+	//~ gimple_stmt_iterator gsi;
+
+	/* TODO the call graph contains only functions which are called within this
+	* file (or those which has a body and might be called from outside)
+     -> It seems to be enough to traverse the call graph,
+     check the function with no body
+     check the source file location (e.g., mpc.h)
+	*/
+
+	FOR_EACH_DEFINED_FUNCTION (node) 
+	{
+		tree t ;
+		if ( dump_file ) 
+		{
+			fprintf( dump_file, "===== Checking <%s>\n",
+			cgraph_node_name( node ) ) ;
+		}
+
+		t = node->symbol.decl ;
+
+		if ( TREE_CODE( t ) == FUNCTION_DECL ) 
+		{
+			fun = DECL_STRUCT_FUNCTION (t) ;
+			if ( fun != NULL && DECL_SAVED_TREE( t ) != NULL ) 
+			{
+				//~ FOR_EACH_BB_FN (bb, fun)
+					//~ for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+					//~ {
+						//~ walk_tree_without_duplicates_1( gsi_stmt (gsi), mpc_thread_mixing_1, NULL, NULL) ;
+					//~ }
+			} 
+			else 
+			{
+				if ( dump_file ) 
+				{
+					fprintf( dump_file, "-> Skip because the body is not available\n" ) ;
+				}
+			}
+		}
+	}
+
+	if ( dump_file ) 
+	{
+		fprintf( dump_file, "MPI content? %d\n", is_mpi ) ;
+		fprintf( dump_file, "MPC content? %d\n", is_mpc ) ;
+		fprintf( dump_file, "Pthread content? %d\n", is_pthread ) ;
+		fprintf( dump_file, "MPC thread content? %d\n", is_mpc_thread ) ;
+		fprintf( dump_file, "SCTK thread content? %d\n", is_sctk_thread ) ;
+	}
+
+
+	if ( is_mpi && is_mpc ) 
+	{
+		warning( 0, "Mixing calls to MPI and MPC is tedious") ;
+	}
+	if ( is_mpc_thread && (is_pthread || is_sctk_thread) ) 
+	{
+		warning( 0, "Mixing calls to pthread and MPC is tedious") ;
+	}
+	(void) mpc_thread_mixing_1;
+	return 0 ;
+}
+
+static bool gate_mpc_warning_thread_mixing(void)
+{
+  return warn_mpc != 0;
+}
+
+struct simple_ipa_opt_pass pass_mpc_warning_thread_mixing = 
+{
+ {
+  SIMPLE_IPA_PASS,
+  "pass_mpc_warning_thread_mixing",	/* name */
+  OPTGROUP_NONE,
+  gate_mpc_warning_thread_mixing,	/* gate */
+  execute_mpc_warning_thread_mixing,	/* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_EARLY_INLINING,			/* tv_id */
+  0,	                                /* properties_required */
+  0,				/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  TODO_dump_symtab 		        /* todo_flags_finish */
+ }
+};
+
+
+static unsigned int execute_mpc_remove_hls_node(void)
+{
+#if 0
+  struct varpool_node *curr_node = NULL ;
+
+  curr_node = varpool_nodes ; 
+
+  while ( curr_node != NULL ) {
+    tree t ;
+
+    t = curr_node->decl ;
+
+	if ( TREE_CODE(t) == VAR_DECL &&
+			is_global_var( t ) &&
+			!DECL_ARTIFICIAL( t ) &&
+			!TREE_READONLY( t ) && 
+			!DECL_IN_SYSTEM_HEADER( t ) ) {
+		if ( DECL_TLS_MODEL(t) == TLS_MODEL_HLS_NODE ) {
+			DECL_TLS_MODEL(t) = TLS_MODEL_NONE ;
+			if (DECL_RTL_SET_P (t))
+				make_decl_rtl (t);
+			fprintf( stderr, "(MPC optimization pass) Optimized HLS node variable %s in fine %s line %d base_var %p\n",
+					lang_hooks.decl_printable_name (t,2),
+					DECL_SOURCE_FILE(t),
+					DECL_SOURCE_LINE(t), t) ;
+
+		}
+	}
+    curr_node = curr_node->next ;
+  }
+
+  struct cgraph_node *node;
+  for (node = cgraph_nodes; node; node = node->next)
+  {
+	  tree decl = node->decl;
+	  struct function *this_cfun = DECL_STRUCT_FUNCTION (decl);
+	  basic_block this_block;
+	  FOR_EACH_BB_FN (this_block, this_cfun)
+	  {
+		  gimple_stmt_iterator gsi;
+		  for (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi)) {
+			  gimple stmt = gsi_stmt (gsi);
+			  if (gimple_code (stmt) == )
+		  }
+	  }
+  }
+
+				if (TREE_CODE (op) == ADDR_EXPR) {
+					fprintf(stderr, "recompute for base_var %p\n", get_base_var(op) );
+					recompute_tree_invariant_for_addr_expr (op);
+				}
+#endif
+
+  return 0 ;
+}
+
+static bool gate_mpc_remove_hls_node (void)
+{
+/*  return flag_mpc_hls != 0; */
+	return 0;
+}
+
+struct simple_ipa_opt_pass pass_mpc_remove_hls_node = 
+{
+ {
+  GIMPLE_PASS,
+  "mpcremovehlsnode",			/* name */
+  OPTGROUP_NONE,
+  gate_mpc_remove_hls_node,		/* gate */
+  execute_mpc_remove_hls_node,	/* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_NONE,			/* tv_id */
+  0,	                                /* properties_required */
+  0,				/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  0 		        /* todo_flags_finish */
+ }
+};
+
+
diff --git a/gcc/omp-builtins.def b/gcc/omp-builtins.def
index 83c26c4..7d3301a 100644
--- a/gcc/omp-builtins.def
+++ b/gcc/omp-builtins.def
@@ -208,3 +208,200 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SINGLE_COPY_START, "GOMP_single_copy_start",
 		  BT_FN_PTR, ATTR_NOTHROW_LEAF_LIST)
 DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SINGLE_COPY_END, "GOMP_single_copy_end",
 		  BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)
+
+/* MPC OMP BEGIN */
+DEF_MPC_BUILTIN (BUILT_IN_MPC_OMP_GET_THREAD_NUM, "mpcomp_get_thread_num",
+		  BT_FN_INT, ATTR_CONST_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_OMP_GET_NUM_THREADS, "mpcomp_get_num_threads",
+		  BT_FN_INT, ATTR_CONST_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ATOMIC_BEGIN, "__mpcomp_atomic_begin",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ATOMIC_END, "__mpcomp_atomic_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_BARRIER, "__mpcomp_barrier",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_TASKWAIT, "__mpcomp_taskwait",
+          BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_TASKYIELD, "__mpcomp_taskyield",
+          BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_CRITICAL_BEGIN, "__mpcomp_anonymous_critical_begin",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_CRITICAL_END, "__mpcomp_anonymous_critical_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_CRITICAL_NAME_BEGIN,
+		  "__mpcomp_named_critical_begin",
+		  BT_FN_VOID_PTRPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_CRITICAL_NAME_END,
+		  "__mpcomp_named_critical_end",
+		  BT_FN_VOID_PTRPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_FLUSH, "__mpcomp_flush",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+
+/* NOTE: Do not change the order of BUILT_IN_MPC_*_LOOP_BEGIN.  They
+   are used in index arithmetic with enum omp_clause_schedule_kind
+   in omp-low.c.  */
+DEF_MPC_BUILTIN (BUILT_IN_MPC_STATIC_LOOP_BEGIN,
+		  "__mpcomp_static_loop_begin",
+		  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,
+		  ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_DYNAMIC_LOOP_BEGIN,
+		  "__mpcomp_dynamic_loop_begin",
+		  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,
+		  ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_GUIDED_LOOP_BEGIN,
+		  "__mpcomp_guided_loop_begin",
+		  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,
+		  ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_RUNTIME_LOOP_BEGIN,
+		  "__mpcomp_runtime_loop_begin",
+		  BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,
+		  ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_STATIC_LOOP_BEGIN,
+		  "__mpcomp_ordered_static_loop_begin",
+		  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,
+		  ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_DYNAMIC_LOOP_BEGIN,
+		  "__mpcomp_ordered_dynamic_loop_begin",
+		  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,
+		  ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_GUIDED_LOOP_BEGIN,
+		  "__mpcomp_ordered_guided_loop_begin",
+		  BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,
+		  ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_RUNTIME_LOOP_BEGIN,
+		  "__mpcomp_ordered_runtime_loop_begin",
+		  BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,
+		  ATTR_NOTHROW_LIST)
+
+/* NOTE: Do not change the order of BUILT_IN_MPC_*_LOOP_NEXT.  They
+   are used in index arithmetic with enum omp_clause_schedule_kind
+   in omp-low.c.  */
+DEF_MPC_BUILTIN (BUILT_IN_MPC_STATIC_LOOP_NEXT, "__mpcomp_static_loop_next",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_DYNAMIC_LOOP_NEXT, "__mpcomp_dynamic_loop_next",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_GUIDED_LOOP_NEXT, "__mpcomp_guided_loop_next",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_RUNTIME_LOOP_NEXT, "__mpcomp_runtime_loop_next",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_STATIC_LOOP_NEXT,
+		  "__mpcomp_ordered_static_loop_next",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_DYNAMIC_LOOP_NEXT,
+		  "__mpcomp_ordered_dynamic_loop_next",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_GUIDED_LOOP_NEXT,
+		  "__mpcomp_ordered_guided_loop_next",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_LOOP_ORDERED_RUNTIME_LOOP_NEXT,
+		  "__mpcomp_ordered_runtime_loop_next",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+
+/* NOTE: Do not change the order of BUILT_IN_MPC_*_LOOP_NEXT_INOGRE_NOWAIT.  They
+   are used in index arithmetic with enum omp_clause_schedule_kind
+   in omp-low.c.  */
+DEF_MPC_BUILTIN (BUILT_IN_MPC_STATIC_LOOP_NEXT_IGNORE_NOWAIT, 
+		  "__mpcomp_static_loop_next_ignore_nowait",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_DYNAMIC_LOOP_NEXT_IGNORE_NOWAIT, 
+		  "__mpcomp_dynamic_loop_next_ignore_nowait",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_GUIDED_LOOP_NEXT_IGNORE_NOWAIT, 
+		  "__mpcomp_guided_loop_next_ignore_nowait",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_RUNTIME_LOOP_NEXT_IGNORE_NOWAIT, 
+		  "__mpcomp_runtime_loop_next_ignore_nowait",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_STATIC_LOOP_NEXT_IGNORE_NOWAIT,
+		  "__mpcomp_ordered_static_loop_next_ignore_nowait",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_DYNAMIC_LOOP_NEXT_IGNORE_NOWAIT,
+		  "__mpcomp_ordered_dynamic_loop_next_ignore_nowait",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_GUIDED_LOOP_NEXT_IGNORE_NOWAIT,
+		  "__mpcomp_ordered_guided_loop_next_ignore_nowait",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_LOOP_ORDERED_RUNTIME_LOOP_NEXT_IGNORE_NOWAIT,
+		  "__mpcomp_ordered_runtime_loop_next_ignore_nowait",
+		  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)
+
+/* NOTE: Do not change the order of BUILT_IN_MPC_PARALLEL_LOOP_*_BEGIN.
+   They are used in index arithmetic with enum omp_clause_schedule_kind
+   in omp-low.c.  */
+DEF_MPC_BUILTIN (BUILT_IN_MPC_PARALLEL_LOOP_STATIC_BEGIN,
+		  "__mpcomp_start_parallel_static_loop",
+		  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,
+		  ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_PARALLEL_LOOP_DYNAMIC_BEGIN,
+		  "__mpcomp_start_parallel_dynamic_loop",
+		  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,
+		  ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_PARALLEL_LOOP_GUIDED_BEGIN,
+		  "__mpcomp_start_parallel_guided_loop",
+		  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,
+		  ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_PARALLEL_LOOP_RUNTIME_BEGIN,
+		  "__mpcomp_start_parallel_runtime_loop",
+		  BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,
+		  ATTR_NOTHROW_LIST)
+
+/* NOTE: Do not change the order of BUILT_IN_MPC_*_LOOP_END.  They
+   are used in index arithmetic with enum omp_clause_schedule_kind
+   in omp-low.c.  */
+DEF_MPC_BUILTIN (BUILT_IN_MPC_STATIC_LOOP_END, "__mpcomp_static_loop_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_DYNAMIC_LOOP_END, "__mpcomp_dynamic_loop_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_GUIDED_LOOP_END, "__mpcomp_guided_loop_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_RUNTIME_LOOP_END, "__mpcomp_runtime_loop_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+
+/* NOTE: Do not change the order of BUILT_IN_MPC_*_LOOP_END_NOWAIT.  They
+   are used in index arithmetic with enum omp_clause_schedule_kind
+   in omp-low.c.  */
+DEF_MPC_BUILTIN (BUILT_IN_MPC_STATIC_LOOP_END_NOWAIT, 
+		  "__mpcomp_static_loop_end_nowait",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_DYNAMIC_LOOP_END_NOWAIT, 
+		  "__mpcomp_dynamic_loop_end_nowait",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_GUIDED_LOOP_END_NOWAIT, 
+		  "__mpcomp_guided_loop_end_nowait",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_RUNTIME_LOOP_END_NOWAIT, 
+		  "__mpcomp_runtime_loop_end_nowait",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+
+/* TODO finish these builtins */
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_BEGIN, "__mpcomp_ordered_begin",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_ORDERED_END, "__mpcomp_ordered_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+
+DEF_MPC_BUILTIN (BUILT_IN_MPC_PARALLEL_START, "__mpcomp_start_parallel_region",
+		  BT_FN_VOID_INT_OMPFN_PTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_TASK, "__mpcomp_task",
+          BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT,
+		  ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_SECTIONS_BEGIN, "__mpcomp_sections_begin",
+		  BT_FN_UINT_UINT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_SECTIONS_NEXT, "__mpcomp_sections_next",
+		  BT_FN_UINT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_PARALLEL_SECTIONS_BEGIN,
+		  "__mpcomp_start_sections_parallel_region",
+		  BT_FN_VOID_INT_OMPFN_PTR_INT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_SECTIONS_END, "__mpcomp_sections_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_SECTIONS_END_NOWAIT,
+		  "__mpcomp_sections_end_nowait",
+		  BT_FN_VOID, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_DO_SINGLE, "__mpcomp_do_single",
+		  BT_FN_BOOL, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_DO_SINGLE_COPYPRIVATE_BEGIN, 
+    		  "__mpcomp_do_single_copyprivate_begin",
+		  BT_FN_PTR, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_DO_SINGLE_COPYPRIVATE_END, 
+    		  "__mpcomp_do_single_copyprivate_end",
+		  BT_FN_VOID_PTR, ATTR_NOTHROW_LIST)
+/* MPC OMP END */
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
index 6a3969b..4ffe30e 100644
--- a/gcc/omp-low.c
+++ b/gcc/omp-low.c
@@ -1575,7 +1575,15 @@ create_omp_child_function (omp_context *ctx, bool task_copy)
     type = build_function_type_list (void_type_node, ptr_type_node,
 				     ptr_type_node, NULL_TREE);
   else
+    /* MPC OMP BEGIN */
+  {
+#if 0
     type = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);
+#endif
+    /* TODO Do the same for task_copy? */
+    type = build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE);
+  }
+  /* MPC OMP END */
 
   decl = build_decl (gimple_location (ctx->stmt),
 		     FUNCTION_DECL, name, type);
@@ -1595,8 +1603,12 @@ create_omp_child_function (omp_context *ctx, bool task_copy)
   DECL_CONTEXT (decl) = NULL_TREE;
   DECL_INITIAL (decl) = make_node (BLOCK);
 
-  t = build_decl (DECL_SOURCE_LOCATION (decl),
-		  RESULT_DECL, NULL_TREE, void_type_node);
+  /* MPC OMP BEGIN */
+#if 0
+  t = build_decl (DECL_SOURCE_LOCATION (decl), RESULT_DECL, NULL_TREE, void_type_node);
+#endif
+  t = build_decl (DECL_SOURCE_LOCATION (decl), RESULT_DECL, NULL_TREE, ptr_type_node);
+/* MPC OMP END */
   DECL_ARTIFICIAL (t) = 1;
   DECL_IGNORED_P (t) = 1;
   DECL_CONTEXT (t) = decl;
@@ -2064,9 +2076,16 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,
       else if (is_gimple_call (stmt))
 	{
 	  tree fndecl = gimple_call_fndecl (stmt);
+	   /* MPC OMP BEGIN */
+#if 0
 	  if (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL
 	      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_GOMP_BARRIER)
-	    remove = !check_omp_nesting_restrictions (stmt, ctx);
+	    check_omp_nesting_restrictions (stmt, ctx);
+#endif
+	  if (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL
+	      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_MPC_BARRIER)
+	    check_omp_nesting_restrictions (stmt, ctx);
+	  /* MPC OMP END */
 	}
       if (remove)
 	{
@@ -2156,7 +2175,12 @@ scan_omp (gimple_seq *body_p, omp_context *ctx)
 static tree
 build_omp_barrier (void)
 {
+  /* MPC OMP BEGIN */
+#if 0
   return build_call_expr (builtin_decl_explicit (BUILT_IN_GOMP_BARRIER), 0);
+#endif
+  return build_call_expr (builtin_decl_explicit (BUILT_IN_MPC_BARRIER), 0);
+  /* MPC OMP END */
 }
 
 /* If a context was created for STMT when it was scanned, return it.  */
@@ -2587,8 +2611,12 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,
      but it certainly is to C++ operator=.  */
   if (copyin_seq)
     {
-      x = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM),
-			   0);
+      /* MPC OMP BEGIN */
+#if 0
+  x = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM),
+#endif
+      x = build_call_expr (builtin_decl_explicit (BUILT_IN_MPC_OMP_GET_THREAD_NUM), 0);
+      /* MPC OMP END */
       x = build2 (NE_EXPR, boolean_type_node, x,
 		  build_int_cst (TREE_TYPE (x), 0));
       x = build3 (COND_EXPR, void_type_node, x, copyin_seq, NULL);
@@ -2783,14 +2811,22 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)
 	}
     }
 
-  stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_START),
-			    0);
+  /* MPC OMP BEGIN */
+#if 0
+  stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_START), 0);
+#endif
+  stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_MPC_ATOMIC_BEGIN), 0);
+  /* MPC OMP END */
   gimple_seq_add_stmt (stmt_seqp, stmt);
 
   gimple_seq_add_seq (stmt_seqp, sub_seq);
 
-  stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_END),
-			    0);
+  /* MPC OMP BEGIN */
+#if 0
+  stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_END), 0);
+#endif
+  stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_MPC_ATOMIC_END), 0);
+  /* MPC OMP END */
   gimple_seq_add_stmt (stmt_seqp, stmt);
 }
 
@@ -3016,13 +3052,15 @@ expand_parallel_call (struct omp_region *region, basic_block bb,
   gimple stmt;
   enum built_in_function start_ix;
   int start_ix2;
-  location_t clause_loc;
+  location_t clause_loc = 0;
   vec<tree, va_gc> *args;
 
   clauses = gimple_omp_parallel_clauses (entry_stmt);
 
   /* Determine what flavor of GOMP_parallel_start we will be
      emitting.  */
+/* MPC OMP BEGIN */
+#if 0
   start_ix = BUILT_IN_GOMP_PARALLEL_START;
   if (is_combined_parallel (region))
     {
@@ -3043,11 +3081,39 @@ expand_parallel_call (struct omp_region *region, basic_block bb,
 	  gcc_unreachable ();
 	}
     }
+#endif
+start_ix = BUILT_IN_MPC_PARALLEL_START;
+  if (is_combined_parallel (region))
+    {
+      switch (region->inner->type)
+	{
+	case GIMPLE_OMP_FOR:
+	  gcc_assert (region->inner->sched_kind != OMP_CLAUSE_SCHEDULE_AUTO);
+	  start_ix2 = ((int)BUILT_IN_MPC_PARALLEL_LOOP_STATIC_BEGIN
+		       + (region->inner->sched_kind
+			  == OMP_CLAUSE_SCHEDULE_RUNTIME
+			  ? 3 : region->inner->sched_kind));
+	  start_ix = (enum built_in_function)start_ix2;
+	  break;
+	case GIMPLE_OMP_SECTIONS:
+	  start_ix = BUILT_IN_MPC_PARALLEL_SECTIONS_BEGIN;
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+    }
+/* MPC OMP END */
 
   /* By default, the value of NUM_THREADS is zero (selected at run time)
      and there is no conditional.  */
   cond = NULL_TREE;
+  /* MPC OMP BEGIN */
+#if 0
   val = build_int_cst (unsigned_type_node, 0);
+#endif
+  /* By default, the number of threads is -1 */
+  val = build_int_cst (integer_type_node, -1);
+  /* MPC OMP END */
 
   c = find_omp_clause (clauses, OMP_CLAUSE_IF);
   if (c)
@@ -3057,14 +3123,22 @@ expand_parallel_call (struct omp_region *region, basic_block bb,
   if (c)
     {
       val = OMP_CLAUSE_NUM_THREADS_EXPR (c);
+      /* MPC BEGIN */
+      /* Ensure 'val' is of the correct type.  */
+		val = fold_convert_loc (clause_loc, unsigned_type_node, val);
+	  /* MPC END */
       clause_loc = OMP_CLAUSE_LOCATION (c);
     }
   else
     clause_loc = gimple_location (entry_stmt);
 
-  /* Ensure 'val' is of the correct type.  */
-  val = fold_convert_loc (clause_loc, unsigned_type_node, val);
-
+	/* MPC BEGIN */
+      /* Ensure 'val' is of the correct type.  */
+      #if 0
+		val = fold_convert_loc (clause_loc, unsigned_type_node, val);
+	  #endif
+	  /* MPC END */
+	  
   /* If we found the clause 'if (cond)', build either
      (cond != 0) or (cond ? val : 1u).  */
   if (cond)
@@ -3149,18 +3223,26 @@ expand_parallel_call (struct omp_region *region, basic_block bb,
   t2 = build_fold_addr_expr (gimple_omp_parallel_child_fn (entry_stmt));
 
   vec_alloc (args, 3 + vec_safe_length (ws_args));
+  /* MPC OMP BEGIN */
+#if 0
   args->quick_push (t2);
   args->quick_push (t1);
   args->quick_push (val);
+#endif
+  args->quick_push (val);
+  args->quick_push (t2);
+  args->quick_push (t1);
+  /* MPC OMP END */
   if (ws_args)
     args->splice (*ws_args);
-
+	
   t = build_call_expr_loc_vec (UNKNOWN_LOCATION,
 			       builtin_decl_explicit (start_ix), args);
 
   force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,
 			    false, GSI_CONTINUE_LINKING);
-
+/* MPC OMP BEGIN */
+#if 0
   t = gimple_omp_parallel_data_arg (entry_stmt);
   if (t == NULL)
     t = null_pointer_node;
@@ -3176,6 +3258,8 @@ expand_parallel_call (struct omp_region *region, basic_block bb,
 			   0);
   force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,
 			    false, GSI_CONTINUE_LINKING);
+#endif
+/* MPC OMP END */
 }
 
 
@@ -3224,12 +3308,18 @@ expand_task_call (basic_block bb, gimple entry_stmt)
     t3 = null_pointer_node;
   else
     t3 = build_fold_addr_expr_loc (loc, t);
-
+  /* MPC OMP BEGIN */
+  #if 0
   t = build_call_expr (builtin_decl_explicit (BUILT_IN_GOMP_TASK),
 		       7, t1, t2, t3,
 		       gimple_omp_task_arg_size (entry_stmt),
 		       gimple_omp_task_arg_align (entry_stmt), cond, flags);
-
+  #endif
+  t = build_call_expr (builtin_decl_explicit (BUILT_IN_MPC_TASK),
+               7, t1, t2, t3,
+			   gimple_omp_task_arg_size (entry_stmt),
+			   gimple_omp_task_arg_align (entry_stmt), cond, flags);
+  /* MPC OMP END */
   force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,
 			    false, GSI_CONTINUE_LINKING);
 }
@@ -4269,12 +4359,65 @@ expand_omp_for_generic (struct omp_region *region,
 
   /* Add the loop cleanup function.  */
   gsi = gsi_last_bb (exit_bb);
+  /* MPC OMP BEGIN */
+#if 0
   if (gimple_omp_return_nowait_p (gsi_stmt (gsi)))
     t = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END_NOWAIT);
   else
     t = builtin_decl_explicit (BUILT_IN_GOMP_LOOP_END);
   stmt = gimple_build_call (t, 0);
   gsi_insert_after (&gsi, stmt, GSI_SAME_STMT);
+#endif
+  /* Do not generate a call to 'end' if this is a combined region */
+  if ( !is_combined_parallel(region) ) {
+    if (gimple_omp_return_nowait_p (gsi_stmt (gsi)))
+    {
+		switch(fd->sched_kind)
+		{
+			case OMP_CLAUSE_SCHEDULE_STATIC:
+			case OMP_CLAUSE_SCHEDULE_AUTO:
+				t = builtin_decl_explicit(BUILT_IN_MPC_STATIC_LOOP_END_NOWAIT);
+				break;
+			case OMP_CLAUSE_SCHEDULE_DYNAMIC:
+				t = builtin_decl_explicit(BUILT_IN_MPC_DYNAMIC_LOOP_END_NOWAIT);
+				break;
+			case OMP_CLAUSE_SCHEDULE_GUIDED:
+				t = builtin_decl_explicit(BUILT_IN_MPC_GUIDED_LOOP_END_NOWAIT);
+				break;
+			case OMP_CLAUSE_SCHEDULE_RUNTIME:
+				t = builtin_decl_explicit(BUILT_IN_MPC_RUNTIME_LOOP_END_NOWAIT);
+				break;
+			default:
+				t = builtin_decl_explicit(BUILT_IN_MPC_STATIC_LOOP_END_NOWAIT);
+				break;
+		}
+     }
+    else
+    {
+		switch(fd->sched_kind)
+		{
+			case OMP_CLAUSE_SCHEDULE_STATIC:
+			case OMP_CLAUSE_SCHEDULE_AUTO:
+				t = builtin_decl_explicit(BUILT_IN_MPC_STATIC_LOOP_END);
+				break;
+			case OMP_CLAUSE_SCHEDULE_DYNAMIC:
+				t = builtin_decl_explicit(BUILT_IN_MPC_DYNAMIC_LOOP_END);
+				break;
+			case OMP_CLAUSE_SCHEDULE_GUIDED:
+				t = builtin_decl_explicit(BUILT_IN_MPC_GUIDED_LOOP_END);
+				break;
+			case OMP_CLAUSE_SCHEDULE_RUNTIME:
+				t = builtin_decl_explicit(BUILT_IN_MPC_RUNTIME_LOOP_END);
+				break;
+			default:
+				t = builtin_decl_explicit(BUILT_IN_MPC_STATIC_LOOP_END);
+				break;
+		}
+     }
+    stmt = gimple_build_call (t, 0);
+    gsi_insert_after (&gsi, stmt, GSI_SAME_STMT);
+  }
+  /* MPC OMP END */
   gsi_remove (&gsi, true);
 
   /* Connect the new blocks.  */
@@ -4394,6 +4537,8 @@ expand_omp_for_static_nochunk (struct omp_region *region,
   gsi = gsi_last_bb (entry_bb);
   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);
 
+  /* MPC OMP BEGIN */
+#if 0
   t = fold_binary (fd->loop.cond_code, boolean_type_node,
 		   fold_convert (type, fd->loop.n1),
 		   fold_convert (type, fd->loop.n2));
@@ -4438,12 +4583,20 @@ expand_omp_for_static_nochunk (struct omp_region *region,
       gsi = gsi_last_bb (entry_bb);
     }
 
-  t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS), 0);
+   t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS), 0);
+#endif
+  t = build_call_expr (builtin_decl_explicit (BUILT_IN_MPC_OMP_GET_NUM_THREADS), 0);
+/* MPC OMP END */
   t = fold_convert (itype, t);
   nthreads = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,
 				       true, GSI_SAME_STMT);
 
-  t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM), 0);
+/* MPC OMP BEGIN */
+#if 0
+   t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM), 0);
+#endif
+  t = build_call_expr (builtin_decl_explicit (BUILT_IN_MPC_OMP_GET_THREAD_NUM), 0);
+/* MPC OMP END */
   t = fold_convert (itype, t);
   threadid = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,
 				       true, GSI_SAME_STMT);
@@ -4665,6 +4818,8 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)
   si = gsi_last_bb (entry_bb);
   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_FOR);
 
+  /* MPC OMP BEGIN */
+#if 0
   t = fold_binary (fd->loop.cond_code, boolean_type_node,
 		   fold_convert (type, fd->loop.n1),
 		   fold_convert (type, fd->loop.n2));
@@ -4709,12 +4864,20 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)
       si = gsi_last_bb (entry_bb);
     }
 
-  t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS), 0);
+   t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS), 0);
+#endif
+  t = build_call_expr (builtin_decl_explicit (BUILT_IN_MPC_OMP_GET_NUM_THREADS), 0);
+/* MPC OMP END */
   t = fold_convert (itype, t);
   nthreads = force_gimple_operand_gsi (&si, t, true, NULL_TREE,
 				       true, GSI_SAME_STMT);
 
-  t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM), 0);
+ /* MPC OMP BEGIN */
+#if 0
+   t = build_call_expr (builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM), 0);
+#endif
+  t = build_call_expr (builtin_decl_explicit (BUILT_IN_MPC_OMP_GET_THREAD_NUM), 0);
+/* MPC OMP END */
   t = fold_convert (itype, t);
   threadid = force_gimple_operand_gsi (&si, t, true, NULL_TREE,
 				       true, GSI_SAME_STMT);
@@ -4983,6 +5146,8 @@ expand_omp_for (struct omp_region *region)
       fn_index = (fd.sched_kind == OMP_CLAUSE_SCHEDULE_RUNTIME)
 		  ? 3 : fd.sched_kind;
       fn_index += fd.have_ordered * 4;
+      /* MPC OMP BEGIN */
+#if 0
       start_ix = ((int)BUILT_IN_GOMP_LOOP_STATIC_START) + fn_index;
       next_ix = ((int)BUILT_IN_GOMP_LOOP_STATIC_NEXT) + fn_index;
       if (fd.iter_type == long_long_unsigned_type_node)
@@ -4992,6 +5157,19 @@ expand_omp_for (struct omp_region *region)
 	  next_ix += ((int)BUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT
 		      - (int)BUILT_IN_GOMP_LOOP_STATIC_NEXT);
 	}
+#endif
+	  start_ix = ((int)BUILT_IN_MPC_STATIC_LOOP_BEGIN) + fn_index;
+      next_ix = ((int)BUILT_IN_MPC_STATIC_LOOP_NEXT) + fn_index;
+      /* MPC FIXME need to create the ULL functions */
+      if (fd.iter_type == long_long_unsigned_type_node)
+	{
+		gcc_unreachable() ;
+	  start_ix += ((int)BUILT_IN_GOMP_LOOP_ULL_STATIC_START
+			- (int)BUILT_IN_GOMP_LOOP_STATIC_START);
+	  next_ix += ((int)BUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT
+		      - (int)BUILT_IN_GOMP_LOOP_STATIC_NEXT);
+	}
+	/* MPC OMP END */
       expand_omp_for_generic (region, &fd, (enum built_in_function) start_ix,
 			      (enum built_in_function) next_ix);
     }
@@ -5098,13 +5276,23 @@ expand_omp_sections (struct omp_region *region)
       /* If we are not inside a combined parallel+sections region,
 	 call GOMP_sections_start.  */
       t = build_int_cst (unsigned_type_node, len - 1);
-      u = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_START);
+      /* MPC OMP BEGIN */
+#if 0
+ u = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_START);
+#endif
+ u = builtin_decl_explicit (BUILT_IN_MPC_SECTIONS_BEGIN);
+    /* MPC OMP END */
       stmt = gimple_build_call (u, 1, t);
     }
   else
     {
       /* Otherwise, call GOMP_sections_next.  */
-      u = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_NEXT);
+      /* MPC OMP BEGIN */
+#if 0
+u = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_NEXT);
+#endif
+u = builtin_decl_explicit (BUILT_IN_MPC_SECTIONS_NEXT);
+	/* MPC OMP END */
       stmt = gimple_build_call (u, 0);
     }
   gimple_call_set_lhs (stmt, vin);
@@ -5193,7 +5381,12 @@ expand_omp_sections (struct omp_region *region)
       si = gsi_last_bb (l1_bb);
       gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_CONTINUE);
 
-      bfn_decl = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_NEXT);
+      /* MPC OMP BEGIN */
+#if 0
+bfn_decl = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_NEXT);
+#endif
+bfn_decl = builtin_decl_explicit (BUILT_IN_MPC_SECTIONS_NEXT);
+/* MPC OMP END */
       stmt = gimple_build_call (bfn_decl, 0);
       gimple_call_set_lhs (stmt, vnext);
       gsi_insert_after (&si, stmt, GSI_SAME_STMT);
@@ -5204,10 +5397,18 @@ expand_omp_sections (struct omp_region *region)
 
   /* Cleanup function replaces GIMPLE_OMP_RETURN in EXIT_BB.  */
   si = gsi_last_bb (l2_bb);
-  if (gimple_omp_return_nowait_p (gsi_stmt (si)))
-    t = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_END_NOWAIT);
-  else
-    t = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_END);
+  /* MPC OMP BEGIN */
+#if 0
+      if (gimple_omp_return_nowait_p (gsi_stmt (si)))
+	t = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_END_NOWAIT);
+      else
+	t = builtin_decl_explicit (BUILT_IN_GOMP_SECTIONS_END);
+#endif
+		if (gimple_omp_return_nowait_p (gsi_stmt (si)))
+	t = builtin_decl_explicit (BUILT_IN_MPC_SECTIONS_END_NOWAIT);
+      else
+	t = builtin_decl_explicit (BUILT_IN_MPC_SECTIONS_END);
+/* MPC OMP END */
   stmt = gimple_build_call (t, 0);
   gsi_insert_after (&si, stmt, GSI_SAME_STMT);
   gsi_remove (&si, true);
@@ -5749,7 +5950,12 @@ expand_omp_atomic_mutex (basic_block load_bb, basic_block store_bb,
   si = gsi_last_bb (load_bb);
   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_ATOMIC_LOAD);
 
-  t = builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_START);
+  /* MPC OMP BEGIN */
+#if 0
+ t = builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_START);
+#endif
+ t = builtin_decl_explicit (BUILT_IN_MPC_ATOMIC_BEGIN);
+/* MPC OMP END */
   t = build_call_expr (t, 0);
   force_gimple_operand_gsi (&si, t, true, NULL_TREE, true, GSI_SAME_STMT);
 
@@ -5764,7 +5970,12 @@ expand_omp_atomic_mutex (basic_block load_bb, basic_block store_bb,
 			      stored_val);
   gsi_insert_before (&si, stmt, GSI_SAME_STMT);
 
-  t = builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_END);
+  /* MPC OMP BEGIN */
+#if 0
+t = builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_END);
+#endif
+t = builtin_decl_explicit (BUILT_IN_MPC_ATOMIC_END);
+/* MPC OMP END */
   t = build_call_expr (t, 0);
   force_gimple_operand_gsi (&si, t, true, NULL_TREE, true, GSI_SAME_STMT);
   gsi_remove (&si, true);
@@ -6192,7 +6403,12 @@ lower_omp_single_simple (gimple single_stmt, gimple_seq *pre_p)
   gimple call, cond;
   tree lhs, decl;
 
-  decl = builtin_decl_explicit (BUILT_IN_GOMP_SINGLE_START);
+  /* MPC OMP BEGIN */
+#if 0
+decl = builtin_decl_explicit (BUILT_IN_GOMP_SINGLE_START);
+#endif
+decl = builtin_decl_explicit (BUILT_IN_MPC_DO_SINGLE);
+/* MPC OMP END */
   lhs = create_tmp_var (TREE_TYPE (TREE_TYPE (decl)), NULL);
   call = gimple_build_call (decl, 0);
   gimple_call_set_lhs (call, lhs);
@@ -6254,7 +6470,12 @@ lower_omp_single_copy (gimple single_stmt, gimple_seq *pre_p, omp_context *ctx)
   l1 = create_artificial_label (loc);
   l2 = create_artificial_label (loc);
 
-  bfn_decl = builtin_decl_explicit (BUILT_IN_GOMP_SINGLE_COPY_START);
+  /* MPC OMP BEGIN */
+#if 0
+bfn_decl = builtin_decl_explicit (BUILT_IN_GOMP_SINGLE_COPY_START);
+#endif
+bfn_decl = builtin_decl_explicit (BUILT_IN_MPC_DO_SINGLE_COPYPRIVATE_BEGIN);
+/* MPC OMP END */
   t = build_call_expr_loc (loc, bfn_decl, 0);
   t = fold_convert_loc (loc, ptr_type, t);
   gimplify_assign (ctx->receiver_decl, t, pre_p);
@@ -6274,7 +6495,12 @@ lower_omp_single_copy (gimple single_stmt, gimple_seq *pre_p, omp_context *ctx)
 			      &copyin_seq, ctx);
 
   t = build_fold_addr_expr_loc (loc, ctx->sender_decl);
-  bfn_decl = builtin_decl_explicit (BUILT_IN_GOMP_SINGLE_COPY_END);
+  /* MPC OMP BEGIN */
+#if 0
+bfn_decl = builtin_decl_explicit (BUILT_IN_GOMP_SINGLE_COPY_END);
+#endif
+bfn_decl = builtin_decl_explicit (BUILT_IN_MPC_DO_SINGLE_COPYPRIVATE_END);
+/* MPC OMP END */
   t = build_call_expr_loc (loc, bfn_decl, 1, t);
   gimplify_and_add (t, pre_p);
 
@@ -6356,7 +6582,12 @@ lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)
   gsi_replace (gsi_p, bind, true);
   gimple_bind_add_stmt (bind, stmt);
 
-  bfn_decl = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);
+  /* MPC OMP BEGIN */
+#if 0
+bfn_decl = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);
+#endif
+bfn_decl = builtin_decl_explicit (BUILT_IN_MPC_OMP_GET_THREAD_NUM);
+/* MPC OMP END */
   x = build_call_expr_loc (loc, bfn_decl, 0);
   x = build2 (EQ_EXPR, boolean_type_node, x, integer_zero_node);
   x = build3 (COND_EXPR, void_type_node, x, NULL, build_and_jump (&lab));
@@ -6396,7 +6627,12 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)
   gsi_replace (gsi_p, bind, true);
   gimple_bind_add_stmt (bind, stmt);
 
-  x = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ORDERED_START),
+  /* MPC OMP BEGIN */
+#if 0
+x = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ORDERED_START),
+#endif
+x = gimple_build_call (builtin_decl_explicit (BUILT_IN_MPC_ORDERED_BEGIN),
+/* MPC OMP END */
 			 0);
   gimple_bind_add_stmt (bind, x);
 
@@ -6405,7 +6641,12 @@ lower_omp_ordered (gimple_stmt_iterator *gsi_p, omp_context *ctx)
   gimple_bind_add_seq (bind, gimple_omp_body (stmt));
   gimple_omp_set_body (stmt, NULL);
 
-  x = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ORDERED_END), 0);
+  /* MPC OMP BEGIN */
+#if 0
+x = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ORDERED_END), 0);
+#endif
+x = gimple_build_call (builtin_decl_explicit (BUILT_IN_MPC_ORDERED_END), 0);
+/* MPC OMP END */
   gimple_bind_add_stmt (bind, x);
 
   gimple_bind_add_stmt (bind, gimple_build_omp_return (true));
@@ -6462,6 +6703,10 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)
 	  DECL_COMMON (decl) = 1;
 	  DECL_ARTIFICIAL (decl) = 1;
 	  DECL_IGNORED_P (decl) = 1;
+	  /* MPC OMP BEGIN */
+	  /* Put this variable TASK scope to get one copy per MPI task */
+	  DECL_TLS_MODEL (decl) = TLS_MODEL_MPC_TASK;
+	  /* MPC OMP END */
 	  varpool_finalize_decl (decl);
 
 	  splay_tree_insert (critical_name_mutexes, (splay_tree_key) name,
@@ -6470,20 +6715,40 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)
       else
 	decl = (tree) n->value;
 
-      lock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_NAME_START);
+     /* MPC OMP BEGIN */
+#if 0
+	  lock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_NAME_START);
       lock = build_call_expr_loc (loc, lock, 1, build_fold_addr_expr_loc (loc, decl));
 
       unlock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_NAME_END);
       unlock = build_call_expr_loc (loc, unlock, 1,
 				build_fold_addr_expr_loc (loc, decl));
+#endif
+	  lock = builtin_decl_explicit (BUILT_IN_MPC_CRITICAL_NAME_BEGIN);
+      lock = build_call_expr_loc (loc, lock, 1, build_fold_addr_expr_loc (loc, decl));
+
+      unlock = builtin_decl_explicit (BUILT_IN_MPC_CRITICAL_NAME_END);
+      unlock = build_call_expr_loc (loc, unlock, 1,
+				build_fold_addr_expr_loc (loc, decl));
+/* MPC OMP END */
+      
     }
   else
     {
-      lock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_START);
+		/* MPC OMP BEGIN */
+#if 0
+	  lock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_START);
       lock = build_call_expr_loc (loc, lock, 0);
 
       unlock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_END);
       unlock = build_call_expr_loc (loc, unlock, 0);
+#endif
+	  lock = builtin_decl_explicit (BUILT_IN_MPC_CRITICAL_BEGIN);
+      lock = build_call_expr_loc (loc, lock, 0);
+
+      unlock = builtin_decl_explicit (BUILT_IN_MPC_CRITICAL_END);
+      unlock = build_call_expr_loc (loc, unlock, 0);
+/* MPC OMP END */
     }
 
   push_gimplify_context (&gctx);
diff --git a/gcc/passes.c b/gcc/passes.c
index 22d843a..2b62488 100644
--- a/gcc/passes.c
+++ b/gcc/passes.c
@@ -1302,6 +1302,10 @@ init_optimization_passes (void)
   p = &all_small_ipa_passes;
   NEXT_PASS (pass_ipa_free_lang_data);
   NEXT_PASS (pass_ipa_function_and_variable_visibility);
+   /* MPC ADD begin */
+  NEXT_PASS (pass_mpc_warning_global_vars);
+  NEXT_PASS (pass_mpc_warning_thread_mixing);
+  /* MPC ADD end */
   NEXT_PASS (pass_early_local_passes);
     {
       struct opt_pass **p = &pass_early_local_passes.pass.sub;
diff --git a/gcc/print-tree.c b/gcc/print-tree.c
index e8a0c77..e0bf7d9 100644
--- a/gcc/print-tree.c
+++ b/gcc/print-tree.c
@@ -464,6 +464,44 @@ print_node (FILE *file, const char *prefix, tree node, int indent)
 	      case TLS_MODEL_LOCAL_EXEC:
 		fputs (" tls-local-exec", file);
 		break;
+		/* BEGIN MPC */
+	      case TLS_MODEL_MPC_OPENMP:
+		fputs (" MPC tls-mpc-openmp", file);
+		break;
+	      case TLS_MODEL_MPC_TASK:
+		fputs (" MPC tls-mpc-task", file);
+		break;
+	      case TLS_MODEL_MPC_THREAD:
+		fputs (" MPC tls-mpc-thread", file);
+		break;
+	      case TLS_MODEL_MPC_PROCESS:
+		fputs (" MPC tls-mpc-process", file);
+		break;
+	      case TLS_MODEL_HLS_NODE:
+		fputs ("", file);
+		break;
+	      case TLS_MODEL_HLS_NUMA_LEVEL_2:
+		fputs (" MPC tls-mpc-hls-numa-level2", file);
+		break;
+	      case TLS_MODEL_HLS_NUMA_LEVEL_1:
+		fputs (" MPC tls-mpc-hls-numa-level1", file);
+		break;
+	      case TLS_MODEL_HLS_SOCKET:
+		fputs (" MPC tls-mpc-hls-socket", file);
+		break;
+	      case TLS_MODEL_HLS_CACHE_LEVEL_3:
+		fputs (" MPC tls-mpc-hls-cache-level3", file);
+		break;
+	      case TLS_MODEL_HLS_CACHE_LEVEL_2:
+		fputs (" MPC tls-mpc-hls-cache-level2", file);
+		break;
+	      case TLS_MODEL_HLS_CACHE_LEVEL_1:
+		fputs (" MPC tls-mpc-hls-cache-level1", file);
+		break;
+	      case TLS_MODEL_HLS_CORE:
+		fputs (" MPC tls-mpc-hls-core", file);
+		break;
+		/* MPC END */
 	      default:
 		gcc_unreachable ();
 	    }
diff --git a/gcc/rtl.h b/gcc/rtl.h
index 91f3387..92f9c7c 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -1616,28 +1616,55 @@ do {									\
 #define SYMBOL_FLAG_SMALL	(1 << 2)
 #define SYMBOL_REF_SMALL_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_SMALL) != 0)
-/* The three-bit field at [5:3] is true for TLS variables; use
+/* MPC HLS BEGIN */
+#if 0
+	/* The three-bit field at [5:3] is true for TLS variables; use
+	   SYMBOL_REF_TLS_MODEL to extract the field as an enum tls_model.  */
+	#define SYMBOL_FLAG_TLS_SHIFT	3
+	#define SYMBOL_REF_TLS_MODEL(RTX) \
+	  ((enum tls_model) ((SYMBOL_REF_FLAGS (RTX) >> SYMBOL_FLAG_TLS_SHIFT) & 7))
+	/* Set if this symbol is not defined in this translation unit.  */
+	#define SYMBOL_FLAG_EXTERNAL	(1 << 6)
+	#define SYMBOL_REF_EXTERNAL_P(RTX) \
+	  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_EXTERNAL) != 0)
+	/* Set if this symbol has a block_symbol structure associated with it.  */
+	#define SYMBOL_FLAG_HAS_BLOCK_INFO (1 << 7)
+	#define SYMBOL_REF_HAS_BLOCK_INFO_P(RTX) \
+	  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_HAS_BLOCK_INFO) != 0)
+	/* Set if this symbol is a section anchor.  SYMBOL_REF_ANCHOR_P implies
+	   SYMBOL_REF_HAS_BLOCK_INFO_P.  */
+	#define SYMBOL_FLAG_ANCHOR	(1 << 8)
+	#define SYMBOL_REF_ANCHOR_P(RTX) \
+	  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_ANCHOR) != 0)
+
+	/* Subsequent bits are available for the target to use.  */
+	#define SYMBOL_FLAG_MACH_DEP_SHIFT	9
+	#define SYMBOL_FLAG_MACH_DEP		(1 << SYMBOL_FLAG_MACH_DEP_SHIFT)
+
+#endif
+/* The three-bit field at [6:3] is true for TLS variables; use
    SYMBOL_REF_TLS_MODEL to extract the field as an enum tls_model.  */
 #define SYMBOL_FLAG_TLS_SHIFT	3
 #define SYMBOL_REF_TLS_MODEL(RTX) \
-  ((enum tls_model) ((SYMBOL_REF_FLAGS (RTX) >> SYMBOL_FLAG_TLS_SHIFT) & 7))
+  ((enum tls_model) ((SYMBOL_REF_FLAGS (RTX) >> SYMBOL_FLAG_TLS_SHIFT) & 31))
 /* Set if this symbol is not defined in this translation unit.  */
-#define SYMBOL_FLAG_EXTERNAL	(1 << 6)
+#define SYMBOL_FLAG_EXTERNAL	(1 << 8)
 #define SYMBOL_REF_EXTERNAL_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_EXTERNAL) != 0)
 /* Set if this symbol has a block_symbol structure associated with it.  */
-#define SYMBOL_FLAG_HAS_BLOCK_INFO (1 << 7)
+#define SYMBOL_FLAG_HAS_BLOCK_INFO (1 << 9)
 #define SYMBOL_REF_HAS_BLOCK_INFO_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_HAS_BLOCK_INFO) != 0)
 /* Set if this symbol is a section anchor.  SYMBOL_REF_ANCHOR_P implies
    SYMBOL_REF_HAS_BLOCK_INFO_P.  */
-#define SYMBOL_FLAG_ANCHOR	(1 << 8)
+#define SYMBOL_FLAG_ANCHOR	(1 << 10)
 #define SYMBOL_REF_ANCHOR_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_ANCHOR) != 0)
 
 /* Subsequent bits are available for the target to use.  */
-#define SYMBOL_FLAG_MACH_DEP_SHIFT	9
+#define SYMBOL_FLAG_MACH_DEP_SHIFT	11
 #define SYMBOL_FLAG_MACH_DEP		(1 << SYMBOL_FLAG_MACH_DEP_SHIFT)
+/* MPC HLS END */
 
 /* If SYMBOL_REF_HAS_BLOCK_INFO_P (RTX), this is the object_block
    structure to which the symbol belongs, or NULL if it has not been
diff --git a/gcc/stor-layout.c b/gcc/stor-layout.c
index 24cad6c..bd691c1 100644
--- a/gcc/stor-layout.c
+++ b/gcc/stor-layout.c
@@ -685,6 +685,7 @@ layout_decl (tree decl, unsigned int known_align)
   /* Evaluate nonconstant size only once, either now or as soon as safe.  */
   if (DECL_SIZE (decl) != 0 && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)
     DECL_SIZE (decl) = variable_size (DECL_SIZE (decl));
+  
   if (DECL_SIZE_UNIT (decl) != 0
       && TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST)
     DECL_SIZE_UNIT (decl) = variable_size (DECL_SIZE_UNIT (decl));
diff --git a/gcc/tree-pass.h b/gcc/tree-pass.h
index 0c83921..1c29c12 100644
--- a/gcc/tree-pass.h
+++ b/gcc/tree-pass.h
@@ -365,6 +365,12 @@ extern struct gimple_opt_pass pass_split_functions;
 extern struct gimple_opt_pass pass_feedback_split_functions;
 extern struct gimple_opt_pass pass_strength_reduction;
 
+/* MPC ADD BEGIN */
+extern struct simple_ipa_opt_pass pass_mpc_warning_global_vars;/* IPA Passes */
+extern struct simple_ipa_opt_pass pass_mpc_warning_thread_mixing;extern struct simple_ipa_opt_pass pass_ipa_lower_emutls;
+extern struct simple_ipa_opt_pass pass_mpc_remove_hls_node;extern struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility;
+/* MPC ADD END */
+
 /* IPA Passes */
 extern struct simple_ipa_opt_pass pass_ipa_lower_emutls;
 extern struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility;
diff --git a/gcc/tree-profile.c b/gcc/tree-profile.c
index 9985b40..9d8ed8c 100644
--- a/gcc/tree-profile.c
+++ b/gcc/tree-profile.c
@@ -565,7 +565,7 @@ struct simple_ipa_opt_pass pass_ipa_tree_profile =
 {
  {
   SIMPLE_IPA_PASS,
-  "profile",  		               /* name */
+  "profile",  		               	   /* name */
   OPTGROUP_NONE,                       /* optinfo_flags */
   gate_tree_profile_ipa,               /* gate */
   tree_profiling,                      /* execute */
diff --git a/gcc/tree-ssa-operands.c b/gcc/tree-ssa-operands.c
index a4ddb6e..b815295 100644
--- a/gcc/tree-ssa-operands.c
+++ b/gcc/tree-ssa-operands.c
@@ -362,12 +362,10 @@ finalize_ssa_uses (gimple stmt)
   if (build_vuse != NULL_TREE)
     {
       tree oldvuse = gimple_vuse (stmt);
-      if (oldvuse
-	  && TREE_CODE (oldvuse) == SSA_NAME)
-	oldvuse = SSA_NAME_VAR (oldvuse);
-      if (oldvuse != (build_vuse != NULL_TREE
-		      ? build_vuse : build_vdef))
-	gimple_set_vuse (stmt, NULL_TREE);
+      if (oldvuse && TREE_CODE (oldvuse) == SSA_NAME)
+		oldvuse = SSA_NAME_VAR (oldvuse);
+      if (oldvuse != (build_vuse != NULL_TREE ? build_vuse : build_vdef))
+		gimple_set_vuse (stmt, NULL_TREE);
       build_uses.safe_insert (0, (tree)gimple_vuse_ptr (stmt));
     }
 
diff --git a/gcc/tree.c b/gcc/tree.c
index 077eed8..b676b17 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -2632,23 +2634,38 @@ staticp (tree arg)
       return arg;
 
     case VAR_DECL:
-      return ((TREE_STATIC (arg) || DECL_EXTERNAL (arg))
+    {
+		if( getenv("MPC_DYN_PRIV_ENABLED") )
+		{
+			if( (TREE_STATIC (arg) || DECL_EXTERNAL (arg))
+			  && DECL_THREAD_LOCAL_P (arg) )
+			{
+					return NULL;
+			}
+		}
+     tree predicate = ((TREE_STATIC (arg) || DECL_EXTERNAL (arg))
 	      && ! DECL_THREAD_LOCAL_P (arg)
 	      && ! DECL_DLLIMPORT_P (arg)
 	      ? arg : NULL);
-
+    
+      return predicate;
+	}
     case CONST_DECL:
+
       return ((TREE_STATIC (arg) || DECL_EXTERNAL (arg))
 	      ? arg : NULL);
 
     case CONSTRUCTOR:
+
       return TREE_STATIC (arg) ? arg : NULL;
 
     case LABEL_DECL:
     case STRING_CST:
+
       return arg;
 
     case COMPONENT_REF:
+
       /* If the thing being referenced is not a field, then it is
 	 something language specific.  */
       gcc_assert (TREE_CODE (TREE_OPERAND (arg, 1)) == FIELD_DECL);
diff --git a/gcc/tree.h b/gcc/tree.h
index 33d8c5d..e4721a0 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -3177,6 +3177,12 @@ struct GTY(()) tree_parm_decl {
    thread-local storage.  */
 #define DECL_THREAD_LOCAL_P(NODE) \
   (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model >= TLS_MODEL_REAL)
+  
+/* MPC BEGIN */
+#define DECL_MPC_THREAD_LOCAL_P(NODE) \
+  (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model >= TLS_MODEL_REAL) && \
+  (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model != TLS_MODEL_MPC_TASK)
+/* MPC END */
 
 /* In a non-local VAR_DECL with static storage duration, true if the
    variable has an initialization priority.  If false, the variable
@@ -3212,8 +3218,12 @@ struct GTY(()) tree_decl_with_vis {
  ENUM_BITFIELD(symbol_visibility) visibility : 2;
  unsigned visibility_specified : 1;
  /* Belongs to VAR_DECL exclusively.  */
- ENUM_BITFIELD(tls_model) tls_model : 3;
-
+  /* MPC HLS BEGIN */
+#if 0
+	ENUM_BITFIELD(tls_model) tls_model : 3;
+#endif
+	ENUM_BITFIELD(tls_model) tls_model : 5;
+ /* MPC HLS END */
  /* Belong to FUNCTION_DECL exclusively.  */
  unsigned init_priority_p : 1;
  /* Used by C++ only.  Might become a generic decl flag.  */
diff --git a/gcc/varasm.c b/gcc/varasm.c
index d39d291..6df4d62 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -1872,10 +1872,38 @@ assemble_variable_contents (tree decl, const char *name,
       if (DECL_INITIAL (decl)
 	  && DECL_INITIAL (decl) != error_mark_node
 	  && !initializer_zerop (DECL_INITIAL (decl)))
-	/* Output the actual data.  */
-	output_constant (DECL_INITIAL (decl),
-			 tree_low_cst (DECL_SIZE_UNIT (decl), 1),
-			 DECL_ALIGN (decl));
+	  {
+		  if( !getenv("MPC_DYN_PRIV_ENABLED") )
+		  {
+				/* Output the actual data.  */
+				output_constant (DECL_INITIAL (decl),
+						 tree_low_cst (DECL_SIZE_UNIT (decl), 1),
+						 DECL_ALIGN (decl));
+		  }
+		  else
+		  {
+			  if( initializer_constant_valid_p (DECL_INITIAL (decl), TREE_TYPE (DECL_INITIAL (decl))) ) 
+			  {
+				/* Output the actual data.  */
+				output_constant (DECL_INITIAL (decl),
+						 tree_low_cst (DECL_SIZE_UNIT (decl), 1),
+						 DECL_ALIGN (decl));
+			  }
+			  else
+			  {
+				  /* MPC DYN */
+				  printf("MPC : Non constant initializer detected in variable %s.\n", name );
+				  
+				  /* Lets put 0x3 in the variable to help
+				   * identify uninitialized globals */
+				  output_constant (integer_three_node,
+						 tree_low_cst (DECL_SIZE_UNIT (decl), 1),
+						 DECL_ALIGN (decl));
+				  
+				  /* MPC DYN */
+			  }
+		  }
+	  }
       else
 	/* Leave space for it.  */
 	assemble_zeros (tree_low_cst (DECL_SIZE_UNIT (decl), 1));
diff --git a/libgfortran/Makefile.am b/libgfortran/Makefile.am
index abc23cd..04c99a2 100644
--- a/libgfortran/Makefile.am
+++ b/libgfortran/Makefile.am
@@ -71,6 +71,12 @@ AM_CFLAGS += $(SECTION_FLAGS)
 # Some targets require additional compiler options for IEEE compatibility.
 AM_CFLAGS += $(IEEE_FLAGS)
 
+# Create a temporary lib for build with auto privatization
+gfor_unit_src = \
+io/open.c \
+io/unix.c \
+io/unit.c 
+
 gfor_io_src= \
 io/close.c \
 io/file_pos.c \
@@ -79,13 +85,10 @@ io/inquire.c \
 io/intrinsics.c \
 io/list_read.c \
 io/lock.c \
-io/open.c \
 io/read.c \
 io/size_from_kind.c \
 io/transfer.c \
 io/transfer128.c \
-io/unit.c \
-io/unix.c \
 io/write.c \
 io/fbuf.c
 
@@ -817,6 +820,21 @@ BUILT_SOURCES=$(gfor_built_src) $(gfor_built_specific_src) \
 prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \
     $(gfor_helper_src) $(gfor_io_headers) $(gfor_specific_src)
 
+libgfortranunit_a_SOURCES = $(gfor_unit_src)
+
+# Add libgfortran dirs to system includes in order to avoid auto privatization during build...
+libgfortranunit_a_CFLAGS = \
+-fPIC \
+-fmpc-privatize \
+-isystem $(srcdir) \
+-isystem $(srcdir)/io/ \
+-isystem $(srcdir)/runtime/ \
+-isystem $(srcdir)/config/ \
+-isystem $(srcdir)/caf/ \
+$(AM_CFLAGS)
+
+noinst_LIBRARIES = libgfortranunit.a
+
 if onestep
 # dummy sources for libtool
 BUILT_SOURCES+=libgfortran_c.c libgfortran_f.f90
@@ -842,10 +860,10 @@ libgfortran_c.lo: $(filter %.c,$(prereq_SRC))
 #	$(LTPPFCCOMPILE) -c -o $@ $^ -combine
 
 libgfortran_la_SOURCES = libgfortran_c.c $(filter-out %.c,$(prereq_SRC))
-
+libgfortran_la_LIBADD = libgfortranunit.a
 else
 libgfortran_la_SOURCES = $(prereq_SRC)
-
+libgfortran_la_LIBADD = libgfortranunit.a
 endif
 
 I_M4_DEPS=m4/iparm.m4
diff --git a/libgfortran/Makefile.in b/libgfortran/Makefile.in
index 62b9f7a..a7f26e4 100644
--- a/libgfortran/Makefile.in
+++ b/libgfortran/Makefile.in
@@ -66,6 +67,15 @@ mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs
 CONFIG_HEADER = config.h
 CONFIG_CLEAN_FILES = libgfortran.spec
 CONFIG_CLEAN_VPATH_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+ARFLAGS = cru
+libgfortranunit_a_AR = $(AR) $(ARFLAGS)
+libgfortranunit_a_LIBADD =
+am__objects_1 = libgfortranunit_a-open.$(OBJEXT) \
+	libgfortranunit_a-unix.$(OBJEXT) \
+	libgfortranunit_a-unit.$(OBJEXT)
+am_libgfortranunit_a_OBJECTS = $(am__objects_1)
+libgfortranunit_a_OBJECTS = $(am_libgfortranunit_a_OBJECTS)
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
 am__vpath_adj = case $$p in \
     $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
@@ -101,15 +111,14 @@ LTLIBRARIES = $(cafexeclib_LTLIBRARIES) $(myexeclib_LTLIBRARIES) \
 libcaf_single_la_LIBADD =
 am_libcaf_single_la_OBJECTS = single.lo
 libcaf_single_la_OBJECTS = $(am_libcaf_single_la_OBJECTS)
-libgfortran_la_LIBADD =
-am__objects_1 = backtrace.lo bounds.lo compile_options.lo \
+am__objects_2 = backtrace.lo bounds.lo compile_options.lo \
 	convert_char.lo environ.lo error.lo fpu.lo main.lo memory.lo \
 	pause.lo stop.lo string.lo select.lo
-am__objects_2 = all_l1.lo all_l2.lo all_l4.lo all_l8.lo all_l16.lo
-am__objects_3 = any_l1.lo any_l2.lo any_l4.lo any_l8.lo any_l16.lo
-am__objects_4 = count_1_l.lo count_2_l.lo count_4_l.lo count_8_l.lo \
+am__objects_3 = all_l1.lo all_l2.lo all_l4.lo all_l8.lo all_l16.lo
+am__objects_4 = any_l1.lo any_l2.lo any_l4.lo any_l8.lo any_l16.lo
+am__objects_5 = count_1_l.lo count_2_l.lo count_4_l.lo count_8_l.lo \
 	count_16_l.lo
-am__objects_5 = maxloc0_4_i1.lo maxloc0_8_i1.lo maxloc0_16_i1.lo \
+am__objects_6 = maxloc0_4_i1.lo maxloc0_8_i1.lo maxloc0_16_i1.lo \
 	maxloc0_4_i2.lo maxloc0_8_i2.lo maxloc0_16_i2.lo \
 	maxloc0_4_i4.lo maxloc0_8_i4.lo maxloc0_16_i4.lo \
 	maxloc0_4_i8.lo maxloc0_8_i8.lo maxloc0_16_i8.lo \
@@ -118,7 +127,7 @@ am__objects_5 = maxloc0_4_i1.lo maxloc0_8_i1.lo maxloc0_16_i1.lo \
 	maxloc0_4_r8.lo maxloc0_8_r8.lo maxloc0_16_r8.lo \
 	maxloc0_4_r10.lo maxloc0_8_r10.lo maxloc0_16_r10.lo \
 	maxloc0_4_r16.lo maxloc0_8_r16.lo maxloc0_16_r16.lo
-am__objects_6 = maxloc1_4_i1.lo maxloc1_8_i1.lo maxloc1_16_i1.lo \
+am__objects_7 = maxloc1_4_i1.lo maxloc1_8_i1.lo maxloc1_16_i1.lo \
 	maxloc1_4_i2.lo maxloc1_8_i2.lo maxloc1_16_i2.lo \
 	maxloc1_4_i4.lo maxloc1_8_i4.lo maxloc1_16_i4.lo \
 	maxloc1_4_i8.lo maxloc1_8_i8.lo maxloc1_16_i8.lo \
@@ -127,10 +136,10 @@ am__objects_6 = maxloc1_4_i1.lo maxloc1_8_i1.lo maxloc1_16_i1.lo \
 	maxloc1_4_r8.lo maxloc1_8_r8.lo maxloc1_16_r8.lo \
 	maxloc1_4_r10.lo maxloc1_8_r10.lo maxloc1_16_r10.lo \
 	maxloc1_4_r16.lo maxloc1_8_r16.lo maxloc1_16_r16.lo
-am__objects_7 = maxval_i1.lo maxval_i2.lo maxval_i4.lo maxval_i8.lo \
+am__objects_8 = maxval_i1.lo maxval_i2.lo maxval_i4.lo maxval_i8.lo \
 	maxval_i16.lo maxval_r4.lo maxval_r8.lo maxval_r10.lo \
 	maxval_r16.lo
-am__objects_8 = minloc0_4_i1.lo minloc0_8_i1.lo minloc0_16_i1.lo \
+am__objects_9 = minloc0_4_i1.lo minloc0_8_i1.lo minloc0_16_i1.lo \
 	minloc0_4_i2.lo minloc0_8_i2.lo minloc0_16_i2.lo \
 	minloc0_4_i4.lo minloc0_8_i4.lo minloc0_16_i4.lo \
 	minloc0_4_i8.lo minloc0_8_i8.lo minloc0_16_i8.lo \
@@ -139,7 +148,7 @@ am__objects_8 = minloc0_4_i1.lo minloc0_8_i1.lo minloc0_16_i1.lo \
 	minloc0_4_r8.lo minloc0_8_r8.lo minloc0_16_r8.lo \
 	minloc0_4_r10.lo minloc0_8_r10.lo minloc0_16_r10.lo \
 	minloc0_4_r16.lo minloc0_8_r16.lo minloc0_16_r16.lo
-am__objects_9 = minloc1_4_i1.lo minloc1_8_i1.lo minloc1_16_i1.lo \
+am__objects_10 = minloc1_4_i1.lo minloc1_8_i1.lo minloc1_16_i1.lo \
 	minloc1_4_i2.lo minloc1_8_i2.lo minloc1_16_i2.lo \
 	minloc1_4_i4.lo minloc1_8_i4.lo minloc1_16_i4.lo \
 	minloc1_4_i8.lo minloc1_8_i8.lo minloc1_16_i8.lo \
@@ -148,60 +157,60 @@ am__objects_9 = minloc1_4_i1.lo minloc1_8_i1.lo minloc1_16_i1.lo \
 	minloc1_4_r8.lo minloc1_8_r8.lo minloc1_16_r8.lo \
 	minloc1_4_r10.lo minloc1_8_r10.lo minloc1_16_r10.lo \
 	minloc1_4_r16.lo minloc1_8_r16.lo minloc1_16_r16.lo
-am__objects_10 = minval_i1.lo minval_i2.lo minval_i4.lo minval_i8.lo \
+am__objects_11 = minval_i1.lo minval_i2.lo minval_i4.lo minval_i8.lo \
 	minval_i16.lo minval_r4.lo minval_r8.lo minval_r10.lo \
 	minval_r16.lo
-am__objects_11 = product_i1.lo product_i2.lo product_i4.lo \
+am__objects_12 = product_i1.lo product_i2.lo product_i4.lo \
 	product_i8.lo product_i16.lo product_r4.lo product_r8.lo \
 	product_r10.lo product_r16.lo product_c4.lo product_c8.lo \
 	product_c10.lo product_c16.lo
-am__objects_12 = sum_i1.lo sum_i2.lo sum_i4.lo sum_i8.lo sum_i16.lo \
+am__objects_13 = sum_i1.lo sum_i2.lo sum_i4.lo sum_i8.lo sum_i16.lo \
 	sum_r4.lo sum_r8.lo sum_r10.lo sum_r16.lo sum_c4.lo sum_c8.lo \
 	sum_c10.lo sum_c16.lo
-am__objects_13 = bessel_r4.lo bessel_r8.lo bessel_r10.lo bessel_r16.lo
-am__objects_14 = iall_i1.lo iall_i2.lo iall_i4.lo iall_i8.lo \
+am__objects_14 = bessel_r4.lo bessel_r8.lo bessel_r10.lo bessel_r16.lo
+am__objects_15 = iall_i1.lo iall_i2.lo iall_i4.lo iall_i8.lo \
 	iall_i16.lo
-am__objects_15 = iany_i1.lo iany_i2.lo iany_i4.lo iany_i8.lo \
+am__objects_16 = iany_i1.lo iany_i2.lo iany_i4.lo iany_i8.lo \
 	iany_i16.lo
-am__objects_16 = iparity_i1.lo iparity_i2.lo iparity_i4.lo \
+am__objects_17 = iparity_i1.lo iparity_i2.lo iparity_i4.lo \
 	iparity_i8.lo iparity_i16.lo
-am__objects_17 = norm2_r4.lo norm2_r8.lo norm2_r10.lo norm2_r16.lo
-am__objects_18 = parity_l1.lo parity_l2.lo parity_l4.lo parity_l8.lo \
+am__objects_18 = norm2_r4.lo norm2_r8.lo norm2_r10.lo norm2_r16.lo
+am__objects_19 = parity_l1.lo parity_l2.lo parity_l4.lo parity_l8.lo \
 	parity_l16.lo
-am__objects_19 = matmul_i1.lo matmul_i2.lo matmul_i4.lo matmul_i8.lo \
+am__objects_20 = matmul_i1.lo matmul_i2.lo matmul_i4.lo matmul_i8.lo \
 	matmul_i16.lo matmul_r4.lo matmul_r8.lo matmul_r10.lo \
 	matmul_r16.lo matmul_c4.lo matmul_c8.lo matmul_c10.lo \
 	matmul_c16.lo
-am__objects_20 = matmul_l4.lo matmul_l8.lo matmul_l16.lo
-am__objects_21 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \
+am__objects_21 = matmul_l4.lo matmul_l8.lo matmul_l16.lo
+am__objects_22 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \
 	transpose_r4.lo transpose_r8.lo transpose_r10.lo \
 	transpose_r16.lo transpose_c4.lo transpose_c8.lo \
 	transpose_c10.lo transpose_c16.lo
-am__objects_22 = shape_i4.lo shape_i8.lo shape_i16.lo
-am__objects_23 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo
-am__objects_24 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo
-am__objects_25 = cshift1_4.lo cshift1_8.lo cshift1_16.lo
-am__objects_26 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \
+am__objects_23 = shape_i4.lo shape_i8.lo shape_i16.lo
+am__objects_24 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo
+am__objects_25 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo
+am__objects_26 = cshift1_4.lo cshift1_8.lo cshift1_16.lo
+am__objects_27 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \
 	reshape_r4.lo reshape_r8.lo reshape_r10.lo reshape_r16.lo \
 	reshape_c4.lo reshape_c8.lo reshape_c10.lo reshape_c16.lo
-am__objects_27 = in_pack_i1.lo in_pack_i2.lo in_pack_i4.lo \
+am__objects_28 = in_pack_i1.lo in_pack_i2.lo in_pack_i4.lo \
 	in_pack_i8.lo in_pack_i16.lo in_pack_r4.lo in_pack_r8.lo \
 	in_pack_r10.lo in_pack_r16.lo in_pack_c4.lo in_pack_c8.lo \
 	in_pack_c10.lo in_pack_c16.lo
-am__objects_28 = in_unpack_i1.lo in_unpack_i2.lo in_unpack_i4.lo \
+am__objects_29 = in_unpack_i1.lo in_unpack_i2.lo in_unpack_i4.lo \
 	in_unpack_i8.lo in_unpack_i16.lo in_unpack_r4.lo \
 	in_unpack_r8.lo in_unpack_r10.lo in_unpack_r16.lo \
 	in_unpack_c4.lo in_unpack_c8.lo in_unpack_c10.lo \
 	in_unpack_c16.lo
-am__objects_29 = exponent_r4.lo exponent_r8.lo exponent_r10.lo \
+am__objects_30 = exponent_r4.lo exponent_r8.lo exponent_r10.lo \
 	exponent_r16.lo
-am__objects_30 = fraction_r4.lo fraction_r8.lo fraction_r10.lo \
+am__objects_31 = fraction_r4.lo fraction_r8.lo fraction_r10.lo \
 	fraction_r16.lo
-am__objects_31 = nearest_r4.lo nearest_r8.lo nearest_r10.lo \
+am__objects_32 = nearest_r4.lo nearest_r8.lo nearest_r10.lo \
 	nearest_r16.lo
-am__objects_32 = set_exponent_r4.lo set_exponent_r8.lo \
+am__objects_33 = set_exponent_r4.lo set_exponent_r8.lo \
 	set_exponent_r10.lo set_exponent_r16.lo
-am__objects_33 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_r16_i4.lo \
+am__objects_34 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_r16_i4.lo \
 	pow_c4_i4.lo pow_c8_i4.lo pow_c10_i4.lo pow_c16_i4.lo \
 	pow_i4_i8.lo pow_i8_i8.lo pow_i16_i8.lo pow_r4_i8.lo \
 	pow_r8_i8.lo pow_r10_i8.lo pow_r16_i8.lo pow_c4_i8.lo \
@@ -209,43 +218,42 @@ am__objects_33 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_r16_i4.lo \
 	pow_i8_i16.lo pow_i16_i16.lo pow_r4_i16.lo pow_r8_i16.lo \
 	pow_r10_i16.lo pow_r16_i16.lo pow_c4_i16.lo pow_c8_i16.lo \
 	pow_c10_i16.lo pow_c16_i16.lo
-am__objects_34 = rrspacing_r4.lo rrspacing_r8.lo rrspacing_r10.lo \
+am__objects_35 = rrspacing_r4.lo rrspacing_r8.lo rrspacing_r10.lo \
 	rrspacing_r16.lo
-am__objects_35 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \
+am__objects_36 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \
 	spacing_r16.lo
-am__objects_36 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \
+am__objects_37 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \
 	pack_i16.lo pack_r4.lo pack_r8.lo pack_r10.lo pack_r16.lo \
 	pack_c4.lo pack_c8.lo pack_c10.lo pack_c16.lo
-am__objects_37 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \
+am__objects_38 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \
 	unpack_i16.lo unpack_r4.lo unpack_r8.lo unpack_r10.lo \
 	unpack_r16.lo unpack_c4.lo unpack_c8.lo unpack_c10.lo \
 	unpack_c16.lo
-am__objects_38 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \
+am__objects_39 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \
 	spread_i16.lo spread_r4.lo spread_r8.lo spread_r10.lo \
 	spread_r16.lo spread_c4.lo spread_c8.lo spread_c10.lo \
 	spread_c16.lo
-am__objects_39 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \
+am__objects_40 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \
 	cshift0_i8.lo cshift0_i16.lo cshift0_r4.lo cshift0_r8.lo \
 	cshift0_r10.lo cshift0_r16.lo cshift0_c4.lo cshift0_c8.lo \
 	cshift0_c10.lo cshift0_c16.lo
-am__objects_40 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \
-	$(am__objects_5) $(am__objects_6) $(am__objects_7) \
-	$(am__objects_8) $(am__objects_9) $(am__objects_10) \
-	$(am__objects_11) $(am__objects_12) $(am__objects_13) \
-	$(am__objects_14) $(am__objects_15) $(am__objects_16) \
-	$(am__objects_17) $(am__objects_18) $(am__objects_19) \
-	$(am__objects_20) $(am__objects_21) $(am__objects_22) \
-	$(am__objects_23) $(am__objects_24) $(am__objects_25) \
-	$(am__objects_26) $(am__objects_27) $(am__objects_28) \
-	$(am__objects_29) $(am__objects_30) $(am__objects_31) \
-	$(am__objects_32) $(am__objects_33) $(am__objects_34) \
-	$(am__objects_35) $(am__objects_36) $(am__objects_37) \
-	$(am__objects_38) $(am__objects_39)
-am__objects_41 = close.lo file_pos.lo format.lo inquire.lo \
-	intrinsics.lo list_read.lo lock.lo open.lo read.lo \
-	size_from_kind.lo transfer.lo transfer128.lo unit.lo unix.lo \
-	write.lo fbuf.lo
-am__objects_42 = associated.lo abort.lo access.lo args.lo \
+am__objects_41 = $(am__objects_3) $(am__objects_4) $(am__objects_5) \
+	$(am__objects_6) $(am__objects_7) $(am__objects_8) \
+	$(am__objects_9) $(am__objects_10) $(am__objects_11) \
+	$(am__objects_12) $(am__objects_13) $(am__objects_14) \
+	$(am__objects_15) $(am__objects_16) $(am__objects_17) \
+	$(am__objects_18) $(am__objects_19) $(am__objects_20) \
+	$(am__objects_21) $(am__objects_22) $(am__objects_23) \
+	$(am__objects_24) $(am__objects_25) $(am__objects_26) \
+	$(am__objects_27) $(am__objects_28) $(am__objects_29) \
+	$(am__objects_30) $(am__objects_31) $(am__objects_32) \
+	$(am__objects_33) $(am__objects_34) $(am__objects_35) \
+	$(am__objects_36) $(am__objects_37) $(am__objects_38) \
+	$(am__objects_39) $(am__objects_40)
+am__objects_42 = close.lo file_pos.lo format.lo inquire.lo \
+	intrinsics.lo list_read.lo lock.lo read.lo size_from_kind.lo \
+	transfer.lo transfer128.lo write.lo fbuf.lo
+am__objects_43 = associated.lo abort.lo access.lo args.lo \
 	bit_intrinsics.lo c99_functions.lo chdir.lo chmod.lo clock.lo \
 	cpu_time.lo cshift0.lo ctime.lo date_and_time.lo dtime.lo \
 	env.lo eoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo \
@@ -260,8 +268,8 @@ am__objects_42 = associated.lo abort.lo access.lo args.lo \
 	system_clock.lo time.lo transpose_generic.lo umask.lo \
 	unlink.lo unpack_generic.lo in_pack_generic.lo \
 	in_unpack_generic.lo
-am__objects_43 =
-am__objects_44 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \
+am__objects_44 =
+am__objects_45 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \
 	_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \
 	_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \
 	_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \
@@ -285,18 +293,18 @@ am__objects_44 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \
 	_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \
 	_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \
 	_anint_r8.lo _anint_r10.lo _anint_r16.lo
-am__objects_45 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \
+am__objects_46 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \
 	_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \
 	_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \
 	_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \
 	_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \
 	_mod_r10.lo _mod_r16.lo
-am__objects_46 = misc_specifics.lo
-am__objects_47 = $(am__objects_44) $(am__objects_45) $(am__objects_46) \
+am__objects_47 = misc_specifics.lo
+am__objects_48 = $(am__objects_45) $(am__objects_46) $(am__objects_47) \
 	dprod_r8.lo f2c_specifics.lo
-am__objects_48 = $(am__objects_1) $(am__objects_40) $(am__objects_41) \
-	$(am__objects_42) $(am__objects_43) $(am__objects_47)
-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_48)
+am__objects_49 = $(am__objects_2) $(am__objects_41) $(am__objects_42) \
+	$(am__objects_43) $(am__objects_44) $(am__objects_48)
+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_49)
 @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo
 libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)
 libgfortranbegin_la_LIBADD =
@@ -327,8 +335,8 @@ LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 FCCOMPILE = $(FC) $(AM_FCFLAGS) $(FCFLAGS)
 LTFCCOMPILE = $(LIBTOOL) --tag=FC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=compile $(FC) $(AM_FCFLAGS) $(FCFLAGS)
-SOURCES = $(libcaf_single_la_SOURCES) $(libgfortran_la_SOURCES) \
-	$(libgfortranbegin_la_SOURCES)
+SOURCES = $(libgfortranunit_a_SOURCES) $(libcaf_single_la_SOURCES) \
+	$(libgfortran_la_SOURCES) $(libgfortranbegin_la_SOURCES)
 MULTISRCTOP = 
 MULTIBUILDTOP = 
 MULTIDIRS = 
@@ -522,6 +530,13 @@ AM_CPPFLAGS = -iquote$(srcdir)/io -I$(srcdir)/$(MULTISRCTOP)../gcc \
 	      -I$(srcdir)/$(MULTISRCTOP)../libgcc \
 	      -I$(MULTIBUILDTOP)../libgcc
 
+
+# Create a temporary lib for build with auto privatization
+gfor_unit_src = \
+io/open.c \
+io/unix.c \
+io/unit.c 
+
 gfor_io_src = \
 io/close.c \
 io/file_pos.c \
@@ -530,13 +545,10 @@ io/inquire.c \
 io/intrinsics.c \
 io/list_read.c \
 io/lock.c \
-io/open.c \
 io/read.c \
 io/size_from_kind.c \
 io/transfer.c \
 io/transfer128.c \
-io/unit.c \
-io/unix.c \
 io/write.c \
 io/fbuf.c
 
@@ -1258,6 +1270,20 @@ BUILT_SOURCES = $(gfor_built_src) $(gfor_built_specific_src) \
 prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \
     $(gfor_helper_src) $(gfor_io_headers) $(gfor_specific_src)
 
+libgfortranunit_a_SOURCES = $(gfor_unit_src)
+
+# Add libgfortran dirs to system includes in order to avoid auto privatization during build...
+libgfortranunit_a_CFLAGS = \
+-fPIC \
+-fmpc-privatize \
+-isystem $(srcdir) \
+-isystem $(srcdir)/io/ \
+-isystem $(srcdir)/runtime/ \
+-isystem $(srcdir)/config/ \
+-isystem $(srcdir)/caf/ \
+$(AM_CFLAGS)
+
+noinst_LIBRARIES = libgfortranunit.a
 @onestep_FALSE@libgfortran_la_SOURCES = $(prereq_SRC)
 
 #libgfortran_f.o: $(filter %.f %.f90,$(prereq_SRC))
@@ -1272,6 +1298,8 @@ prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \
 #libgfortran_F.lo: 
 #	$(LTPPFCCOMPILE) -c -o $@ $^ -combine
 @onestep_TRUE@libgfortran_la_SOURCES = libgfortran_c.c $(filter-out %.c,$(prereq_SRC))
+@onestep_FALSE@libgfortran_la_LIBADD = libgfortranunit.a
+@onestep_TRUE@libgfortran_la_LIBADD = libgfortranunit.a
 I_M4_DEPS = m4/iparm.m4
 I_M4_DEPS0 = $(I_M4_DEPS) m4/iforeach.m4
 I_M4_DEPS1 = $(I_M4_DEPS) m4/ifunction.m4
@@ -1333,6 +1361,13 @@ distclean-hdr:
 	-rm -f config.h stamp-h1
 libgfortran.spec: $(top_builddir)/config.status $(srcdir)/libgfortran.spec.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libgfortranunit.a: $(libgfortranunit_a_OBJECTS) $(libgfortranunit_a_DEPENDENCIES) $(EXTRA_libgfortranunit_a_DEPENDENCIES) 
+	-rm -f libgfortranunit.a
+	$(libgfortranunit_a_AR) libgfortranunit.a $(libgfortranunit_a_OBJECTS) $(libgfortranunit_a_LIBADD)
+	$(RANLIB) libgfortranunit.a
 install-cafexeclibLTLIBRARIES: $(cafexeclib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
 	test -z "$(cafexeclibdir)" || $(MKDIR_P) "$(DESTDIR)$(cafexeclibdir)"
@@ -1579,6 +1614,9 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iso_c_generated_procs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/kill.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortran_c.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortranunit_a-open.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortranunit_a-unit.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortranunit_a-unix.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/link.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/list_read.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock.Plo@am__quote@
@@ -1737,7 +1775,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/norm2_r16.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/norm2_r4.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/norm2_r8.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/open.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c10.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c16.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c4.Plo@am__quote@
@@ -1891,8 +1928,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transpose_r4.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transpose_r8.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/umask.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unit.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unix.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unlink.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_c10.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_c16.Plo@am__quote@
@@ -2354,6 +2389,48 @@ f2c_specifics.lo: intrinsics/f2c_specifics.F90
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
 
+libgfortranunit_a-open.o: io/open.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-open.o -MD -MP -MF $(DEPDIR)/libgfortranunit_a-open.Tpo -c -o libgfortranunit_a-open.o `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-open.Tpo $(DEPDIR)/libgfortranunit_a-open.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/open.c' object='libgfortranunit_a-open.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-open.o `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
+
+libgfortranunit_a-open.obj: io/open.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-open.obj -MD -MP -MF $(DEPDIR)/libgfortranunit_a-open.Tpo -c -o libgfortranunit_a-open.obj `if test -f 'io/open.c'; then $(CYGPATH_W) 'io/open.c'; else $(CYGPATH_W) '$(srcdir)/io/open.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-open.Tpo $(DEPDIR)/libgfortranunit_a-open.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/open.c' object='libgfortranunit_a-open.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-open.obj `if test -f 'io/open.c'; then $(CYGPATH_W) 'io/open.c'; else $(CYGPATH_W) '$(srcdir)/io/open.c'; fi`
+
+libgfortranunit_a-unix.o: io/unix.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unix.o -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unix.Tpo -c -o libgfortranunit_a-unix.o `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unix.Tpo $(DEPDIR)/libgfortranunit_a-unix.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unix.c' object='libgfortranunit_a-unix.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unix.o `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
+
+libgfortranunit_a-unix.obj: io/unix.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unix.obj -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unix.Tpo -c -o libgfortranunit_a-unix.obj `if test -f 'io/unix.c'; then $(CYGPATH_W) 'io/unix.c'; else $(CYGPATH_W) '$(srcdir)/io/unix.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unix.Tpo $(DEPDIR)/libgfortranunit_a-unix.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unix.c' object='libgfortranunit_a-unix.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unix.obj `if test -f 'io/unix.c'; then $(CYGPATH_W) 'io/unix.c'; else $(CYGPATH_W) '$(srcdir)/io/unix.c'; fi`
+
+libgfortranunit_a-unit.o: io/unit.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unit.o -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unit.Tpo -c -o libgfortranunit_a-unit.o `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unit.Tpo $(DEPDIR)/libgfortranunit_a-unit.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unit.c' object='libgfortranunit_a-unit.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unit.o `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
+
+libgfortranunit_a-unit.obj: io/unit.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unit.obj -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unit.Tpo -c -o libgfortranunit_a-unit.obj `if test -f 'io/unit.c'; then $(CYGPATH_W) 'io/unit.c'; else $(CYGPATH_W) '$(srcdir)/io/unit.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unit.Tpo $(DEPDIR)/libgfortranunit_a-unit.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unit.c' object='libgfortranunit_a-unit.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unit.obj `if test -f 'io/unit.c'; then $(CYGPATH_W) 'io/unit.c'; else $(CYGPATH_W) '$(srcdir)/io/unit.c'; fi`
+
 single.lo: caf/single.c
 @am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT single.lo -MD -MP -MF $(DEPDIR)/single.Tpo -c -o single.lo `test -f 'caf/single.c' || echo '$(srcdir)/'`caf/single.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/single.Tpo $(DEPDIR)/single.Plo
@@ -5140,13 +5217,6 @@ lock.lo: io/lock.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o lock.lo `test -f 'io/lock.c' || echo '$(srcdir)/'`io/lock.c
 
-open.lo: io/open.c
-@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT open.lo -MD -MP -MF $(DEPDIR)/open.Tpo -c -o open.lo `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/open.Tpo $(DEPDIR)/open.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/open.c' object='open.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o open.lo `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
-
 read.lo: io/read.c
 @am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT read.lo -MD -MP -MF $(DEPDIR)/read.Tpo -c -o read.lo `test -f 'io/read.c' || echo '$(srcdir)/'`io/read.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/read.Tpo $(DEPDIR)/read.Plo
@@ -5175,20 +5245,6 @@ transfer128.lo: io/transfer128.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o transfer128.lo `test -f 'io/transfer128.c' || echo '$(srcdir)/'`io/transfer128.c
 
-unit.lo: io/unit.c
-@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unit.lo -MD -MP -MF $(DEPDIR)/unit.Tpo -c -o unit.lo `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/unit.Tpo $(DEPDIR)/unit.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unit.c' object='unit.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unit.lo `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
-
-unix.lo: io/unix.c
-@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unix.lo -MD -MP -MF $(DEPDIR)/unix.Tpo -c -o unix.lo `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/unix.Tpo $(DEPDIR)/unix.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unix.c' object='unix.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unix.lo `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
-
 write.lo: io/write.c
 @am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT write.lo -MD -MP -MF $(DEPDIR)/write.Tpo -c -o write.lo `test -f 'io/write.c' || echo '$(srcdir)/'`io/write.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/write.Tpo $(DEPDIR)/write.Plo
@@ -5746,7 +5802,8 @@ distclean-tags:
 check-am: all-am
 check: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) check-am
-all-am: Makefile $(LTLIBRARIES) all-multi $(DATA) config.h
+all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \
+		config.h
 installdirs:
 	for dir in "$(DESTDIR)$(cafexeclibdir)" "$(DESTDIR)$(myexeclibdir)" "$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(toolexeclibdir)"; do \
 	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
@@ -5786,8 +5843,8 @@ maintainer-clean-generic:
 clean: clean-am clean-multi
 
 clean-am: clean-cafexeclibLTLIBRARIES clean-generic clean-libtool \
-	clean-myexeclibLTLIBRARIES clean-toolexeclibLTLIBRARIES \
-	mostlyclean-am
+	clean-myexeclibLTLIBRARIES clean-noinstLIBRARIES \
+	clean-toolexeclibLTLIBRARIES mostlyclean-am
 
 distclean: distclean-am distclean-multi
 	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
@@ -5868,7 +5925,7 @@ uninstall-am: uninstall-cafexeclibLTLIBRARIES \
 
 .PHONY: CTAGS GTAGS all all-am all-multi am--refresh check check-am \
 	clean clean-cafexeclibLTLIBRARIES clean-generic clean-libtool \
-	clean-multi clean-myexeclibLTLIBRARIES \
+	clean-multi clean-myexeclibLTLIBRARIES clean-noinstLIBRARIES \
 	clean-toolexeclibLTLIBRARIES ctags distclean distclean-compile \
 	distclean-generic distclean-hdr distclean-libtool \
 	distclean-multi distclean-tags dvi dvi-am html html-am info \
diff --git a/libgfortran/gfortran.map b/libgfortran/gfortran.map
index 80a9a00..9f726e4 100644
--- a/libgfortran/gfortran.map
+++ b/libgfortran/gfortran.map
@@ -30,6 +30,7 @@ GFORTRAN_1.0 {
     _gfortran_chmod_func;
     _gfortran_chmod_i4_sub;
     _gfortran_chmod_i8_sub;
+    _gfortran_close_units;
     _gfortran_compare_string;
     _gfortran_concat_string;
     _gfortran_count_1_l;
@@ -165,6 +166,7 @@ GFORTRAN_1.0 {
     _gfortran_idate_i8;
     _gfortran_ierrno_i4;
     _gfortran_ierrno_i8;
+    _gfortran_init_units;
     _gfortran_internal_pack;
     _gfortran_internal_unpack;
     _gfortran_irand;
@@ -1027,6 +1029,7 @@ GFORTRAN_1.0 {
     __iso_c_binding_c_f_pointer_l4;
     __iso_c_binding_c_f_pointer_l8;
     __iso_c_binding_c_f_pointer_u0;
+    __extls_get_addr_task;
   local:
     *;
 };
diff --git a/libgfortran/io/unit.c b/libgfortran/io/unit.c
index 3b46bba..c4f52e2 100644
--- a/libgfortran/io/unit.c
+++ b/libgfortran/io/unit.c
@@ -27,6 +27,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include "fbuf.h"
 #include "format.h"
 #include "unix.h"
+#include "libgfortran.h"
 #include <stdlib.h>
 #include <string.h>
 #include <stdbool.h>
@@ -664,6 +665,7 @@ init_units (void)
   for (i = 0; i < sizeof (max_offset) * 8 - 1; i++)
     max_offset = max_offset + ((gfc_offset) 1 << i);
 }
+iexport(init_units);
 
 
 static int
@@ -742,6 +744,7 @@ close_units (void)
     close_unit_1 (unit_root, 1);
   __gthread_mutex_unlock (&unit_lock);
 }
+iexport(close_units);
 
 
 /* High level interface to truncate a file, i.e. flush format buffers,
@@ -862,3 +865,16 @@ get_unique_unit_number (st_parameter_open *opp)
     }
   return num;
 }
+
+/* Just a fake __sctk__tls_get_addr__task_scope to allow MPC to test the compiler during configuration */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+void * __attribute__ ((weak))
+__extls_get_addr_task (tls_index * tmp)
+{
+    return NULL;
+}
diff --git a/libgfortran/libgfortran.h b/libgfortran/libgfortran.h
index 9a713d8..ba3eea7 100644
--- a/libgfortran/libgfortran.h
+++ b/libgfortran/libgfortran.h
@@ -816,10 +816,10 @@ internal_proto(flush_all_units);
 /* io.c */
 
 extern void init_units (void);
-internal_proto(init_units);
+iexport_proto(init_units);
 
 extern void close_units (void);
-internal_proto(close_units);
+iexport_proto(close_units);
 
 extern int unit_to_fd (int);
 internal_proto(unit_to_fd);
diff --git a/libgfortran/runtime/main.c b/libgfortran/runtime/main.c
index 32033ba..4d0d722 100644
--- a/libgfortran/runtime/main.c
+++ b/libgfortran/runtime/main.c
@@ -233,8 +233,9 @@ init (void)
 
   /* Must be first */
   init_variables ();
-
-  init_units ();
+  
+  //Deported to mpc with TLS context
+  //init_units ();
   set_fpu ();
   init_compile_options ();
 
@@ -259,7 +260,8 @@ init (void)
 static void __attribute__((destructor))
 cleanup (void)
 {
-  close_units ();
+  //Deported to mpc with TLS context
+  //close_units ();
   
   if (please_free_exe_path_when_done)
     free ((char *) exe_path);
