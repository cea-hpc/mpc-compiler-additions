diff -Naur gcc-4.8.0/gcc/Makefile.in mpc-gcc-4.8.0/gcc/Makefile.in
--- gcc-4.8.0/gcc/Makefile.in	2013-03-14 10:13:36.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/Makefile.in	2016-04-19 15:29:43.000000000 +0200
@@ -861,7 +861,7 @@
 READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h
 PARAMS_H = params.h params.def
 BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def \
-	gtm-builtins.def sanitizer.def
+	gtm-builtins.def sanitizer.def hls-builtins.def
 INTERNAL_FN_DEF = internal-fn.def
 INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)
 TREE_H = coretypes.h tree.h all-tree.def tree.def c-family/c-common.def \
@@ -1304,6 +1304,7 @@
 	mcf.o \
 	mode-switching.o \
 	modulo-sched.o \
+	mpc-pass.o \
 	omega.o \
 	omp-low.o \
 	optabs.o \
@@ -2536,6 +2537,11 @@
    $(TREE_FLOW_H) $(FLAGS_H) $(EXPR_H) $(DIAGNOSTIC_CORE_H) \
    $(TREE_PASS_H) $(GGC_H) $(EXCEPT_H) $(SPLAY_TREE_H) $(OPTABS_H) \
    $(CFGLOOP_H) tree-iterator.h gt-omp-low.h
+mpc-pass.o : mpc-pass.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) $(GIMPLE_H) $(TREE_INLINE_H) langhooks.h $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TIMEVAR_H) $(FLAGS_H) $(EXPR_H) $(TOPLEV_H) tree-pass.h \
+   $(GGC_H) except.h $(SPLAY_TREE_H) $(OPTABS_H) $(CFGLOOP_H) \
+   tree-iterator.h
 tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \
    coretypes.h $(TREE_H) $(TREE_PRETTY_PRINT_H)
 omega.o : omega.c $(OMEGA_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h \
@@ -3743,6 +3749,7 @@
   $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \
   $(srcdir)/tree-parloops.c \
   $(srcdir)/omp-low.c \
+  $(srcdir)/mpc-pass.c \
   $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \
   $(srcdir)/cgraphclones.c \
   $(srcdir)/tree-ssa-propagate.c \
diff -Naur gcc-4.8.0/gcc/builtin-types.def mpc-gcc-4.8.0/gcc/builtin-types.def
--- gcc-4.8.0/gcc/builtin-types.def	2016-04-19 20:04:51.000000000 +0200
+++ mpc-gcc-4.8.0/gcc/builtin-types.def	2016-04-19 20:54:49.000000000 +0200
@@ -230,9 +230,13 @@
 DEF_FUNCTION_TYPE_1 (BT_FN_UINT16_UINT16, BT_UINT16, BT_UINT16)
 DEF_FUNCTION_TYPE_1 (BT_FN_UINT32_UINT32, BT_UINT32, BT_UINT32)
 DEF_FUNCTION_TYPE_1 (BT_FN_UINT64_UINT64, BT_UINT64, BT_UINT64)
+/* MPC HLS BEGIN */
+DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)
+/* MPC HLS END */
 
 DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)
 
+
 DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_INT, BT_VOID, BT_PTR, BT_INT)
 DEF_FUNCTION_TYPE_2 (BT_FN_STRING_STRING_CONST_STRING,
 		     BT_STRING, BT_STRING, BT_CONST_STRING)
diff -Naur gcc-4.8.0/gcc/builtins.def mpc-gcc-4.8.0/gcc/builtins.def
--- gcc-4.8.0/gcc/builtins.def	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/builtins.def	2016-04-19 15:47:39.000000000 +0200
@@ -831,6 +831,16 @@
 /* OpenMP builtins.  */
 #include "omp-builtins.def"
 
+#define DEF_MPC_BUILTIN(ENUM, NAME, TYPE, ATTRS) \
+  DEF_BUILTIN (ENUM, "__builtin_" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \
+               false, true, true, ATTRS, false, \
+             (flag_openmp || flag_tree_parallelize_loops))
+
+
+/* MPC HLS BEGIN */
+#include "hls-builtins.def"
+/* MPC HLS END */
+
 /* GTM builtins. */
 #include "gtm-builtins.def"
 
diff -Naur gcc-4.8.0/gcc/c/c-decl.c mpc-gcc-4.8.0/gcc/c/c-decl.c
--- gcc-4.8.0/gcc/c/c-decl.c	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/c/c-decl.c	2016-04-19 15:29:43.000000000 +0200
@@ -1962,13 +1962,24 @@
     {
       /* Only variables can be thread-local, and all declarations must
 	 agree on this property.  */
-      if (C_DECL_THREADPRIVATE_P (olddecl) && !DECL_THREAD_LOCAL_P (newdecl))
+     /* MPC HLS BEGIN */
+#if 0
+    if (C_DECL_THREADPRIVATE_P (olddecl) && !DECL_THREAD_LOCAL_P (newdecl))
+#endif
+	  /* newdecl can be modified by mpc-privatize */
+    if (C_DECL_THREADPRIVATE_P (olddecl))
 	{
 	  /* Nothing to check.  Since OLDDECL is marked threadprivate
 	     and NEWDECL does not have a thread-local attribute, we
 	     will merge the threadprivate attribute into NEWDECL.  */
 	  ;
 	}
+	else if (DECL_TLS_MODEL(olddecl) >= TLS_MODEL_HLS_NODE)
+	{
+	  /* same as above but for HLS variables */
+	  ;
+	}
+      /* MPC HLS END */
       else if (DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl))
 	{
 	  if (DECL_THREAD_LOCAL_P (newdecl))
@@ -2260,6 +2271,14 @@
       C_DECL_THREADPRIVATE_P (newdecl) = 1;
     }
 
+	/* MPC HLS BEGIN */
+  /* merge the HLS attribute */
+  if (TREE_CODE (olddecl) == VAR_DECL && DECL_TLS_MODEL (olddecl) >= TLS_MODEL_HLS_NODE )
+    {
+      DECL_TLS_MODEL (newdecl) = DECL_TLS_MODEL (olddecl);
+    }
+/* MPC HLS END */
+	
   if (CODE_CONTAINS_STRUCT (TREE_CODE (olddecl), TS_DECL_WITH_VIS))
     {
       /* Merge the section attribute.
@@ -4162,6 +4181,44 @@
     record_inline_static (input_location, current_function_decl,
 			  decl, csi_modifiable);
 
+/* MPC TLS BEGIN */
+#if 1
+  if ( flag_mpi_privatize && 
+      TREE_CODE(decl) == VAR_DECL && 
+      ( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) && 
+      !DECL_IN_SYSTEM_HEADER(decl) && 
+      !TREE_READONLY( decl ) && 
+      !DECL_THREAD_LOCAL_P(decl) &&
+	  strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&
+	  strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0
+      ) {
+    fprintf( stderr, 
+	"(Front-end C) Automatic privatization to TLS (variable %s in file %s line %d)\n",
+	lang_hooks.decl_printable_name (decl,2), 
+	DECL_SOURCE_FILE(decl),
+	DECL_SOURCE_LINE(decl) ) ;
+    DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
+  }
+  if ( flag_mpc_privatize && 
+      TREE_CODE(decl) == VAR_DECL && 
+      ( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) && 
+      !DECL_IN_SYSTEM_HEADER(decl) && 
+      !TREE_READONLY( decl ) && 
+      !DECL_THREAD_LOCAL_P(decl)  &&
+	  strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&
+	  strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0
+      ) {
+    fprintf( stderr, 
+	"(Front-end C) Automatic privatization to MPC task (variable %s in file %s line %d)\n",
+	lang_hooks.decl_printable_name (decl,2), 
+	DECL_SOURCE_FILE(decl),
+	DECL_SOURCE_LINE(decl) ) ;
+    DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_TASK ;
+  }
+#endif
+/* MPC TLS END */
+
+
   if (c_dialect_objc () 
       && (TREE_CODE (decl) == VAR_DECL
           || TREE_CODE (decl) == FUNCTION_DECL))
diff -Naur gcc-4.8.0/gcc/c/c-parser.c mpc-gcc-4.8.0/gcc/c/c-parser.c
--- gcc-4.8.0/gcc/c/c-parser.c	2013-02-12 21:07:04.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/c/c-parser.c	2016-04-20 09:42:51.000000000 +0200
@@ -1186,6 +1186,12 @@
 static void c_parser_omp_taskwait (c_parser *);
 static void c_parser_omp_taskyield (c_parser *);
 
+/* MPC HLS BEGIN */
+static void c_parser_hls_scope(c_parser *);
+static void c_parser_hls_single(c_parser *);
+static void c_parser_hls_barrier(c_parser *);
+/* MPC HLS END */
+
 enum pragma_context { pragma_external, pragma_stmt, pragma_compound };
 static bool c_parser_pragma (c_parser *, enum pragma_context);
 
@@ -8608,7 +8614,33 @@
       c_parser_error (parser, "%<#pragma GCC pch_preprocess%> must be first");
       c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);
       return false;
+	
+	/* MPC HLS BEGIN */
+
+    case PRAGMA_HLS_NODE:
+    case PRAGMA_HLS_NUMA:
+    case PRAGMA_HLS_SOCKET:
+    case PRAGMA_HLS_CACHE:
+   case PRAGMA_HLS_CORE:
+      c_parser_hls_scope (parser);
+      return false ;
+
+    case PRAGMA_HLS_SINGLE:
+      c_parser_hls_single (parser);
+      return false ;
+
+    case PRAGMA_HLS_BARRIER:
+      if (context != pragma_compound)
+	{
+	  if (context == pragma_stmt)
+	    c_parser_error (parser, "%<#pragma hls barrier%> may only be "
+			    "used in compound statements");
+	  goto bad_stmt;
+	}
+      c_parser_hls_barrier (parser);
+      return false ;
 
+      /* MPC HLS END */
     default:
       if (id < PRAGMA_FIRST_EXTERNAL)
 	{
@@ -10626,9 +10658,17 @@
 	error_at (loc, "%<threadprivate%> %qE has incomplete type", v);
       else
 	{
+#if 1 /* MPC OMP C THREADPRIVATE */ 
+		/* Even if this variable is already a TLS, it should be at the
+	     * lowest level (OpenMP in MPC) */
+      if (DECL_TLS_MODEL (v) != TLS_MODEL_MPC_OPENMP)
+        {
+          DECL_TLS_MODEL (v) = TLS_MODEL_MPC_OPENMP;
+#else /* MPC OMP C THREADPRIVATE */ 
 	  if (! DECL_THREAD_LOCAL_P (v))
 	    {
 	      DECL_TLS_MODEL (v) = decl_default_tls_model (v);
+#endif /* MPC OMP C THREADPRIVATE */ 
 	      /* If rtl has been already set for this var, call
 		 make_decl_rtl once again, so that encode_section_info
 		 has a chance to look at the new decl flags.  */
@@ -10854,6 +10894,241 @@
   return build1 (NOP_EXPR, void_type_node, error_mark_node);
 }
 
+
+
+/* MPC HLS BEGIN */
+
+static void c_parser_hls_scope(c_parser *parser) 
+{
+  tree vars, t;
+  enum pragma_kind p_kind;
+  char hls_string[32];
+  enum tls_model tls_type = TLS_MODEL_NONE;
+  int hls_level = 0 ;
+  location_t loc ;
+
+  p_kind = c_parser_peek_token (parser)->pragma_kind;
+  loc = c_parser_peek_token (parser)->location;
+  c_parser_consume_pragma (parser);
+ 
+  /* get variables */
+  vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);
+  
+  /* check if there is a level clause */
+  if ( c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL) ) {
+	  if ( c_parser_next_token_is (parser, CPP_NAME) ) {
+		  const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);
+		  if (strcmp ("level", p) == 0) {
+			  tree t ;
+			  c_parser_consume_token (parser);
+			  c_parser_require (parser, CPP_OPEN_PAREN, "expected %<(%>");
+			  t = c_parser_expr_no_commas (parser, NULL).value;
+			  if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE) {
+				  hls_level = tree_low_cst(t,0);
+			  }else{
+				  c_parser_error (parser, "expected integer expression");
+			  }
+			  if ( hls_level <= 0 ) {
+				  c_parser_error (parser, "HLS: level should be strictly positive");
+				  hls_level = 0 ;
+			  }
+			  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, "expected %<)%>");
+		  }else {
+			  c_parser_error (parser, "HLS: expected %<level%> clause or empty");
+		  }
+	  }else{
+		  c_parser_error (parser, "HLS: expected %<level%> clause or empty");
+	  }
+  }
+  c_parser_skip_to_pragma_eol (parser);
+
+  /* set hls scope and level */
+  switch (p_kind)
+  {
+	  case PRAGMA_HLS_NODE:
+		  tls_type = TLS_MODEL_HLS_NODE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope node") ;
+		  sprintf ( hls_string, "node" );
+		  break;
+	  case PRAGMA_HLS_NUMA:
+		  if ( hls_level > 2 ) {
+			  warning_at (loc, 0, "HLS: max level is 2 for scope numa");
+			  hls_level = 2 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_1 ;
+		  sprintf ( hls_string, "numa level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_SOCKET:
+		  tls_type = TLS_MODEL_HLS_SOCKET ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "socket" );
+		  break;
+	  case PRAGMA_HLS_CACHE:
+		  if ( hls_level > 4 ) {
+			  warning_at (loc, 0, "HLS: max level is 3 for scope cache");
+			  hls_level = 3 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 3 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_3 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_1 ;
+		  sprintf ( hls_string, "cache level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_CORE:
+		  tls_type = TLS_MODEL_HLS_CORE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "core" );
+		  break;
+	  default:
+		  gcc_unreachable ();
+  }
+
+  /* Mark every variable in VARS to be assigned HLS
+     with the corresponding level.  */
+  for (t = vars; t; t = TREE_CHAIN (t))
+  {
+	  tree v = TREE_PURPOSE (t);
+
+	  if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+	  else if (! TREE_STATIC (v) && ! DECL_EXTERNAL (v))
+		  error ("automatic variable %qE cannot be %<HLS-%s%>", v, hls_string);
+	  else if (! COMPLETE_TYPE_P (TREE_TYPE (v))) 
+		  error ("variable %<HLS-%s%> %qE has incomplete type", hls_string, v);
+	  else if (TREE_USED (v) && DECL_TLS_MODEL(v) != tls_type)
+		  error ("%qE declared %<HLS-%s%> after first use", v, hls_string);
+	  else 
+	  {
+		  DECL_TLS_MODEL (v) = tls_type;
+		  if ( flag_mpc_hls_verbose ) {
+			  fprintf( stderr , "HLS: Privatization to scope %s of variable %s (file %s line %d)\n", 
+					  hls_string, IDENTIFIER_POINTER( DECL_NAME(v) ), DECL_SOURCE_FILE(v), DECL_SOURCE_LINE(v) ) ;
+		  } 
+	  }
+  }
+}
+
+static void c_parser_hls_barrier(c_parser *parser) 
+{
+  tree vars, t, x, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, larger_tls_type = TLS_MODEL_HLS_CORE;
+  
+  loc = c_parser_peek_token (parser)->location;
+  c_parser_consume_pragma (parser);
+
+  /* get the larger tls type */
+  vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+
+      if (TREE_CODE (v) != VAR_DECL)
+        error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+        error ("%qD is not declared HLS", v);
+      else if ( tls_type < larger_tls_type )
+        larger_tls_type = tls_type ;
+    } 
+
+  c_parser_skip_to_pragma_eol (parser);
+  
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE ) ;
+  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_BARRIER);
+  x = build_call_expr (x, 1, arg);
+  add_stmt (x);
+  SET_EXPR_LOCATION (x, loc);
+}
+
+
+static void c_parser_hls_single(c_parser *parser) 
+{
+  tree vars, t, x, cond, then_block, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, previous_tls_type = TLS_MODEL_NONE;
+  char clause_nowait = 0 ;
+
+  loc = c_parser_peek_token (parser)->location;
+  c_parser_consume_pragma (parser);
+
+  /* check all vars have the same HLS scope
+	 and store this scope in tls_model */
+  vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+      if ( t == vars )
+        previous_tls_type = tls_type ;
+
+      if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+		  error ("%qD is not declared HLS", v);
+      else if ( tls_type != previous_tls_type )
+		  error ("%qD has incorrect HLS scope", v);
+    } 
+
+  /* get nowait clause */
+  if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL)) {
+	  if (c_parser_next_token_is (parser, CPP_NAME)) {
+		  const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);
+		  if (!strcmp ("nowait", p)) {
+			  clause_nowait = 1 ;
+			  c_parser_consume_token (parser);
+		  }else
+			  c_parser_error (parser, "HLS: expected %<nowait%> clause or empty");
+	  }else{
+		  c_parser_error (parser, "HLS: expected %<nowait%> clause or empty");
+	  }
+  }
+	  
+  c_parser_skip_to_pragma_eol (parser);
+  
+  
+  /* get single body */
+  then_block = push_stmt_list ();
+  c_parser_statement (parser);
+  if ( !clause_nowait ) {
+	  /* in case of blocking single, add a call at the end of the
+	     then block to exit the barrier entered when evaluating
+	     the condition of the if */
+	  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE );
+	  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_SINGLE_DONE);
+	  x = build_call_expr (x, 1, arg);
+	  SET_EXPR_LOCATION (x, loc);
+	  add_stmt (x) ;
+  }
+  then_block = pop_stmt_list (then_block);
+  
+  /* build call to hls_single */
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE );
+  cond = builtin_decl_explicit(clause_nowait ? BUILT_IN_MPC_HLS_SINGLE_NOWAIT : BUILT_IN_MPC_HLS_SINGLE);
+  cond = build_call_expr (cond, 1, arg);
+  SET_EXPR_LOCATION (cond, loc);
+  
+  /* add the if statement */
+  /* if ( hls_single() ) then { block in single ; hls_single_end() ; } */
+  x = build3 (COND_EXPR, void_type_node, cond, then_block, NULL);
+  SET_EXPR_LOCATION (x, loc);
+  add_stmt (x);
+}
+
+/* MPC HLS END */
+
 /* Parse a single source file.  */
 
 void
diff -Naur gcc-4.8.0/gcc/c/c-typeck.c mpc-gcc-4.8.0/gcc/c/c-typeck.c
--- gcc-4.8.0/gcc/c/c-typeck.c	2013-01-24 17:59:44.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/c/c-typeck.c	2016-04-19 15:29:43.000000000 +0200
@@ -10770,7 +10770,12 @@
 	    {
 	      const char *share_name = NULL;
 
+	      /* MPC BEGIN */
+		  #if 0
 	      if (TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))
+	      #endif
+	      if (TREE_CODE (t) == VAR_DECL && DECL_MPC_THREAD_LOCAL_P (t))
+	      /* MPC END */
 		share_name = "threadprivate";
 	      else switch (c_omp_predetermined_sharing (t))
 		{
diff -Naur gcc-4.8.0/gcc/c-family/c-pragma.c mpc-gcc-4.8.0/gcc/c-family/c-pragma.c
--- gcc-4.8.0/gcc/c-family/c-pragma.c	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/c-family/c-pragma.c	2016-04-19 15:29:43.000000000 +0200
@@ -1344,6 +1344,30 @@
 				      omp_pragmas[i].id, true, true);
     }
 
+  /* MPC HLS BEGIN */
+  if (flag_mpc_hls && !flag_preprocess_only)
+    {
+      struct mpc_hls_pragma_def { const char *name; unsigned int id; };
+      static const struct mpc_hls_pragma_def mpc_hls_pragmas[] = {
+	{ "node",    PRAGMA_HLS_NODE },
+	{ "numa",    PRAGMA_HLS_NUMA },
+	{ "socket",  PRAGMA_HLS_SOCKET },
+	{ "cache",   PRAGMA_HLS_CACHE },
+	{ "core",    PRAGMA_HLS_CORE },
+	{ "single",  PRAGMA_HLS_SINGLE },
+	{ "barrier", PRAGMA_HLS_BARRIER },
+      } ;
+
+      const int n_mpc_hls_pragmas = sizeof (mpc_hls_pragmas) / 
+	sizeof (*mpc_hls_pragmas);
+      int i;
+
+      for (i = 0; i < n_mpc_hls_pragmas; ++i)
+	cpp_register_deferred_pragma (parse_in, "hls", mpc_hls_pragmas[i].name,
+				      mpc_hls_pragmas[i].id, true, true);
+    }
+  /* MPC HLS END */
+  
   if (!flag_preprocess_only)
     cpp_register_deferred_pragma (parse_in, "GCC", "pch_preprocess",
 				  PRAGMA_GCC_PCH_PREPROCESS, false, false);
diff -Naur gcc-4.8.0/gcc/c-family/c-pragma.h mpc-gcc-4.8.0/gcc/c-family/c-pragma.h
--- gcc-4.8.0/gcc/c-family/c-pragma.h	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/c-family/c-pragma.h	2016-04-19 15:29:43.000000000 +0200
@@ -44,7 +44,15 @@
   PRAGMA_OMP_TASKWAIT,
   PRAGMA_OMP_TASKYIELD,
   PRAGMA_OMP_THREADPRIVATE,
-
+  /* MPC HLS BEGIN */
+  PRAGMA_HLS_NODE,
+  PRAGMA_HLS_NUMA,
+  PRAGMA_HLS_SOCKET,
+  PRAGMA_HLS_CACHE,
+  PRAGMA_HLS_CORE,
+  PRAGMA_HLS_SINGLE,
+  PRAGMA_HLS_BARRIER,
+  /* MPC HLS END */
   PRAGMA_GCC_PCH_PREPROCESS,
 
   PRAGMA_FIRST_EXTERNAL
diff -Naur gcc-4.8.0/gcc/c-family/c.opt mpc-gcc-4.8.0/gcc/c-family/c.opt
--- gcc-4.8.0/gcc/c-family/c.opt	2013-01-19 06:25:25.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/c-family/c.opt	2016-04-19 15:29:43.000000000 +0200
@@ -490,6 +490,12 @@
 C ObjC C++ ObjC++ Var(warn_missing_declarations) Warning
 Warn about global functions without previous declarations
 
+; MPC HLS BEGIN 
+Wmpc
+C C++ Var(warn_mpc) Warning LangEnabledBy(C C++, Wall)
+Warn about MPC-related and thread-safety issues
+; MPC HLS END
+
 Wmissing-field-initializers
 C ObjC C++ ObjC++ Var(warn_missing_field_initializers) Warning EnabledBy(Wextra)
 Warn about missing fields in struct initializers
@@ -984,6 +990,27 @@
 C ObjC C++ ObjC++ Var(flag_lax_vector_conversions)
 Allow implicit conversions between vectors with differing numbers of subparts and/or differing element types.
 
+; MPC TLS BEGIN 
+fmpc-privatize
+C C++ Var(flag_mpc_privatize)
+Privatize every global variable to make MPI codes MPC compliant.
+
+fmpi-privatize
+C C++ Var(flag_mpi_privatize)
+Privatize every global variable to make MPI codes MPC compliant using standard TLS mechanism.
+; MPC TLS END 
+
+; MPC HLS BEGIN
+fhls
+C C++ Var(flag_mpc_hls)
+Enable Hierarchical Local Storage (HLS) directives
+
+fhls-verbose
+C C++ Var(flag_mpc_hls_verbose)
+Enable verbose output for Hierarchical Local Storage (HLS) directives
+; MPC HLS END
+
+
 fms-extensions
 C ObjC C++ ObjC++ Var(flag_ms_extensions)
 Don't warn about uses of Microsoft extensions
diff -Naur gcc-4.8.0/gcc/common.opt mpc-gcc-4.8.0/gcc/common.opt
--- gcc-4.8.0/gcc/common.opt	2013-03-14 10:13:36.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/common.opt	2016-04-20 10:20:28.000000000 +0200
@@ -2255,6 +2255,12 @@
 Common Report Var(flag_verbose_asm)
 Add extra commentary to assembler output
 
+; MPC OMP VERBOSE FLAGS BEGIN
+fopenmp-verbose
+Common Report Var(flag_openmp_verbose)
+Add extra information about the OpenMP transformation
+; MPC OMP VERBOSE FLAGS END 
+
 fvisibility=
 Common Joined RejectNegative Enum(symbol_visibility) Var(default_visibility) Init(VISIBILITY_DEFAULT)
 -fvisibility=[default|internal|hidden|protected]	Set the default symbol visibility
diff -Naur gcc-4.8.0/gcc/config/i386/i386-protos.h mpc-gcc-4.8.0/gcc/config/i386/i386-protos.h
--- gcc-4.8.0/gcc/config/i386/i386-protos.h	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/config/i386/i386-protos.h	2016-04-19 15:29:43.000000000 +0200
@@ -223,6 +223,22 @@
 
 extern rtx ix86_tls_module_base (void);
 
+/* MPC TLS BEGIN */
+extern rtx ix86_tls_get_addr__openmp_scope (void);
+extern rtx ix86_tls_get_addr__task_scope (void);
+/* MPC TLS END */
+
+/* MPC HLS BEGIN */
+extern rtx ix86_tls_get_addr__node_scope (void);
+extern rtx ix86_tls_get_addr__numa_level_2_scope (void);
+extern rtx ix86_tls_get_addr__numa_level_1_scope (void);
+extern rtx ix86_tls_get_addr__socket_scope (void);
+extern rtx ix86_tls_get_addr__cache_level_3_scope (void);
+extern rtx ix86_tls_get_addr__cache_level_2_scope (void);
+extern rtx ix86_tls_get_addr__cache_level_1_scope (void);
+extern rtx ix86_tls_get_addr__core_scope (void);
+/* MPC HLS END */
+
 extern void ix86_expand_vector_init (bool, rtx, rtx);
 extern void ix86_expand_vector_set (bool, rtx, rtx, int);
 extern void ix86_expand_vector_extract (bool, rtx, rtx, int);
diff -Naur gcc-4.8.0/gcc/config/i386/i386.c mpc-gcc-4.8.0/gcc/config/i386/i386.c
--- gcc-4.8.0/gcc/config/i386/i386.c	2013-02-21 11:57:10.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/config/i386/i386.c	2016-04-19 15:29:43.000000000 +0200
@@ -12741,7 +12741,11 @@
 static rtx
 ix86_tls_get_addr (void)
 {
-  if (!ix86_tls_symbol)
+  /* MPC TLS BEGIN */
+#if 0
+  if (!ix86_tls_symbol) 
+#endif
+  /* MPC TLS END */
     {
       const char *sym
 	= ((TARGET_ANY_GNU_TLS && !TARGET_64BIT)
@@ -12753,6 +12757,158 @@
   return ix86_tls_symbol;
 }
 
+/* MPC TLS BEGIN */
+rtx
+ix86_tls_get_addr__openmp_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__sctk__tls_get_addr__openmp_scope"
+					    : "__sctk__tls_get_addr__openmp_scope");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__task_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__sctk__tls_get_addr__task_scope"
+					    : "__sctk__tls_get_addr__task_scope");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__node_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__sctk__tls_get_addr__node_scope"
+					    : "__sctk__tls_get_addr__node_scope");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__numa_level_2_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__sctk__tls_get_addr__numa_level_2_scope"
+					    : "__sctk__tls_get_addr__numa_level_2_scope");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__numa_level_1_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__sctk__tls_get_addr__numa_level_1_scope"
+					    : "__sctk__tls_get_addr__numa_level_1_scope");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__socket_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__sctk__tls_get_addr__socket_scope"
+					    : "__sctk__tls_get_addr__socket_scope");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__cache_level_3_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__sctk__tls_get_addr__cache_level_3_scope"
+					    : "__sctk__tls_get_addr__cache_level_3_scope");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__cache_level_2_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__sctk__tls_get_addr__cache_level_2_scope"
+					    : "__sctk__tls_get_addr__cache_level_2_scope");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__cache_level_1_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__sctk__tls_get_addr__cache_level_1_scope"
+					    : "__sctk__tls_get_addr__cache_level_1_scope");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__core_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__sctk__tls_get_addr__core_scope"
+					    : "__sctk__tls_get_addr__core_scope");
+    }
+
+  return ix86_tls_symbol;
+}
+  /* MPC TLS END */
+  
 /* Construct the SYMBOL_REF for the _TLS_MODULE_BASE_ symbol.  */
 
 static GTY(()) rtx ix86_tls_module_base_symbol;
@@ -12783,9 +12939,142 @@
   rtx pic = NULL_RTX, tp = NULL_RTX;
   enum machine_mode tp_mode = Pmode;
   int type;
-
+/* MPC HLS BEGIN */
+  rtx (*gen_tls_hls_scope_32)(rtx,rtx) = NULL;
+  rtx (*gen_tls_hls_scope_64)(rtx,rtx) = NULL;
   switch (model)
     {
+    case TLS_MODEL_HLS_NODE:
+	  gen_tls_hls_scope_64 = &gen_tls_hls_node_64 ;
+	  gen_tls_hls_scope_32 = &gen_tls_hls_node_32 ;
+	  break;
+    case TLS_MODEL_HLS_NUMA_LEVEL_2:
+	  gen_tls_hls_scope_64 = &gen_tls_hls_numa_level_2_64 ;
+	  gen_tls_hls_scope_32 = &gen_tls_hls_numa_level_2_32 ;
+	  break;
+    case TLS_MODEL_HLS_NUMA_LEVEL_1:
+	  gen_tls_hls_scope_64 = &gen_tls_hls_numa_level_1_64 ;
+	  gen_tls_hls_scope_32 = &gen_tls_hls_numa_level_1_32 ;
+	  break;
+    case TLS_MODEL_HLS_SOCKET:
+	  gen_tls_hls_scope_64 = &gen_tls_hls_socket_64 ;
+	  gen_tls_hls_scope_32 = &gen_tls_hls_socket_32 ;
+	  break;
+    case TLS_MODEL_HLS_CACHE_LEVEL_3:
+	  gen_tls_hls_scope_64 = &gen_tls_hls_cache_level_3_64 ;
+	  gen_tls_hls_scope_32 = &gen_tls_hls_cache_level_3_32 ;
+	  break;
+    case TLS_MODEL_HLS_CACHE_LEVEL_2:
+	  gen_tls_hls_scope_64 = &gen_tls_hls_cache_level_2_64 ;
+	  gen_tls_hls_scope_32 = &gen_tls_hls_cache_level_2_32 ;
+	  break;
+    case TLS_MODEL_HLS_CACHE_LEVEL_1:
+	  gen_tls_hls_scope_64 = &gen_tls_hls_cache_level_1_64 ;
+	  gen_tls_hls_scope_32 = &gen_tls_hls_cache_level_1_32 ;
+	  break;
+    case TLS_MODEL_HLS_CORE:
+	  gen_tls_hls_scope_64 = &gen_tls_hls_core_64 ;
+	  gen_tls_hls_scope_32 = &gen_tls_hls_core_32 ;
+	  break;
+	default:
+	  ;
+	}
+/* MPC HLS END */
+  switch (model)
+    {
+			/* MPC TLS BEGIN */
+    case TLS_MODEL_MPC_TASK:
+      dest = gen_reg_rtx (Pmode);
+      tp = TARGET_GNU2_TLS ? get_thread_pointer (Pmode, true) : 0;
+
+      if (TARGET_64BIT && ! TARGET_GNU2_TLS)
+	{
+	  rtx rax = gen_rtx_REG (Pmode, AX_REG), insns;
+
+	  start_sequence ();
+	  emit_call_insn (gen_tls_mpc_task_64 (rax, x));
+	  insns = get_insns ();
+	  end_sequence ();
+
+	  RTL_CONST_CALL_P (insns) = 1;
+	  emit_libcall_block (insns, dest, rax, x);
+	}
+      else if (TARGET_64BIT && TARGET_GNU2_TLS)
+	emit_insn (gen_tls_mpc_task_64 (dest, x));
+      else
+	emit_insn (gen_tls_mpc_task_32 (dest, x));
+
+      if (TARGET_GNU2_TLS)
+	{
+	  dest = force_reg (Pmode, gen_rtx_PLUS (Pmode, tp, dest));
+
+	  set_unique_reg_note (get_last_insn (), REG_EQUIV, x);
+	}
+      break;
+    case TLS_MODEL_MPC_OPENMP:
+      dest = gen_reg_rtx (Pmode);
+      tp = TARGET_GNU2_TLS ? get_thread_pointer (Pmode, true) : 0;
+
+      if (TARGET_64BIT && ! TARGET_GNU2_TLS)
+	{
+	  rtx rax = gen_rtx_REG (Pmode, AX_REG), insns;
+
+	  start_sequence ();
+	  emit_call_insn (gen_tls_mpc_openmp_64 (rax, x));
+	  insns = get_insns ();
+	  end_sequence ();
+
+	  RTL_CONST_CALL_P (insns) = 1;
+	  emit_libcall_block (insns, dest, rax, x);
+	}
+      else if (TARGET_64BIT && TARGET_GNU2_TLS)
+	emit_insn (gen_tls_mpc_openmp_64 (dest, x));
+      else
+	emit_insn (gen_tls_mpc_openmp_32 (dest, x));
+
+      if (TARGET_GNU2_TLS)
+	{
+	  dest = force_reg (Pmode, gen_rtx_PLUS (Pmode, tp, dest));
+
+	  set_unique_reg_note (get_last_insn (), REG_EQUIV, x);
+	}
+      break;
+    case TLS_MODEL_HLS_NODE:
+    case TLS_MODEL_HLS_NUMA_LEVEL_2:
+    case TLS_MODEL_HLS_NUMA_LEVEL_1:
+    case TLS_MODEL_HLS_SOCKET:
+    case TLS_MODEL_HLS_CACHE_LEVEL_3:
+    case TLS_MODEL_HLS_CACHE_LEVEL_2:
+    case TLS_MODEL_HLS_CACHE_LEVEL_1:
+    case TLS_MODEL_HLS_CORE:
+      dest = gen_reg_rtx (Pmode);
+      tp = TARGET_GNU2_TLS ? get_thread_pointer (Pmode, true) : 0;
+
+      if (TARGET_64BIT && ! TARGET_GNU2_TLS)
+	{
+	  rtx rax = gen_rtx_REG (Pmode, AX_REG), insns;
+
+	  start_sequence ();
+	  emit_call_insn (gen_tls_hls_scope_64 (rax, x));
+	  insns = get_insns ();
+	  end_sequence ();
+
+	  RTL_CONST_CALL_P (insns) = 1;
+	  emit_libcall_block (insns, dest, rax, x);
+	}
+      else if (TARGET_64BIT && TARGET_GNU2_TLS)
+	emit_insn (gen_tls_hls_scope_64 (dest, x));
+      else
+	emit_insn (gen_tls_hls_scope_32 (dest, x));
+
+      if (TARGET_GNU2_TLS)
+	{
+	  dest = force_reg (Pmode, gen_rtx_PLUS (Pmode, tp, dest));
+
+	  set_unique_reg_note (get_last_insn (), REG_EQUIV, x);
+	}
+      break;
+      /* MPC TLS END */
     case TLS_MODEL_GLOBAL_DYNAMIC:
       dest = gen_reg_rtx (Pmode);
 
diff -Naur gcc-4.8.0/gcc/config/i386/i386.md mpc-gcc-4.8.0/gcc/config/i386/i386.md
--- gcc-4.8.0/gcc/config/i386/i386.md	2013-01-28 21:42:55.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/config/i386/i386.md	2016-04-19 15:29:43.000000000 +0200
@@ -12658,6 +12658,288 @@
      (clobber (match_scratch:SI 5))
      (clobber (reg:CC FLAGS_REG))])])
 
+;; MPC TLS BEGIN
+(define_expand "tls_mpc_openmp_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__openmp_scope();
+})
+
+(define_expand "tls_mpc_task_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__task_scope();
+})
+
+(define_expand "tls_hls_node_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__node_scope();
+})
+
+(define_expand "tls_hls_numa_level_2_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__numa_level_2_scope();
+})
+
+(define_expand "tls_hls_numa_level_1_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__numa_level_1_scope();
+})
+
+(define_expand "tls_hls_socket_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__socket_scope();
+})
+
+(define_expand "tls_hls_cache_level_3_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__cache_level_3_scope();
+})
+
+(define_expand "tls_hls_cache_level_2_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__cache_level_2_scope();
+})
+
+(define_expand "tls_hls_cache_level_1_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__cache_level_1_scope();
+})
+
+(define_expand "tls_hls_core_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__core_scope();
+})
+;; MPC TLS END
+
 (define_insn "*tls_global_dynamic_64_<mode>"
   [(set (match_operand:P 0 "register_operand" "=a")
 	(call:P
@@ -12691,6 +12973,160 @@
 	       UNSPEC_TLS_GD)])]
   "TARGET_64BIT")
 
+
+;; MPC TLS BEGIN
+(define_expand "tls_mpc_openmp_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__openmp_scope ();
+})
+(define_expand "tls_mpc_task_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__task_scope ();
+})
+(define_expand "tls_hls_node_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__node_scope ();
+})
+(define_expand "tls_hls_numa_level_2_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__numa_level_2_scope ();
+})
+(define_expand "tls_hls_numa_level_1_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__numa_level_1_scope ();
+})
+(define_expand "tls_hls_socket_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__socket_scope ();
+})
+(define_expand "tls_hls_cache_level_3_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__cache_level_3_scope ();
+})
+(define_expand "tls_hls_cache_level_2_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__cache_level_2_scope ();
+})
+(define_expand "tls_hls_cache_level_1_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__cache_level_1_scope ();
+})
+(define_expand "tls_hls_core_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__core_scope ();
+})
+;; MPC TLS END
+
 (define_insn "*tls_local_dynamic_base_32_gnu"
   [(set (match_operand:SI 0 "register_operand" "=a")
 	(unspec:SI
diff -Naur gcc-4.8.0/gcc/coretypes.h mpc-gcc-4.8.0/gcc/coretypes.h
--- gcc-4.8.0/gcc/coretypes.h	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/coretypes.h	2016-04-19 15:29:43.000000000 +0200
@@ -107,7 +107,21 @@
   TLS_MODEL_GLOBAL_DYNAMIC = TLS_MODEL_REAL,
   TLS_MODEL_LOCAL_DYNAMIC,
   TLS_MODEL_INITIAL_EXEC,
-  TLS_MODEL_LOCAL_EXEC
+  TLS_MODEL_LOCAL_EXEC,
+  /* MPC TLS BEGIN */
+  TLS_MODEL_MPC_OPENMP,
+  TLS_MODEL_MPC_TASK,
+  /* MPC TLS END */
+  /* MPC HLS BEGIN */
+  TLS_MODEL_HLS_NODE,
+  TLS_MODEL_HLS_NUMA_LEVEL_2,
+  TLS_MODEL_HLS_NUMA_LEVEL_1,
+  TLS_MODEL_HLS_SOCKET,
+  TLS_MODEL_HLS_CACHE_LEVEL_3,
+  TLS_MODEL_HLS_CACHE_LEVEL_2,
+  TLS_MODEL_HLS_CACHE_LEVEL_1,
+  TLS_MODEL_HLS_CORE
+  /* MPC HLS END */
 };
 
 /* Types of unwind/exception handling info that can be generated.  */
diff -Naur gcc-4.8.0/gcc/cp/cp-tree.h mpc-gcc-4.8.0/gcc/cp/cp-tree.h
--- gcc-4.8.0/gcc/cp/cp-tree.h	2013-03-08 17:03:48.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/cp/cp-tree.h	2016-04-19 15:29:43.000000000 +0200
@@ -5727,6 +5727,10 @@
 extern void maybe_add_lambda_conv_op            (tree);
 extern bool is_lambda_ignored_entity            (tree);
 
+/* MPC HLS BEGIN */
+extern void finish_hls_scope			(tree vars);
+/* MPC HLS END */
+
 /* in tree.c */
 extern int cp_tree_operand_length		(const_tree);
 void cp_free_lang_data 				(tree t);
diff -Naur gcc-4.8.0/gcc/cp/decl.c mpc-gcc-4.8.0/gcc/cp/decl.c
--- gcc-4.8.0/gcc/cp/decl.c	2013-03-14 14:09:11.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/cp/decl.c	2016-04-19 15:29:43.000000000 +0200
@@ -1887,6 +1887,17 @@
 	      DECL_TLS_MODEL (newdecl) = DECL_TLS_MODEL (olddecl);
 	      CP_DECL_THREADPRIVATE_P (newdecl) = 1;
 	    }
+	    /* MPC HLS BEGIN */
+	  if (DECL_LANG_SPECIFIC (olddecl)
+	      && DECL_TLS_MODEL (olddecl) >= TLS_MODEL_HLS_NODE )
+	    {
+	      /* Allocate a LANG_SPECIFIC structure for NEWDECL, if needed.  */
+	      if (!DECL_LANG_SPECIFIC (newdecl))
+		retrofit_lang_decl (newdecl);
+
+	      DECL_TLS_MODEL (newdecl) = DECL_TLS_MODEL (olddecl);
+	    }
+           /* MPC HLS END */
 	}
 
       /* Do this after calling `merge_types' so that default
@@ -2544,7 +2555,12 @@
 	   && DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl)
 	   && (! DECL_LANG_SPECIFIC (olddecl)
 	       || ! CP_DECL_THREADPRIVATE_P (olddecl)
+	       || DECL_THREAD_LOCAL_P (newdecl))
+	       /* MPC HLS BEGIN */
+	   && (! DECL_LANG_SPECIFIC (olddecl)
+	       || ! DECL_TLS_MODEL (olddecl) >= TLS_MODEL_HLS_NODE 
 	       || DECL_THREAD_LOCAL_P (newdecl)))
+/* MPC HLS END */
     {
       /* Only variables can be thread-local, and all declarations must
 	 agree on this property.  */
@@ -4432,6 +4448,7 @@
 	    tree prefix_attributes,
 	    tree *pushed_scope_p)
 {
+  
   tree decl;
   tree context;
   bool was_public;
@@ -4449,7 +4466,7 @@
 
   decl = grokdeclarator (declarator, declspecs, NORMAL, initialized,
 			 &attributes);
-
+			 
   deprecated_state = DEPRECATED_NORMAL;
 
   if (decl == NULL_TREE || TREE_CODE (decl) == VOID_TYPE
@@ -4528,6 +4545,43 @@
       && lookup_attribute ("noinline", DECL_ATTRIBUTES (decl)))
     warning (0, "inline function %q+D given attribute noinline", decl);
 
+/* MPC TLS BEGIN */
+  if ( flag_mpi_privatize &&
+	TREE_CODE(decl) == VAR_DECL &&
+	( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) &&
+	!DECL_IN_SYSTEM_HEADER(decl) &&
+	!TREE_READONLY( decl ) &&
+	!DECL_THREAD_LOCAL_P(decl) &&
+    strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&
+	strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0
+  ) {
+    fprintf( stderr,
+      "(Front-end C++) Automatic privatization to TLS "
+      "(variable %s in file %s line %d)\n",
+      lang_decl_name( decl, 2 , 0),
+      DECL_SOURCE_FILE(decl),
+      DECL_SOURCE_LINE(decl) ) ;
+    DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
+  }
+  if ( flag_mpc_privatize &&
+	TREE_CODE(decl) == VAR_DECL &&
+	( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) &&
+	!DECL_IN_SYSTEM_HEADER(decl) &&
+	!TREE_READONLY( decl ) &&
+	!DECL_THREAD_LOCAL_P(decl) &&
+    strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&
+	strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0
+  ) {
+		fprintf( stderr,
+		  "(Front-end C++) Automatic privatization to MPC task "
+		  "(variable %s in file %s line %d)\n",
+		  lang_decl_name( decl, 2 , 0),
+		  DECL_SOURCE_FILE(decl),
+		  DECL_SOURCE_LINE(decl) ) ;
+		DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_TASK ;
+  }
+  /* MPC TLS END */
+  
   if (TYPE_P (context) && COMPLETE_TYPE_P (complete_type (context)))
     {
       if (TREE_CODE (decl) == VAR_DECL)
@@ -6499,6 +6553,42 @@
     TREE_READONLY (decl) = 1;
 
   invoke_plugin_callbacks (PLUGIN_FINISH_DECL, decl);
+  
+  /* MPC TLS BEGIN */
+#if 0
+    if ( flag_mpc_privatize &&
+	TREE_CODE(decl) == VAR_DECL &&
+	( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) &&
+	!DECL_IN_SYSTEM_HEADER(decl) &&
+	!TREE_READONLY( decl ) &&
+	!DECL_THREAD_LOCAL_P(decl)
+       ) {
+      fprintf( stderr,
+	  "(Front-end C++ (in finish decl)) Automatic privatization to MPC task "
+	  "(variable %s in file %s line %d)\n",
+	  lang_decl_name( decl, 2, 0),
+	  /* lang_hooks.decl_printable_name (decl,2), */
+	  DECL_SOURCE_FILE(decl),
+	  DECL_SOURCE_LINE(decl) ) ;
+      DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_TASK ;
+    }
+    /*
+    fprintf( stderr,
+	"Info: variable %s in file %s line %d) "
+	"TC:%d, TS:%d, DE:%d, DS:%d, DR:%d, DT:%d\n",
+	lang_decl_name( decl, 2 ),
+	DECL_SOURCE_FILE(decl),
+	DECL_SOURCE_LINE(decl),
+	TREE_CODE(decl) == VAR_DECL,
+	TREE_STATIC( decl ),
+	DECL_EXTERNAL(decl),
+	DECL_IN_SYSTEM_HEADER(decl),
+	TREE_READONLY( decl ),
+	DECL_THREAD_LOCAL_P(decl)
+	) ;
+	*/
+#endif
+    /* MPC TLS END */
 }
 
 /* Returns a declaration for a VAR_DECL as if:
@@ -6871,6 +6961,7 @@
 static void
 expand_static_init (tree decl, tree init)
 {
+	
   gcc_assert (TREE_CODE (decl) == VAR_DECL);
   gcc_assert (TREE_STATIC (decl));
 
@@ -7028,9 +7119,23 @@
 	}
     }
   else if (DECL_THREAD_LOCAL_P (decl))
+  {
+	  switch(DECL_TLS_MODEL(decl))
+	  {
+		  case TLS_MODEL_MPC_OPENMP:
+		  fprintf(stderr,"TLS MPC OPENMP %s\n", IDENTIFIER_POINTER(DECL_NAME(decl)));
+		  break;
+		  case TLS_MODEL_MPC_TASK:
+		  fprintf(stderr,"TLS MPC TASK %s\n", IDENTIFIER_POINTER(DECL_NAME(decl)));
+		  break;
+		  default:
+		  break;
+	  }
     tls_aggregates = tree_cons (init, decl, tls_aggregates);
+   }
   else
     static_aggregates = tree_cons (init, decl, static_aggregates);
+    
 }
 
 
@@ -13678,7 +13783,7 @@
   tree fndecl = current_function_decl;
   tree fntype, ctype = NULL_TREE;
   int inclass_inline = (flags & 2) != 0;
-
+  
   /* When we get some parse errors, we can end up without a
      current_function_decl, so cope.  */
   if (fndecl == NULL_TREE)
diff -Naur gcc-4.8.0/gcc/cp/decl2.c mpc-gcc-4.8.0/gcc/cp/decl2.c
--- gcc-4.8.0/gcc/cp/decl2.c	2013-02-16 02:07:11.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/cp/decl2.c	2016-04-19 15:29:43.000000000 +0200
@@ -954,7 +954,40 @@
 	    }
 	}
     }
-
+    
+/* MPC TLS BEGIN */
+  if ( flag_mpi_privatize &&
+	TREE_CODE(value) == VAR_DECL &&
+	( TREE_STATIC( value ) || DECL_EXTERNAL(value) ) &&
+	!DECL_IN_SYSTEM_HEADER(value) &&
+	!TREE_READONLY( value ) &&
+	!DECL_THREAD_LOCAL_P(value)
+  ) {
+    fprintf( stderr,
+      "(Front-end C++) Automatic privatization to TLS "
+      "(variable %s in file %s line %d)\n",
+      lang_decl_name( value, 2 , 0),
+      DECL_SOURCE_FILE(value),
+      DECL_SOURCE_LINE(value) ) ;
+      DECL_TLS_MODEL (value) = decl_default_tls_model (value);
+  }
+  if ( flag_mpc_privatize &&
+	TREE_CODE(value) == VAR_DECL &&
+	( TREE_STATIC( value ) || DECL_EXTERNAL(value) ) &&
+	!DECL_IN_SYSTEM_HEADER(value) &&
+	!TREE_READONLY( value ) &&
+	!DECL_THREAD_LOCAL_P(value)
+  ) {
+		fprintf( stderr,
+		  "(Front-end C++) Automatic privatization to MPC task "
+		  "(variable %s in file %s line %d)\n",
+		  lang_decl_name( value, 2 , 0),
+		  DECL_SOURCE_FILE(value),
+		  DECL_SOURCE_LINE(value) ) ;
+		DECL_TLS_MODEL(value) = TLS_MODEL_MPC_TASK ;
+  }
+  /* MPC TLS END */
+  
   if (processing_template_decl
       && (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == FUNCTION_DECL))
     {
@@ -3511,10 +3544,10 @@
       tree t = *var;
       tree decl = TREE_VALUE (t);
       tree init = TREE_PURPOSE (t);
-
       /* Deal gracefully with error.  */
       if (decl == error_mark_node)
 	{
+		fprintf(stderr,"error_mark_node\n");
 	  var = &TREE_CHAIN (t);
 	  continue;
 	}
@@ -3526,6 +3559,7 @@
 	 here.  */
       if (DECL_EXTERNAL (decl))
 	{
+		fprintf(stderr,"object not defined\n");
 	  var = &TREE_CHAIN (t);
 	  continue;
 	}
@@ -3535,6 +3569,7 @@
       if (init && TREE_CODE (init) == TREE_LIST
 	  && value_member (error_mark_node, init))
 	{
+		fprintf(stderr,"bail out now\n");
 	  var = &TREE_CHAIN (t);
 	  continue;
 	}
@@ -3894,9 +3929,9 @@
 handle_tls_init (void)
 {
   tree vars = prune_vars_needing_no_initialization (&tls_aggregates);
-  if (vars == NULL_TREE)
+  if (vars == NULL_TREE) 
     return;
-
+    
   location_t loc = DECL_SOURCE_LOCATION (TREE_VALUE (vars));
 
   write_out_vars (vars);
@@ -3908,7 +3943,12 @@
   DECL_ARTIFICIAL (guard) = true;
   DECL_IGNORED_P (guard) = true;
   TREE_USED (guard) = true;
+  /* MPC BEGIN */
+  #if 0
   DECL_TLS_MODEL (guard) = decl_default_tls_model (guard);
+  #endif
+  DECL_TLS_MODEL (guard) = TLS_MODEL_MPC_TASK;
+  /* MPC END */
   pushdecl_top_level_and_finish (guard, NULL_TREE);
 
   tree fn = get_local_tls_init_fn ();
diff -Naur gcc-4.8.0/gcc/cp/parser.c mpc-gcc-4.8.0/gcc/cp/parser.c
--- gcc-4.8.0/gcc/cp/parser.c	2013-03-07 00:47:20.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/cp/parser.c	2016-04-19 15:29:43.000000000 +0200
@@ -22786,7 +22786,6 @@
 			     cp_decl_spec ds, cp_token *token)
 {
   gcc_assert (ds < ds_last);
-
   if (decl_specs == NULL)
     return;
 
@@ -22796,7 +22795,7 @@
     {
       decl_specs->locations[ds] = location;
       if (ds == ds_thread)
-	decl_specs->gnu_thread_keyword_p = token_is__thread (token);
+		decl_specs->gnu_thread_keyword_p = token_is__thread (token);
     }
   else
     {
@@ -27680,6 +27679,267 @@
     SET_EXPR_LOCATION (stmt, pragma_tok->location);
 }
 
+
+
+/* MPC HLS BEGIN */
+static void
+cp_parser_hls_scope(cp_parser *parser, cp_token *pragma_tok)
+{
+  tree vars,t;
+  char hls_string[32];
+  enum tls_model tls_type;
+  const unsigned int id = pragma_tok->pragma_kind;
+  const location_t loc = pragma_tok->location;
+  int hls_level = 0 ;
+
+  /* get variables */
+  vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);
+
+  /* check if there is a level clause */
+  if ( cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL) ) {
+	  if ( cp_lexer_next_token_is (parser->lexer, CPP_NAME) ) {
+		  tree id = cp_lexer_peek_token (parser->lexer)->u.value;
+		  const char *p = IDENTIFIER_POINTER (id);
+		  if (strcmp ("level", p) == 0) {
+			  tree t;
+			  cp_lexer_consume_token (parser->lexer);
+			  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);
+			  t = cp_parser_constant_expression (parser, false, NULL);
+			  t = fold_non_dependent_expr (t);
+			  if (INTEGRAL_TYPE_P (TREE_TYPE (t))) {
+				  hls_level = tree_low_cst(t,0);
+				  if ( hls_level <= 0 ) {
+					  cp_parser_error (parser, "HLS: level should be strictly positive");
+					  hls_level = 0 ;
+					  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+				  }else{
+					  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);
+				  }
+			  }else{
+				  cp_parser_error (parser,"HLS: level argument needs positive constant integer expression");
+				  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+			  }
+		  }else{
+			  cp_parser_error (parser, "HLS: expected %<level%> clause or empty");
+			  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+		  }
+	  }else{
+		  cp_parser_error (parser, "HLS: expected %<level%> clause or empty");
+		  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+	  }
+  }
+
+  cp_parser_require_pragma_eol (parser, pragma_tok);
+
+  switch (id)
+  {
+	  case PRAGMA_HLS_NODE:
+		  tls_type = TLS_MODEL_HLS_NODE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope node") ;
+		  sprintf ( hls_string, "node" );
+		  break;
+	  case PRAGMA_HLS_NUMA:
+		  if ( hls_level > 2 ) {
+			  warning_at (loc, 0, "HLS: max level is 2 for scope numa");
+			  hls_level = 2 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_1 ;
+		  sprintf ( hls_string, "numa level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_SOCKET:
+		  tls_type = TLS_MODEL_HLS_SOCKET ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "socket" );
+		  break;
+	  case PRAGMA_HLS_CACHE:
+		  if ( hls_level > 4 ) {
+			  warning_at (loc, 0, "HLS: max level is 3 for scope cache");
+			  hls_level = 3 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 3 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_3 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_1 ;
+		  sprintf ( hls_string, "cache level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_CORE:
+		  tls_type = TLS_MODEL_HLS_CORE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "core" );
+		  break;
+	  default:
+		  gcc_unreachable ();
+  }
+
+  /* Mark every variable in VARS to be assigned HLS
+	 with the corresponding level.  */
+  for (t = vars; t; t = TREE_CHAIN (t))
+  {
+	  tree v = TREE_PURPOSE (t);
+
+	  if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+      else if (! TREE_STATIC (v) && ! DECL_EXTERNAL (v))
+		  error ("automatic variable %qE cannot be %<HLS-%s%>", v, hls_string);
+      else if (! COMPLETE_TYPE_P (TREE_TYPE (v))) 
+		  error ("variable %<HLS-%s%> %qE has incomplete type", hls_string, v);
+      else if (TREE_USED (v) && DECL_TLS_MODEL(v) != tls_type ) 
+		  error ("%qE declared %<HLS-%s%> after first use", v, hls_string);
+      else if (TREE_STATIC (v) && TYPE_P (CP_DECL_CONTEXT (v))
+	       && CP_DECL_CONTEXT (v) != current_class_type)
+		  error ("%<HLS-%s%> %qE directive not "
+	       "in %qT definition", hls_string, v, CP_DECL_CONTEXT (v));
+      else 
+	  {
+		  /* Allocate a LANG_SPECIFIC structure for V, if needed.  */
+		  if (DECL_LANG_SPECIFIC (v) == NULL)
+		  {
+			  retrofit_lang_decl (v);
+
+			  /* Make sure that DECL_DISCRIMINATOR_P continues to be true
+				 after the allocation of the lang_decl structure.  */
+			  if (DECL_DISCRIMINATOR_P (v))
+				  DECL_LANG_SPECIFIC (v)->u.base.u2sel = 1;
+		  }
+		  DECL_TLS_MODEL (v) = tls_type ;
+		  {
+			  /* If rtl has been already set for this var, call
+				 make_decl_rtl once again, so that encode_section_info
+				 has a chance to look at the new decl flags.  */
+			  if (DECL_RTL_SET_P (v))
+				  make_decl_rtl (v);
+		  }
+		  if ( flag_mpc_hls_verbose ) {
+			  fprintf( stderr , "HLS: Privatization to %s scope of variable %s (file %s line %d)\n",
+					  hls_string, IDENTIFIER_POINTER( DECL_NAME(v) ),
+					  DECL_SOURCE_FILE(v), DECL_SOURCE_LINE(v) ) ;
+		  } 
+	  }
+	}
+}
+
+static void
+cp_parser_hls_barrier(cp_parser *parser, cp_token *pragma_tok)
+{
+  tree vars, t, x, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, larger_tls_type = TLS_MODEL_NONE;
+
+  larger_tls_type = TLS_MODEL_HLS_CORE ;
+  
+  loc = pragma_tok->location;
+
+  /* get the larger tls type */
+  vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+
+      if (TREE_CODE (v) != VAR_DECL)
+        error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+        error ("%qD is not declared HLS", v);
+      else if ( tls_type < larger_tls_type )
+        larger_tls_type = tls_type ;
+    } 
+
+  cp_parser_require_pragma_eol (parser, pragma_tok);
+  
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE ) ;
+  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_BARRIER);
+  x = build_call_expr (x, 1, arg);
+  add_stmt (x);
+  SET_EXPR_LOCATION (x, loc);
+}
+
+static void
+cp_parser_hls_single(cp_parser *parser, cp_token *pragma_tok) {
+  tree vars, t, x, cond, then_block, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, previous_tls_type = TLS_MODEL_NONE;
+  char clause_nowait = 0 ;
+
+  loc = pragma_tok->location;
+
+  /* check all vars have the same HLS scope
+	 and store this scope in tls_model */
+  vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+      if ( t == vars )
+        previous_tls_type = tls_type ;
+
+      if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+		  error ("%qD is not declared HLS", v);
+      else if ( tls_type != previous_tls_type )
+		  error ("%qD has incorrect HLS scope", v);
+    } 
+
+  /* get nowait clause */
+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)) {
+	  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)) {
+		  tree id = cp_lexer_peek_token (parser->lexer)->u.value;
+		  const char *p = IDENTIFIER_POINTER (id);
+		  if (!strcmp ("nowait", p)) {
+			  clause_nowait = 1 ;
+			  cp_lexer_consume_token (parser->lexer);
+		  }else{
+			  cp_parser_error (parser, "expected %<nowait%> clause or empty");
+			  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+		  }
+	  }else{
+		  cp_parser_error (parser, "expected %<nowait%> clause or empty");
+		  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+	  }
+  }
+	  
+  cp_parser_require_pragma_eol (parser, pragma_tok);
+
+  /* get single body */
+  then_block = push_stmt_list ();
+  cp_parser_statement (parser, NULL_TREE, false, NULL);
+  if ( !clause_nowait ) {
+	  /* in case of blocking single, add a call at the end of the
+	     then block to exit the barrier entered when evaluating
+	     the condition of the if */
+	  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE );
+	  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_SINGLE_DONE);
+	  x = build_call_expr (x, 1, arg);
+	  SET_EXPR_LOCATION (x, loc);
+	  add_stmt (x) ;
+  }
+  then_block = pop_stmt_list (then_block);
+  
+  /* add the if statement */
+  /* if ( hls_single() ) then { then_block ; hls_single_done(); } */
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE ) ;
+  cond = builtin_decl_explicit(clause_nowait ? BUILT_IN_MPC_HLS_SINGLE_NOWAIT : BUILT_IN_MPC_HLS_SINGLE);
+  cond = build_call_expr (cond, 1, arg);
+  SET_EXPR_LOCATION (cond, loc);
+  x = build3 (COND_EXPR, void_type_node, cond, then_block, NULL);
+  SET_EXPR_LOCATION (x, loc);
+  add_stmt (x);
+}
+
+/* MPC HLS END */
+
 /* Transactional Memory parsing routines.  */
 
 /* Parse a transaction attribute.
@@ -28121,7 +28381,25 @@
 		"%<#pragma omp section%> may only be used in "
 		"%<#pragma omp sections%> construct");
       break;
+	/* MPC HLS BEGIN */
+
+    case PRAGMA_HLS_NODE:
+    case PRAGMA_HLS_NUMA:
+    case PRAGMA_HLS_SOCKET:
+    case PRAGMA_HLS_CACHE:
+    case PRAGMA_HLS_CORE:
+      cp_parser_hls_scope (parser, pragma_tok);
+      return false ;
+
+    case PRAGMA_HLS_BARRIER:
+      cp_parser_hls_barrier (parser, pragma_tok);
+      return false ;
+
+    case PRAGMA_HLS_SINGLE:
+      cp_parser_hls_single (parser, pragma_tok);
+      return false ;
 
+      /* MPC HLS END */
     default:
       gcc_assert (id >= PRAGMA_FIRST_EXTERNAL);
       c_invoke_pragma_handler (id);
diff -Naur gcc-4.8.0/gcc/cp/semantics.c mpc-gcc-4.8.0/gcc/cp/semantics.c
--- gcc-4.8.0/gcc/cp/semantics.c	2016-04-20 08:54:38.000000000 +0200
+++ mpc-gcc-4.8.0/gcc/cp/semantics.c	2016-04-20 09:44:00.000000000 +0200
@@ -4416,9 +4416,17 @@
 		DECL_LANG_SPECIFIC (v)->u.base.u2sel = 1;
 	    }
 
+#if 1 /* MPC OMP C++ THREADPRIVATE */ 
+		/* Even if this variable is already a TLS, it should be at the
+	     * lowest level (OpenMP in MPC) */
+      if (DECL_TLS_MODEL (v) != TLS_MODEL_MPC_OPENMP)
+        {
+          DECL_TLS_MODEL (v) = TLS_MODEL_MPC_OPENMP;
+#else /* MPC OMP C++ THREADPRIVATE */ 
 	  if (! DECL_THREAD_LOCAL_P (v))
 	    {
 	      DECL_TLS_MODEL (v) = decl_default_tls_model (v);
+#endif /* MPC OMP C++ THREADPRIVATE */
 	      /* If rtl has been already set for this var, call
 		 make_decl_rtl once again, so that encode_section_info
 		 has a chance to look at the new decl flags.  */
diff -Naur gcc-4.8.0/gcc/fortran/Make-lang.in mpc-gcc-4.8.0/gcc/fortran/Make-lang.in
--- gcc-4.8.0/gcc/fortran/Make-lang.in	2013-03-03 18:16:42.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/Make-lang.in	2016-04-19 15:29:43.000000000 +0200
@@ -58,7 +58,7 @@
     fortran/iresolve.o fortran/match.o fortran/matchexp.o fortran/misc.o \
     fortran/module.o fortran/openmp.o fortran/options.o fortran/parse.o \
     fortran/primary.o fortran/resolve.o fortran/scanner.o fortran/simplify.o \
-    fortran/st.o fortran/symbol.o fortran/target-memory.o
+    fortran/st.o fortran/symbol.o fortran/target-memory.o fortran/hls.o
 
 F95_OBJS = $(F95_PARSER_OBJS) $(FORTRAN_TARGET_OBJS) \
     fortran/convert.o fortran/dependency.o fortran/f95-lang.o \
diff -Naur gcc-4.8.0/gcc/fortran/f95-lang.c mpc-gcc-4.8.0/gcc/fortran/f95-lang.c
--- gcc-4.8.0/gcc/fortran/f95-lang.c	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/f95-lang.c	2016-04-19 15:29:43.000000000 +0200
@@ -1019,12 +1019,25 @@
 #include "../sync-builtins.def"
 #undef DEF_SYNC_BUILTIN
 
+/* MPC HLS BEGIN */
+  if (gfc_option.flag_hls)
+  {
+#undef DEF_MPC_BUILTIN
+#define DEF_MPC_BUILTIN(code, name, type, attr) \
+	  gfc_define_builtin ("__builtin_" name, builtin_types[type], \
+			  code, name, attr == ATTR_CONST_NOTHROW_LIST);
+#include "../hls-builtins.def"
+#undef DEF_MPC_BUILTIN
+  }
+  /* MPC HLS END */
+  
   if (gfc_option.gfc_flag_openmp || flag_tree_parallelize_loops)
     {
 #undef DEF_GOMP_BUILTIN
 #define DEF_GOMP_BUILTIN(code, name, type, attr) \
       gfc_define_builtin ("__builtin_" name, builtin_types[type], \
 			  code, name, attr);
+			  
 #include "../omp-builtins.def"
 #undef DEF_GOMP_BUILTIN
     }
diff -Naur gcc-4.8.0/gcc/fortran/gfortran.h mpc-gcc-4.8.0/gcc/fortran/gfortran.h
--- gcc-4.8.0/gcc/fortran/gfortran.h	2013-03-03 18:34:42.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/gfortran.h	2016-04-19 15:29:43.000000000 +0200
@@ -219,6 +219,12 @@
   ST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,
   ST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION, ST_OMP_SINGLE,
   ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE, ST_OMP_TASK, ST_OMP_END_TASK,
+  /* MPC HLS BEGIN */
+  ST_HLS_SCOPE,
+  ST_HLS_SINGLE,
+  ST_HLS_END_SINGLE,
+  ST_HLS_BARRIER,
+  /* MPC HLS END */
   ST_OMP_TASKWAIT, ST_OMP_TASKYIELD, ST_PROCEDURE, ST_GENERIC, ST_CRITICAL,
   ST_END_CRITICAL, ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_NONE
 }
@@ -585,6 +591,14 @@
 }
 init_local_integer;
 
+/* MPC HLS BEGIN */
+typedef enum gfc_hls_scope
+{
+	HLS_SCOPE_NONE, HLS_SCOPE_NODE, HLS_SCOPE_NUMA,
+	HLS_SCOPE_SOCKET, HLS_SCOPE_CACHE, HLS_SCOPE_CORE
+} gfc_hls_scope ;
+/* MPC HLS END */
+
 typedef enum
 {
   GFC_FCOARRAY_NONE = 0,
@@ -704,6 +718,11 @@
     implied_index:1, subref_array_pointer:1, proc_pointer:1, asynchronous:1,
     contiguous:1;
 
+ /* MPC HLS BEGIN */
+  ENUM_BITFIELD (gfc_hls_scope) hls_scope:3;
+  unsigned hls_level:2;
+  /* MPC HLS END */
+  
   /* For CLASS containers, the pointer attribute is sometimes set internally
      even though it was not directly specified.  In this case, keep the
      "real" (original) value here.  */
@@ -1290,6 +1309,10 @@
 {
   locus where;
   char use_assoc, saved, threadprivate;
+  /* MPC HLS BEGIN */
+  gfc_hls_scope hls_scope;
+  unsigned int hls_level;
+  /* MPC HLS END */
   char name[GFC_MAX_SYMBOL_LEN + 1];
   struct gfc_symbol *head;
   const char* binding_label;
@@ -2108,7 +2131,11 @@
   EXEC_OMP_SECTIONS, EXEC_OMP_SINGLE, EXEC_OMP_WORKSHARE,
   EXEC_OMP_ATOMIC, EXEC_OMP_BARRIER, EXEC_OMP_END_NOWAIT,
   EXEC_OMP_END_SINGLE, EXEC_OMP_TASK, EXEC_OMP_TASKWAIT,
-  EXEC_OMP_TASKYIELD
+  EXEC_OMP_TASKYIELD,
+  /* MPC HLS BEGIN */
+  EXEC_HLS_BARRIER, EXEC_HLS_SINGLE, EXEC_HLS_SINGLE_NOWAIT,
+  EXEC_HLS_END_SINGLE
+  /* MPC HLS END */
 }
 gfc_exec_op;
 
@@ -2172,6 +2199,13 @@
     gfc_namelist *omp_namelist;
     bool omp_bool;
     gfc_omp_atomic_op omp_atomic;
+     /* MPC HLS BEGIN */
+	struct 
+	{
+		gfc_hls_scope scope;
+		unsigned int level;
+	} hls ;
+	/* MPC HLS END */
   }
   ext;		/* Points to additional structures required by statement */
 
@@ -2306,7 +2340,14 @@
   int fpe;
   int rtcheck;
   gfc_fcoarray coarray;
-
+  /* MPC GLOBAL BEGIN */
+  //~ int warn_mpc;
+  //~ int flag_mpc_privatize;
+  /* MPC GLOBAL END */
+  /* MPC HLS BEGIN */
+  int flag_hls;
+  int flag_hls_verbose;
+  /* MPC HLS END */
   int warn_std;
   int allow_std;
   int convert;
@@ -2570,6 +2611,11 @@
 gfc_try gfc_add_result (symbol_attribute *, const char *, locus *);
 gfc_try gfc_add_save (symbol_attribute *, save_state, const char *, locus *);
 gfc_try gfc_add_threadprivate (symbol_attribute *, const char *, locus *);
+
+/* MPC HLS BEGIN */
+gfc_try gfc_add_hls_scope (symbol_attribute *, const char *, locus *, gfc_hls_scope, unsigned int);
+/* MPC HLS END */
+
 gfc_try gfc_add_saved_common (symbol_attribute *, locus *);
 gfc_try gfc_add_target (symbol_attribute *, locus *);
 gfc_try gfc_add_dummy (symbol_attribute *, const char *, locus *);
diff -Naur gcc-4.8.0/gcc/fortran/hls.c mpc-gcc-4.8.0/gcc/fortran/hls.c
--- gcc-4.8.0/gcc/fortran/hls.c	1970-01-01 01:00:00.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/hls.c	2016-04-19 15:29:43.000000000 +0200
@@ -0,0 +1,440 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "flags.h"
+#include "gfortran.h"
+#include "match.h"
+#include "parse.h"
+#include "pointer-set.h"
+#include "target.h"
+#include "toplev.h"
+#include "tree.h"
+#include "trans.h"
+#include "trans-stmt.h"
+
+
+static match gfc_match_hls_eos (void)
+{
+  locus old_loc;
+  char c;
+
+  old_loc = gfc_current_locus;
+  gfc_gobble_whitespace ();
+
+  c = gfc_next_ascii_char ();
+  switch (c)
+    {
+    case '!':
+      do
+	c = gfc_next_ascii_char ();
+      while (c != '\n');
+      /* Fall through */
+
+    case '\n':
+      return MATCH_YES;
+    }
+
+  gfc_current_locus = old_loc;
+  return MATCH_NO;
+}
+
+static match gfc_match_hls_scope (gfc_hls_scope scope)
+{
+  char n[GFC_MAX_SYMBOL_LEN+1];
+  gfc_symbol *sym;
+  match m;
+  gfc_symtree *st;
+  gfc_expr *expr_level;
+  int level = 1;
+  locus old_loc = gfc_current_locus; 
+  locus loc_var_list, loc_after_level ;
+  int level_clause_found = 0 ;
+  
+  m = gfc_match (" (");
+  if (m != MATCH_YES)
+    return m;
+
+  loc_var_list = gfc_current_locus;
+
+  /* skip variables */
+  while (1) {
+	  if ( gfc_match_symbol (&sym, 0) != MATCH_YES
+		&& ( gfc_match (" / %n /", n) != MATCH_YES || n[0] == '\0' ) )
+		  goto syntax ;
+	  m = gfc_match_char (',') ;
+	  if ( m == MATCH_ERROR )
+		  goto syntax; 
+	  if ( m == MATCH_YES ) {
+		  continue;
+	  }
+	  m = gfc_match_char (')') ;
+	  if ( m == MATCH_ERROR )
+		  goto syntax; 
+	  if ( m == MATCH_YES ) {
+		  break;
+	  }
+  }
+
+  m = gfc_match (" level ( %e ) ", &expr_level);
+  if ( m == MATCH_ERROR )
+	  goto syntax;
+  if ( m == MATCH_YES ) {
+	  level_clause_found = 1 ;
+	  /* level clause present */
+	  gfc_extract_int(expr_level, &level);
+	  if ( level <= 0 ) {
+		  gfc_error("HLS: level should contain a positive integer at %C");
+		  goto cleanup;
+	  }
+	  gfc_free_expr(expr_level);
+	  switch (scope){
+		  case HLS_SCOPE_NONE:
+			  gfc_error("HLS: scope cannot be none at %C");
+			  goto cleanup;
+		  case HLS_SCOPE_NODE:
+		  case HLS_SCOPE_SOCKET:
+		  case HLS_SCOPE_CORE:
+			  gfc_error("HLS: level clause not valid for scopes node, socket and core at %C");
+			  goto cleanup;
+		  case HLS_SCOPE_NUMA:
+			  if ( level > 2 ) {
+				  gfc_error("HLS: level is at most 2 for scope NUMA at %C");
+				  goto cleanup;
+			  }
+			  break;
+		  case HLS_SCOPE_CACHE:
+			  if ( level > 3 ) {
+				  gfc_error("HLS: level is at most 3 for scope CACHE at %C");
+				  goto cleanup;
+			  }
+			  break ;
+	  }
+	  loc_after_level = gfc_current_locus ;
+  }
+  
+  /* go back to variables list */
+  gfc_current_locus = loc_var_list ;
+   
+  for (;;)
+    {
+      m = gfc_match_symbol (&sym, 0);
+      switch (m)
+	{
+	case MATCH_YES:
+	  if (sym->attr.in_common)
+	    gfc_error_now ("HLS variable at %C is an element of "
+			   "a COMMON block");
+	  else if (gfc_add_hls_scope (&sym->attr, sym->name,
+		   &sym->declared_at, scope, level) == FAILURE)
+	    goto cleanup;
+	  goto next_item;
+	case MATCH_NO:
+	  break;
+	case MATCH_ERROR:
+	  goto cleanup;
+	}
+
+      m = gfc_match (" / %n /", n);
+      if (m == MATCH_ERROR)
+	goto cleanup;
+      if (m == MATCH_NO || n[0] == '\0')
+	goto syntax;
+
+      st = gfc_find_symtree (gfc_current_ns->common_root, n);
+      if (st == NULL)
+	{
+	  gfc_error ("COMMON block /%s/ not found at %C", n);
+	  goto cleanup;
+	}
+      st->n.common->hls_scope = scope;
+      for (sym = st->n.common->head; sym; sym = sym->common_next)
+	if (gfc_add_hls_scope (&sym->attr, sym->name,
+				   &sym->declared_at, scope, level) == FAILURE)
+	  goto cleanup;
+
+    next_item:
+      if (gfc_match_char (')') == MATCH_YES)
+	break;
+      if (gfc_match_char (',') != MATCH_YES)
+	goto syntax;
+    }
+
+  /* skip level clause if found */
+  if ( level_clause_found == 1 ) 
+	  gfc_current_locus = loc_after_level ;
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in !$HLS list at %C");
+
+cleanup:
+  gfc_current_locus = old_loc;
+  return MATCH_ERROR;
+}
+
+match gfc_match_hls_node (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_NODE ) ;
+}
+
+match gfc_match_hls_numa (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_NUMA ) ;
+}
+
+match gfc_match_hls_socket (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_SOCKET ) ;
+}
+
+match gfc_match_hls_cache (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_CACHE ) ;
+}
+
+match gfc_match_hls_core (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_CORE ) ;
+}
+
+match gfc_match_hls_single (void)
+{
+  locus old_loc;
+  bool nowait ;
+  char n[GFC_MAX_SYMBOL_LEN+1];
+  gfc_symbol *sym;
+  match m;
+  gfc_symtree *st;
+  gfc_hls_scope scope = HLS_SCOPE_NONE ;
+  unsigned int level = 1;
+
+  old_loc = gfc_current_locus;
+
+  m = gfc_match (" (");
+  if (m != MATCH_YES)
+	  return m;
+
+  for (;;)
+  {
+	  m = gfc_match_symbol (&sym, 0);
+	  switch (m)
+	  {
+		  case MATCH_YES:
+			  if ( sym->attr.hls_scope == HLS_SCOPE_NONE )
+				  gfc_error_now ("variable at %C has not been declared HLS");
+			  else if ( scope != HLS_SCOPE_NONE )
+			  {
+				  if ( sym->attr.hls_scope != scope || sym->attr.hls_level != level )
+					  gfc_error_now ("variable at %C has incorrect HLS scope");
+			  }else{
+				  scope = sym->attr.hls_scope ;
+				  level = sym->attr.hls_level ;
+			  }
+			  goto next_item;
+		  case MATCH_NO:
+			  break;
+		  case MATCH_ERROR:
+			  goto cleanup;
+	  }
+
+	  m = gfc_match (" / %n /", n);
+	  if (m == MATCH_ERROR)
+		  goto cleanup;
+	  if (m == MATCH_NO || n[0] == '\0')
+		  goto syntax;
+
+	  st = gfc_find_symtree (gfc_current_ns->common_root, n);
+	  if (st == NULL)
+	  {
+		  gfc_error ("COMMON block /%s/ not found at %C", n);
+		  goto cleanup;
+	  }
+	  if ( st->n.common->hls_scope == HLS_SCOPE_NONE )
+	  {
+		  gfc_error_now ("variable at %C has not been declared HLS");
+		  goto next_item;
+	  }else if ( scope != HLS_SCOPE_NONE )
+	  {
+		  if ( st->n.common->hls_scope != scope || st->n.common->hls_level != level )
+			  gfc_error_now ("variable at %C has incorrect HLS scope");
+	  }else{
+		  scope = st->n.common->hls_scope ;
+		  level = st->n.common->hls_level ;
+	  }
+
+next_item:
+	  if (gfc_match_char (')') == MATCH_YES)
+		  break;
+	  if (gfc_match_char (',') != MATCH_YES)
+		  goto syntax;
+  }
+
+    
+  nowait = gfc_match ("% nowait") == MATCH_YES ;
+
+  if (gfc_match_hls_eos () != MATCH_YES)
+	  return MATCH_ERROR;
+
+  if ( nowait )
+ 	 new_st.op = EXEC_HLS_SINGLE_NOWAIT;
+  else
+	 new_st.op = EXEC_HLS_SINGLE;
+  new_st.ext.hls.scope = scope ;
+  new_st.ext.hls.level = level ;
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in !$HLS SINGLE at %C");
+
+cleanup:
+  gfc_current_locus = old_loc;
+  return MATCH_ERROR;
+}
+
+match gfc_match_hls_end_single (void)
+{
+  if (gfc_match_hls_eos () != MATCH_YES)
+	  return MATCH_ERROR;
+
+  new_st.op = EXEC_HLS_END_SINGLE;
+  return MATCH_YES;
+}
+
+match gfc_match_hls_barrier (void)
+{
+  locus old_loc;
+  char n[GFC_MAX_SYMBOL_LEN+1];
+  gfc_symbol *sym;
+  match m;
+  gfc_symtree *st;
+  gfc_hls_scope min_scope = HLS_SCOPE_CORE ;
+  unsigned int max_level = 1;
+
+  old_loc = gfc_current_locus;
+
+  m = gfc_match (" (");
+  if (m != MATCH_YES)
+	  return m;
+
+  for (;;)
+  {
+	  m = gfc_match_symbol (&sym, 0);
+	  switch (m)
+	  {
+		  case MATCH_YES:
+			  if ( sym->attr.hls_scope == HLS_SCOPE_NONE )
+				  gfc_error_now ("variable at %C has not been declared HLS");
+			  else if ( sym->attr.hls_scope < min_scope ) {
+				  min_scope = sym->attr.hls_scope ;
+				  max_level = sym->attr.hls_level ;
+			  }
+			  else if ( sym->attr.hls_scope == min_scope && sym->attr.hls_level > max_level )
+				  max_level = sym->attr.hls_level ;
+			  goto next_item;
+		  case MATCH_NO:
+			  break;
+		  case MATCH_ERROR:
+			  goto cleanup;
+	  }
+
+	  m = gfc_match (" / %n /", n);
+	  if (m == MATCH_ERROR)
+		  goto cleanup;
+	  if (m == MATCH_NO || n[0] == '\0')
+		  goto syntax;
+
+	  st = gfc_find_symtree (gfc_current_ns->common_root, n);
+	  if (st == NULL)
+	  {
+		  gfc_error ("COMMON block /%s/ not found at %C", n);
+		  goto cleanup;
+	  }
+	  if ( st->n.common->hls_scope == HLS_SCOPE_NONE )
+	  {
+		  gfc_error_now ("variable at %C has not been declared HLS");
+		  goto next_item;
+	  }else if ( st->n.common->hls_scope < min_scope ) {
+		  min_scope = st->n.common->hls_scope ;
+		  max_level = st->n.common->hls_level ;
+	  }
+	  else if ( st->n.common->hls_scope == min_scope && st->n.common->hls_level > max_level )
+		  max_level = st->n.common->hls_level ;
+
+next_item:
+	  if (gfc_match_char (')') == MATCH_YES)
+		  break;
+	  if (gfc_match_char (',') != MATCH_YES)
+		  goto syntax;
+  }
+  
+  if (gfc_match_hls_eos () != MATCH_YES)
+	  return MATCH_ERROR;
+  new_st.op = EXEC_HLS_BARRIER;
+  new_st.ext.hls.scope = min_scope ;
+  new_st.ext.hls.level = max_level ;
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in !$HLS BARRIER at %C");
+
+cleanup:
+  gfc_current_locus = old_loc;
+  return MATCH_ERROR;
+}
+
+tree gfc_trans_hls_directive (gfc_code *code)
+{
+  tree arg, call_hls, then_block, cond;
+  bool nowait = true ;
+  stmtblock_t stmt_block;
+  const gfc_hls_scope scope = code->ext.hls.scope ;
+  const unsigned int level = code->ext.hls.level ;
+  unsigned int hls_scope_with_level ;
+ 
+  hls_scope_with_level = scope - HLS_SCOPE_NODE ;
+
+  if ( scope == HLS_SCOPE_NUMA )
+	  hls_scope_with_level += 2 - level ;
+  else if ( scope > HLS_SCOPE_NUMA )
+	  hls_scope_with_level += 1 ;
+
+  if ( scope == HLS_SCOPE_CACHE )
+	  hls_scope_with_level += 3 - level ;
+  else if ( scope > HLS_SCOPE_CACHE )
+	  hls_scope_with_level += 2 ;
+
+  arg = build_int_cst ( integer_type_node, hls_scope_with_level );
+
+  switch (code->op)
+    {
+    case EXEC_HLS_BARRIER:
+		call_hls = builtin_decl_explicit(BUILT_IN_MPC_HLS_BARRIER);
+		call_hls = build_call_expr (call_hls, 1, arg);
+		return call_hls;
+	case EXEC_HLS_SINGLE:
+		nowait = false ;
+	case EXEC_HLS_SINGLE_NOWAIT:
+		pushlevel ();
+		then_block = gfc_trans_code (code->block->next);
+		if ( !nowait ) {
+			call_hls = builtin_decl_explicit(BUILT_IN_MPC_HLS_SINGLE_DONE);
+			call_hls = build_call_expr (call_hls, 1, arg);
+			stmt_block.head = then_block;
+			stmt_block.has_scope = 1;
+			gfc_add_expr_to_block ( &stmt_block, call_hls) ;
+		}
+		if (TREE_CODE (then_block) != BIND_EXPR)
+		{
+			tree block = poplevel (1, 0);
+			then_block = build3_v (BIND_EXPR, NULL, then_block, block);
+		}
+		else
+			poplevel (0, 0);
+		call_hls = builtin_decl_explicit(nowait?BUILT_IN_MPC_HLS_SINGLE_NOWAIT:BUILT_IN_MPC_HLS_SINGLE);
+		call_hls = build_call_expr (call_hls, 1, arg);
+		cond = build3 (COND_EXPR, void_type_node, call_hls, then_block, NULL);
+		return cond ;
+    default:
+      gcc_unreachable ();
+    }
+}
diff -Naur gcc-4.8.0/gcc/fortran/lang.opt mpc-gcc-4.8.0/gcc/fortran/lang.opt
--- gcc-4.8.0/gcc/fortran/lang.opt	2013-01-16 17:19:32.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/lang.opt	2016-04-19 15:29:43.000000000 +0200
@@ -237,6 +237,12 @@
 Fortran Warning
 Warn about function call elimination
 
+; MPC GLOBAL BEGIN
+;Wmpc
+;Fortran Warning
+;Warn about MPC and thread-safety issues
+; MPC GLOBAL END
+
 Wimplicit-interface
 Fortran Warning
 Warn about calls with implicit interface
@@ -341,6 +347,16 @@
 Fortran RejectNegative Joined UInteger
 -fblas-matmul-limit=<n>	Size of the smallest matrix for which matmul will use BLAS
 
+; MPC TLS BEGIN 
+fhls
+Fortran
+Enable Hierarchical Local Storage (HLS) directives
+
+fhls-verbose
+Fortran
+Enable verbose output for Hierarchical Local Storage (HLS) directives
+; MPC TLS END 
+
 fcheck-array-temporaries
 Fortran
 Produce a warning at runtime if a array temporary has been created for a procedure argument
@@ -505,6 +521,12 @@
 Fortran
 Set default accessibility of module entities to PRIVATE.
 
+; MPC TLS BEGIN 
+fmpc-privatize
+Fortran
+Privatize every global variable to make MPI codes MPC compliant.
+; MPC TLS END 
+
 fopenmp
 Fortran
 ; Documented in C
diff -Naur gcc-4.8.0/gcc/fortran/match.h mpc-gcc-4.8.0/gcc/fortran/match.h
--- gcc-4.8.0/gcc/fortran/match.h	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/match.h	2016-04-19 15:29:44.000000000 +0200
@@ -190,6 +190,17 @@
 match gfc_match_value (void);
 match gfc_match_volatile (void);
 
+/* MPC HLS BEGIN */
+match gfc_match_hls_node (void);
+match gfc_match_hls_numa (void);
+match gfc_match_hls_socket (void);
+match gfc_match_hls_core (void);
+match gfc_match_hls_cache (void);
+match gfc_match_hls_single (void);
+match gfc_match_hls_end_single (void);
+match gfc_match_hls_barrier (void);
+/* MPC HLS END */
+
 /* decl.c.  */
 
 /* Fortran 2003 c interop.
diff -Naur gcc-4.8.0/gcc/fortran/options.c mpc-gcc-4.8.0/gcc/fortran/options.c
--- gcc-4.8.0/gcc/fortran/options.c	2013-02-14 23:13:26.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/options.c	2016-04-19 15:29:44.000000000 +0200
@@ -162,6 +162,17 @@
   gfc_option.flag_frontend_optimize = -1;
   
   gfc_option.fpe = 0;
+  
+  /* MPC GLOBAL BEGIN */
+  //~ gfc_option.warn_mpc = 0 ;
+  //~ gfc_option.flag_mpc_privatize = 0 ;
+  /* MPC GLOBAL END */
+
+  /* MPC HLS BEGIN */
+  gfc_option.flag_hls = 0 ;
+  gfc_option.flag_hls_verbose = 0 ;
+  /* MPC HLS END */
+  
   gfc_option.rtcheck = 0;
   gfc_option.coarray = GFC_FCOARRAY_NONE;
 
@@ -475,6 +486,13 @@
   gfc_option.warn_unused_dummy_argument = setting;
   gfc_option.warn_target_lifetime = setting;
 
+  /* MPC TLS BEGIN */
+  /* Uncomment the following assignment to enable -Wmpc w/ -Wall */
+  #if 0
+    gfc_option.warn_mpc = setting;
+  #endif
+  /* MPC TLS END */
+  
   warn_return_type = setting;
   warn_uninitialized = setting;
   warn_maybe_uninitialized = setting;
@@ -701,7 +719,13 @@
     case OPT_Wtabs:
       gfc_option.warn_tabs = value;
       break;
-
+    
+    /* MPC GLOBAL BEGIN */
+    case OPT_Wmpc:
+      //~ gfc_option.warn_mpc = value ;
+      break ;
+    /* MPC GLOBAL END */
+    
     case OPT_Wtarget_lifetime:
       gfc_option.warn_target_lifetime = value;
       break;
@@ -804,7 +828,22 @@
     case OPT_ffree_form:
       gfc_option.source_form = FORM_FREE;
       break;
-
+	
+	/* MPC TLS BEGIN */
+    case OPT_fmpc_privatize:
+      //~ gfc_option.flag_mpc_privatize = value ;
+      break ;
+      /* MPC TLS END */
+
+    /* MPC HLS BEGIN */
+    case OPT_fhls:
+      gfc_option.flag_hls = value;
+      break;
+    case OPT_fhls_verbose:
+      gfc_option.flag_hls_verbose = value;
+      break;
+    /* MPC HLS END */
+    
     case OPT_fopenmp:
       gfc_option.gfc_flag_openmp = value;
       break;
diff -Naur gcc-4.8.0/gcc/fortran/parse.c mpc-gcc-4.8.0/gcc/fortran/parse.c
--- gcc-4.8.0/gcc/fortran/parse.c	2013-02-02 10:50:58.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/parse.c	2016-04-19 15:29:44.000000000 +0200
@@ -633,6 +633,69 @@
   return ST_NONE;
 }
 
+/* MPC BEGIN */
+static gfc_statement
+decode_hls_directive (void)
+{
+  locus old_locus;
+  char c;
+
+#ifdef GFC_DEBUG
+  gfc_symbol_state ();
+#endif
+
+  gfc_clear_error ();	/* Clear any pending errors.  */
+  gfc_clear_warning ();	/* Clear any pending warnings.  */
+
+  if (gfc_pure (NULL))
+    {
+      gfc_error_now ("HLS directives at %C may not appear in PURE "
+		     "or ELEMENTAL procedures");
+      gfc_error_recovery ();
+      return ST_NONE;
+    }
+
+  old_locus = gfc_current_locus;
+
+  /* return statement not used here */
+  c = gfc_peek_ascii_char ();
+
+  switch (c)
+    {
+	case 'b':
+		match ( "barrier", gfc_match_hls_barrier, ST_HLS_BARRIER);
+		break;
+	case 'c':
+		match ( "cache", gfc_match_hls_cache, ST_HLS_SCOPE);
+		match ( "core", gfc_match_hls_core, ST_HLS_SCOPE);
+		break;
+	case 'e':
+		match ( "end single", gfc_match_hls_end_single, ST_HLS_END_SINGLE);
+		break;
+    case 'n':
+		match ( "node", gfc_match_hls_node, ST_HLS_SCOPE);
+		match ( "numa", gfc_match_hls_numa, ST_HLS_SCOPE);
+		break;
+	case 's':
+		match ( "socket", gfc_match_hls_socket, ST_HLS_SCOPE);
+		match ( "single", gfc_match_hls_single, ST_HLS_SINGLE);
+		break;
+	}
+
+  /* All else has failed, so give up.  See if any of the matchers has
+     stored an error message of some sort.  */
+
+  if (gfc_error_check () == 0)
+    gfc_error_now ("Unclassifiable HLS directive at %C");
+
+  reject_statement ();
+
+  gfc_error_recovery ();
+
+  return ST_NONE;
+}
+/* MPC END */
+
 static gfc_statement
 decode_gcc_attribute (void)
 {
@@ -669,7 +732,7 @@
 {
   match m;
   int i, cnt, at_bol;
-  char c;
+  char c, directive[5];
 
   at_bol = gfc_at_bol ();
   gfc_gobble_whitespace ();
@@ -747,19 +810,40 @@
 	  return decode_gcc_attribute ();
 
 	}
+      /* MPC BEGIN */
+	 #if 0
       else if (c == '$' && gfc_option.gfc_flag_openmp)
+      #endif
+    /* MPC END */
+      else if (c == '$' && (gfc_option.gfc_flag_openmp || gfc_option.flag_hls))
 	{
 	  int i;
 
 	  c = gfc_next_ascii_char ();
 	  for (i = 0; i < 4; i++, c = gfc_next_ascii_char ())
+	   /* MPC BEGIN */
+	  #if 0
 	    gcc_assert (c == "$omp"[i]);
-
+	  #endif
+	  directive[i] = c;
+	   directive[4] = 0 ;
+	  gcc_assert ( strcmp(directive,"$omp") == 0 || strcmp(directive,"$hls") == 0 );
+	  /* MPC END */
 	  gcc_assert (c == ' ' || c == '\t');
 	  gfc_gobble_whitespace ();
 	  if (last_was_use_stmt)
 	    use_modules ();
-	  return decode_omp_directive ();
+	   /* MPC BEGIN */
+	  #if 0
+		return decode_omp_directive ();
+	  #endif
+	  if ( strcmp(directive,"$hls") == 0 )
+		 return decode_hls_directive() ;
+	  else if ( strcmp(directive,"$omp") == 0 )
+	     return decode_omp_directive() ;
+
+          gcc_assert ( 0 ) ;
+	  /* MPC HLS END */
 	}
 
       gcc_unreachable (); 
@@ -836,11 +920,18 @@
 
 	      return decode_gcc_attribute ();
 	    }
-	  else if (c == '$' && gfc_option.gfc_flag_openmp)
+	   /* MPC BEGIN */
+	 #if 0
+      else if (c == '$' && gfc_option.gfc_flag_openmp)
+      #endif
+      else if (c == '$' && (gfc_option.gfc_flag_openmp || gfc_option.flag_hls))
 	    {
+			char directive[5];
 	      for (i = 0; i < 4; i++, c = gfc_next_char_literal (NONSTRING))
-		gcc_assert ((char) gfc_wide_tolower (c) == "$omp"[i]);
-
+				directive[i] = (char) gfc_wide_tolower ( c );/*gcc_assert ((char) gfc_wide_tolower (c) == "$omp"[i]);*/
+		  directive[4] = 0;
+		  gcc_assert ( strcmp(directive,"$omp") == 0 || strcmp(directive,"$hls") == 0 );
+		  /* MPC END */
 	      if (c != ' ' && c != '0')
 		{
 		  gfc_buffer_error (0);
@@ -849,7 +940,13 @@
 		}
 	      if (last_was_use_stmt)
 		use_modules ();
-	      return decode_omp_directive ();
+	     /* MPC BEGIN */
+	      /* return decode_omp_directive (); */
+	      if ( strcmp(directive,"$omp") == 0 ) 
+	        return decode_omp_directive() ;
+	      else if ( strcmp(directive,"$hls") == 0 )
+			return decode_hls_directive() ;
+		/* MPC END */
 	    }
 	  /* FALLTHROUGH */
 
@@ -1008,7 +1105,7 @@
   case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \
   case ST_OMP_BARRIER: case ST_OMP_TASKWAIT: case ST_OMP_TASKYIELD: \
   case ST_ERROR_STOP: case ST_SYNC_ALL: case ST_SYNC_IMAGES: \
-  case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK
+  case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK: case ST_HLS_BARRIER /* MPC HLS */
 
 /* Statements that mark other executable statements.  */
 
@@ -1020,14 +1117,14 @@
   case ST_OMP_CRITICAL: case ST_OMP_MASTER: case ST_OMP_SINGLE: \
   case ST_OMP_DO: case ST_OMP_PARALLEL_DO: case ST_OMP_ATOMIC: \
   case ST_OMP_WORKSHARE: case ST_OMP_PARALLEL_WORKSHARE: \
-  case ST_OMP_TASK: case ST_CRITICAL
+  case ST_OMP_TASK: case ST_CRITICAL: case ST_HLS_SINGLE /* MPC HLS */
 
 /* Declaration statements */
 
 #define case_decl case ST_ATTR_DECL: case ST_COMMON: case ST_DATA_DECL: \
   case ST_EQUIVALENCE: case ST_NAMELIST: case ST_STATEMENT_FUNCTION: \
   case ST_TYPE: case ST_INTERFACE: case ST_OMP_THREADPRIVATE: \
-  case ST_PROCEDURE
+  case ST_PROCEDURE: case ST_HLS_SCOPE /* MPC HLS */
 
 /* Block end statements.  Errors associated with interchanging these
    are detected in gfc_match_end().  */
@@ -1608,6 +1705,22 @@
     case ST_OMP_WORKSHARE:
       p = "!$OMP WORKSHARE";
       break;
+      
+    /* MPC HLS BEGIN */
+    case ST_HLS_SCOPE:
+      p = "!$HLS";
+      break;
+    case ST_HLS_SINGLE:
+      p = "!$HLS SINGLE";
+      break;
+    case ST_HLS_END_SINGLE:
+      p = "!$HLS END SINGLE";
+      break;
+    case ST_HLS_BARRIER:
+      p = "!$HLS BARRIER";
+      break;
+    /* MPC HLS END */
+    
     default:
       gfc_internal_error ("gfc_ascii_statement(): Bad statement code");
     }
@@ -3781,6 +3894,34 @@
   pop_state ();
 }
 
+/* MPC HLS BEGIN */
+static void
+parse_hls_structured_block (gfc_statement hls_st)
+{
+  gfc_statement st;
+  gfc_code *cp, *np;
+  gfc_state_data s;
+
+  accept_statement (hls_st);
+
+  cp = gfc_state_stack->tail;
+  push_state (&s, COMP_HLS_STRUCTURED_BLOCK, NULL);
+  np = new_level (cp);
+  np->op = cp->op;
+  np->block = NULL;
+
+  st = parse_executable (ST_NONE);
+  if (st == ST_NONE)
+	  unexpected_eof ();
+  else if (st != ST_HLS_END_SINGLE)
+	unexpected_statement (st);
+
+  gfc_clear_new_st ();
+  gfc_commit_symbols ();
+  gfc_warning_check ();
+  pop_state ();
+}
+/* MPC HLS END */
 
 /* Accept a series of executable statements.  We return the first
    statement that doesn't fit to the caller.  Any block statements are
@@ -3906,7 +4047,13 @@
 	case ST_OMP_ATOMIC:
 	  st = parse_omp_atomic ();
 	  continue;
-
+	  
+    /* MPC HLS BEGIN */
+	case ST_HLS_SINGLE:
+	  parse_hls_structured_block (st);
+	  break;
+	/* MPC HLS END */
+	
 	default:
 	  return st;
 	}
diff -Naur gcc-4.8.0/gcc/fortran/parse.h mpc-gcc-4.8.0/gcc/fortran/parse.h
--- gcc-4.8.0/gcc/fortran/parse.h	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/parse.h	2016-04-19 15:29:44.000000000 +0200
@@ -29,7 +29,8 @@
   COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_DERIVED_CONTAINS,
   COMP_BLOCK, COMP_ASSOCIATE, COMP_IF,
   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,
-  COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT
+  COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT,
+  COMP_HLS_STRUCTURED_BLOCK /* MPC HLS */
 }
 gfc_compile_state;
 
diff -Naur gcc-4.8.0/gcc/fortran/resolve.c mpc-gcc-4.8.0/gcc/fortran/resolve.c
--- gcc-4.8.0/gcc/fortran/resolve.c	2013-03-10 14:23:58.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/resolve.c	2016-04-19 15:29:44.000000000 +0200
@@ -9440,7 +9440,13 @@
 	case EXEC_OMP_TASKYIELD:
 	case EXEC_OMP_WORKSHARE:
 	  break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  break;
+	/* MPC HLS END */
+	
 	default:
 	  gfc_internal_error ("gfc_resolve_blocks(): Bad block type");
 	}
@@ -10438,7 +10444,14 @@
 	  gfc_resolve_omp_directive (code, ns);
 	  omp_workshare_flag = omp_workshare_save;
 	  break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_BARRIER:
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  break;
+	/* MPC HLS END */
+	
 	default:
 	  gfc_internal_error ("resolve_code(): Bad statement code");
 	}
@@ -13779,6 +13792,15 @@
 	      || sym->ns->proc_name->attr.flavor != FL_MODULE)))
     gfc_error ("Threadprivate at %L isn't SAVEd", &sym->declared_at);
 
+	/* MPC HLS BEGIN */
+  if (sym->attr.hls_scope && !sym->attr.save && !sym->ns->save_all
+      && (!sym->attr.in_common
+	  && sym->module == NULL
+	  && (sym->ns->proc_name == NULL
+	      || sym->ns->proc_name->attr.flavor != FL_MODULE)))
+    gfc_error ("HLS at %L isn't SAVEd", &sym->declared_at);
+  /* MPC HLS END */
+  
   /* If we have come this far we can apply default-initializers, as
      described in 14.7.5, to those variables that have not already
      been assigned one.  */
diff -Naur gcc-4.8.0/gcc/fortran/scanner.c mpc-gcc-4.8.0/gcc/fortran/scanner.c
--- gcc-4.8.0/gcc/fortran/scanner.c	2013-02-14 23:13:26.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/scanner.c	2016-04-19 15:29:44.000000000 +0200
@@ -62,7 +62,10 @@
 static gfc_directorylist *include_dirs, *intrinsic_modules_dirs;
 
 static gfc_file *file_head, *current_file;
-
+/* MPC HLS BEGIN */
+static int hls_flag;
+static locus hls_locus;
+/* MPC HLS END */
 static int continue_flag, end_flag, openmp_flag, gcc_attribute_flag;
 static int continue_count, continue_line;
 static locus openmp_locus;
@@ -812,6 +815,36 @@
 		      next_char ();
 		      c = next_char ();
 		    }
+		    /* MPC HLS BEGIN */
+		  else if (c == 'h' || c == 'H')
+		    {
+		      if (((c = next_char ()) == 'l' || c == 'L')
+			  && ((c = next_char ()) == 's' || c == 'S'))
+			{
+			  if ((c = next_char ()) == ' ' || c == '\t'
+			      || continue_flag)
+			    {
+			      while (gfc_is_whitespace (c))
+				c = next_char ();
+			      if (c != '\n' && c != '!')
+				{
+				  hls_flag = 1;
+				  hls_locus = old_loc;
+				  gfc_current_locus = start;
+				  return false;
+				}
+			    }
+			  else
+			    gfc_warning_now ("!$HLS at %C starts a commented "
+					     "line as it neither is followed "
+					     "by a space nor is a "
+					     "continuation line");
+			}
+		      gfc_current_locus = old_loc;
+		      next_char ();
+		      c = next_char ();
+		    }
+                    /* MPC HLS END */
 		  if (continue_flag || c == ' ' || c == '\t')
 		    {
 		      gfc_current_locus = old_loc;
@@ -831,7 +864,10 @@
 
   if (openmp_flag && at_bol)
     openmp_flag = 0;
-
+  /* MPC HLS BEGIN */
+  if (hls_flag && at_bol)
+    hls_flag = 0;
+/* MPC HLS END */
   gcc_attribute_flag = 0;
   gfc_current_locus = start;
   return false;
@@ -933,6 +969,32 @@
 			    }
 			}
 		    }
+		     /* MPC HLS BEGIN */
+		  else if (c == 'h' || c == 'H')
+		    {
+		      if (((c = next_char ()) == 'l' || c == 'L')
+			  && ((c = next_char ()) == 's' || c == 'S'))
+			{
+			  c = next_char ();
+			  if (c != '\n'
+			      && ((hls_flag && continue_flag)
+				  || c == ' ' || c == '\t' || c == '0'))
+			    {
+			      do
+				c = next_char ();
+			      while (gfc_is_whitespace (c));
+			      if (c != '\n' && c != '!')
+				{
+				  /* Canonicalize to *$hls.  */
+				  *start.nextc = '*';
+				  hls_flag = 1;
+				  gfc_current_locus = start;
+				  return;
+				}
+			    }
+			}
+		    }
+		   /* MPC HLS END */
 		  else
 		    {
 		      int digit_seen = 0;
@@ -1005,6 +1067,9 @@
     }
 
   openmp_flag = 0;
+  /* MPC HLS BEGIN */
+  hls_flag = 0;
+  /* MPC HLS END */
   gcc_attribute_flag = 0;
   gfc_current_locus = start;
 }
@@ -1034,6 +1099,9 @@
 {
   locus old_loc;
   int i, prev_openmp_flag;
+  /* MPC HLS BEGIN */
+  int prev_hls_flag;
+  /* MPC HLS END */
   gfc_char_t c;
 
   continue_flag = 0;
@@ -1049,6 +1117,9 @@
   if (gfc_current_form == FORM_FREE)
     {
       bool openmp_cond_flag;
+       /* MPC HLS BEGIN */
+      bool hls_cond_flag;
+      /* MPC HLS END */
 
       if (!in_string && c == '!')
 	{
@@ -1056,7 +1127,14 @@
 	      && memcmp (&gfc_current_locus, &gcc_attribute_locus,
 		 sizeof (gfc_current_locus)) == 0)
 	    goto done;
-
+	  
+	  /* MPC HLS BEGIN */
+	  if (hls_flag
+	      && memcmp (&gfc_current_locus, &hls_locus,
+		 sizeof (gfc_current_locus)) == 0)
+	    goto done;
+          /* MPC HLS END */
+          
 	  if (openmp_flag
 	      && memcmp (&gfc_current_locus, &openmp_locus,
 		 sizeof (gfc_current_locus)) == 0)
@@ -1117,6 +1195,9 @@
 	}
 
       prev_openmp_flag = openmp_flag;
+      /* MPC HLS BEGIN */
+      prev_hls_flag = hls_flag;
+      /* MPC HLS END */
       continue_flag = 1;
       if (c == '!')
 	skip_comment_line ();
@@ -1141,6 +1222,9 @@
 
       /* Now find where it continues. First eat any comment lines.  */
       openmp_cond_flag = skip_free_comments ();
+       /* MPC HLS BEGIN */
+      hls_cond_flag = openmp_cond_flag;
+      /* MPC HLS END */
 
       if (gfc_current_locus.lb != NULL
 	  && continue_line < gfc_linebuf_linenum (gfc_current_locus.lb))
@@ -1153,7 +1237,17 @@
 	  c = '&';
 	  goto done;
 	}
-
+	
+	   /* MPC HLS BEGIN */
+      if (prev_hls_flag != hls_flag)
+	{
+	  gfc_current_locus = old_loc;
+	  hls_flag = prev_hls_flag;
+	  c = '&';
+	  goto done;
+	}
+	/* MPC HLS END */
+	
       /* Now that we have a non-comment line, probe ahead for the
 	 first non-whitespace character.  If it is another '&', then
 	 reading starts at the next character, otherwise we must back
@@ -1176,7 +1270,21 @@
 	  while (gfc_is_whitespace (c))
 	    c = next_char ();
 	}
-
+	  
+	  /* MPC HLS BEGIN */
+      if (hls_flag)
+	{
+	  for (i = 0; i < 5; i++, c = next_char ())
+	    {
+	      gcc_assert (gfc_wide_tolower (c) == (unsigned char) "!$hls"[i]);
+	      if (i == 4)
+		old_loc = gfc_current_locus;
+	    }
+	  while (gfc_is_whitespace (c))
+	    c = next_char ();
+	}
+      /* MPC HLS END */
+      
       if (c != '&')
 	{
 	  if (in_string)
@@ -1190,6 +1298,10 @@
 	     continuation line only optionally.  */
 	  else if (openmp_flag || openmp_cond_flag)
 	    gfc_current_locus.nextc--;
+	   /* MPC HLS BEGIN */
+	  else if (hls_flag || hls_cond_flag)
+	    gfc_current_locus.nextc--;
+	  /* MPC HLS END */
 	  else
 	    {
 	      c = ' ';
@@ -1226,6 +1338,9 @@
 	}
 
       prev_openmp_flag = openmp_flag;
+      /* MPC HLS BEGIN */
+      prev_hls_flag = hls_flag;
+      /* MPC HLS END */
       continue_flag = 1;
       old_loc = gfc_current_locus;
 
@@ -1239,21 +1354,36 @@
 	  goto not_continuation;
 	}
 
-      if (!openmp_flag)
-	for (i = 0; i < 5; i++)
+     /* MPC HLS BEGIN */
+    if (hls_flag != prev_hls_flag)
+	{
+	  hls_flag = prev_hls_flag;
+	  goto not_continuation;
+	}
+
+    if (!openmp_flag && !hls_flag)
+	  for (i = 0; i < 5; i++)
 	  {
 	    c = next_char ();
 	    if (c != ' ')
 	      goto not_continuation;
 	  }
-      else
-	for (i = 0; i < 5; i++)
+    else if (openmp_flag)
+	  for (i = 0; i < 5; i++)
 	  {
 	    c = next_char ();
 	    if (gfc_wide_tolower (c) != (unsigned char) "*$omp"[i])
 	      goto not_continuation;
 	  }
-
+	else
+	  for (i = 0; i < 5; i++)
+	  {
+	    c = next_char ();
+	    if (gfc_wide_tolower (c) != (unsigned char) "*$hls"[i])
+	      goto not_continuation;
+	  }
+      /* MPC HLS END */
+      
       c = next_char ();
       if (c == '0' || c == ' ' || c == '\n')
 	goto not_continuation;
diff -Naur gcc-4.8.0/gcc/fortran/st.c mpc-gcc-4.8.0/gcc/fortran/st.c
--- gcc-4.8.0/gcc/fortran/st.c	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/st.c	2016-04-19 15:29:44.000000000 +0200
@@ -212,7 +212,14 @@
     case EXEC_OMP_TASKWAIT:
     case EXEC_OMP_TASKYIELD:
       break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_BARRIER:
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  break;
+	/* MPC HLS END */
+	
     default:
       gfc_internal_error ("gfc_free_statement(): Bad statement");
     }
diff -Naur gcc-4.8.0/gcc/fortran/symbol.c mpc-gcc-4.8.0/gcc/fortran/symbol.c
--- gcc-4.8.0/gcc/fortran/symbol.c	2013-03-03 18:34:42.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/symbol.c	2016-04-19 15:29:44.000000000 +0200
@@ -364,7 +364,10 @@
     *asynchronous = "ASYNCHRONOUS", *codimension = "CODIMENSION",
     *contiguous = "CONTIGUOUS", *generic = "GENERIC";
   static const char *threadprivate = "THREADPRIVATE";
-
+/* MPC HLS BEGIN */
+  static const char *hls_scope = "HLS SCOPE";
+  static const char *hls_level = "HLS LEVEL";
+  /* MPC HLS END */
   const char *a1, *a2;
   int standard;
 
@@ -450,6 +453,10 @@
   conf (dummy, entry);
   conf (dummy, intrinsic);
   conf (dummy, threadprivate);
+  /* MPC HLS BEGIN */
+  conf (dummy, hls_scope);
+  conf (dummy, hls_level);
+  /* MPC HLS END */
   conf (pointer, target);
   conf (pointer, intrinsic);
   conf (pointer, elemental);
@@ -492,6 +499,10 @@
   conf (in_equivalence, entry);
   conf (in_equivalence, allocatable);
   conf (in_equivalence, threadprivate);
+  /* MPC HLS BEGIN */
+  conf (in_equivalence, hls_scope);
+  conf (in_equivalence, hls_level);
+  /* MPC HLS END */
 
   conf (dummy, result);
   conf (entry, result);
@@ -540,6 +551,10 @@
   conf (cray_pointee, in_common);
   conf (cray_pointee, in_equivalence);
   conf (cray_pointee, threadprivate);
+  /* MPC HLS BEGIN */
+  conf (cray_pointee, hls_scope);
+  conf (cray_pointee, hls_level);
+  /* MPC HLS END */
 
   conf (data, dummy);
   conf (data, function);
@@ -626,6 +641,10 @@
       conf2 (function);
       conf2 (subroutine);
       conf2 (threadprivate);
+      /* MPC HLS BEGIN */
+      conf2 (hls_scope);
+      conf2 (hls_level);
+      /* MPC HLS END */
 
       if (attr->access == ACCESS_PUBLIC || attr->access == ACCESS_PRIVATE)
 	{
@@ -667,6 +686,12 @@
 	  conf2 (function);
 	  if (!attr->proc_pointer)
 	    conf2 (threadprivate);
+	  
+	  /* MPC HLS BEGIN */
+	  conf2 (hls_scope);
+	  conf2 (hls_level);
+	  /* MPC HLS END */
+	  
 	}
 
       if (!attr->proc_pointer)
@@ -686,6 +711,10 @@
 	case PROC_DUMMY:
 	  conf2 (result);
 	  conf2 (threadprivate);
+	  /* MPC HLS BEGIN */
+	  conf2 (hls_scope);
+	  conf2 (hls_level);
+	  /* MPC HLS END */
 	  break;
 
 	default:
@@ -706,6 +735,10 @@
       conf2 (function);
       conf2 (subroutine);
       conf2 (threadprivate);
+      /* MPC HLS BEGIN */
+      conf2 (hls_scope);
+      conf2 (hls_level);
+      /* MPC HLS END */
       conf2 (result);
 
       if (attr->intent != INTENT_UNKNOWN)
@@ -733,6 +766,10 @@
       conf2 (volatile_);
       conf2 (asynchronous);
       conf2 (threadprivate);
+      /* MPC HLS BEGIN */
+      conf2 (hls_scope);
+      conf2 (hls_level);
+      /* MPC HLS END */
       conf2 (value);
       conf2 (codimension);
       conf2 (result);
@@ -905,6 +942,32 @@
   return check_conflict (attr, name, where);
 }
 
+/* MPC HLS BEGIN */
+gfc_try
+gfc_add_hls_scope (symbol_attribute *attr, const char *name, locus *where, gfc_hls_scope scope, unsigned int level)
+{
+  if (check_used (attr, name, where))
+    return FAILURE;
+
+  if (attr->hls_scope == scope) 
+    {
+      duplicate_attr ("HLS_SCOPE", where);
+      return FAILURE;
+    }
+  
+  if ( attr->hls_scope != HLS_SCOPE_NONE )
+    {
+      if (where == NULL)
+        where = &gfc_current_locus;
+      gfc_error ("Variable %s at %L already specified HLS", name, where);
+      return FAILURE;
+    }
+
+  attr->hls_scope = scope;
+  attr->hls_level = level;
+  return check_conflict (attr, name, where);
+}
+/* MPC HLS END */
 
 gfc_try
 gfc_add_dimension (symbol_attribute *attr, const char *name, locus *where)
@@ -1760,6 +1823,13 @@
   if (src->threadprivate
       && gfc_add_threadprivate (dest, NULL, where) == FAILURE)
     goto fail;
+    
+  /* MPC HLS BEGIN */
+  if (src->hls_scope != HLS_SCOPE_NONE
+      && gfc_add_hls_scope (dest, NULL, where, src->hls_scope, src->hls_level) == FAILURE)
+    goto fail;
+  /* MPC HLS END */
+    
   if (src->target && gfc_add_target (dest, where) == FAILURE)
     goto fail;
   if (src->dummy && gfc_add_dummy (dest, NULL, where) == FAILURE)
diff -Naur gcc-4.8.0/gcc/fortran/trans-common.c mpc-gcc-4.8.0/gcc/fortran/trans-common.c
--- gcc-4.8.0/gcc/fortran/trans-common.c	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/trans-common.c	2016-04-20 09:35:03.000000000 +0200
@@ -445,7 +445,86 @@
       gfc_set_decl_location (decl, &com->where);
 
       if (com->threadprivate)
+      {
+#if 1 /* MPC OMP FORTRAN THREADPRIVATE */ 
+	DECL_TLS_MODEL (decl) = TLS_MODEL_MPC_OPENMP ;
+	/* Verbose mode */
+	if ( flag_openmp_verbose && DECL_NAME(decl) ) 
+	{
+	  fprintf( stderr, "MPC-OPENMP: Found threadprivate variable %s (file %s line %d)\n"
+	      , IDENTIFIER_POINTER( DECL_NAME(decl) )
+	      , DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+	}
+#else /* MPC OMP FORTRAN THREADPRIVATE */
 	DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
+#endif /* MPC OMP FORTRAN THREADPRIVATE */
+      }
+
+/* MPC HLS BEGIN */
+      switch(com->hls_scope)
+      {
+        case HLS_SCOPE_NODE:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NODE ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope node of variable %s (file %s line %d)\n",
+              IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_NUMA:
+		  if ( com->hls_level == 1 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NUMA_LEVEL_1 ;
+		  else if ( com->hls_level == 2 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NUMA_LEVEL_2 ;
+		  else
+			gfc_internal_error ("HLS level for NUMA scope is invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope numa level %d of variable %s (file %s line %d)\n",
+              com->hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_SOCKET:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_SOCKET ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope socket of variable %s (file %s line %d)\n",
+              IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_CACHE:
+		  if ( com->hls_level == 1 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_1 ;
+		  else if ( com->hls_level == 2 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_2 ;
+		  else if ( com->hls_level == 3 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_3 ;
+		  else
+			gfc_internal_error ("HLS level for CACHE scope invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope cache level %d of variable %s (file %s line %d)\n",
+              com->hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_CORE:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CORE ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope core of variable %s (file %s line %d)\n",
+              IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_NONE:
+          /* do not privatize variables modified by hls or omp threadprivate pragmas */ 
+          if ( flag_mpc_privatize  && ! com->threadprivate ) {
+	fprintf( stderr, 
+	    "(Front-end Fortran) "
+	    "Automatic privatization to MPC task (variable %s in file %s line %d)\n",
+	    IDENTIFIER_POINTER( DECL_NAME(decl) ), 
+	    DECL_SOURCE_FILE(decl),
+	    DECL_SOURCE_LINE(decl) ) ;
+	DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_TASK ;
+      }
+        default:
+          break;
+      }
+	/* MPC HLS END */
 
       /* Place the back end declaration for this common block in
          GLOBAL_BINDING_LEVEL.  */
diff -Naur gcc-4.8.0/gcc/fortran/trans-decl.c mpc-gcc-4.8.0/gcc/fortran/trans-decl.c
--- gcc-4.8.0/gcc/fortran/trans-decl.c	2013-03-01 11:24:11.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/trans-decl.c	2016-04-20 10:25:12.000000000 +0200
@@ -608,7 +608,88 @@
   /* Handle threadprivate variables.  */
   if (sym->attr.threadprivate
       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))
+  {
+#if 1 /* MPC OMP FORTRAN THREADPRIVATE */ 
+    DECL_TLS_MODEL (decl) = TLS_MODEL_MPC_OPENMP ;
+    /* Verbose mode */
+    if ( flag_openmp_verbose && DECL_NAME(decl) ) 
+    {
+      fprintf( stderr, "MPC-OPENMP: Found threadprivate variable %s (file %s line %d)\n"
+	  , IDENTIFIER_POINTER( DECL_NAME(decl) )
+	 , DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+    }
+#else /* MPC OMP FORTRAN THREADPRIVATE */ 
     DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
+#endif /* MPC OMP FORTRAN THREADPRIVATE */
+  }
+  /* MPC HLS BEGIN */
+  if ( TREE_STATIC (decl) || DECL_EXTERNAL (decl) )
+    {
+      switch(sym->attr.hls_scope)
+      {
+        case HLS_SCOPE_NODE:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NODE ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope node of variable %s (file %s line %d)\n",
+            IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_NUMA:
+		  if ( sym->attr.hls_level == 1 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NUMA_LEVEL_1 ;
+		  else if ( sym->attr.hls_level == 2 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_NUMA_LEVEL_2 ;
+		  else
+			internal_error ("HLS level for NUMA scope is invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope numa level %d of variable %s (file %s line %d)\n",
+			sym->attr.hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_SOCKET:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_SOCKET ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope socket of variable %s (file %s line %d)\n",
+            IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_CACHE:
+		  if ( sym->attr.hls_level == 1 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_1 ;
+		  else if ( sym->attr.hls_level == 2 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_2 ;
+		  else if ( sym->attr.hls_level == 3 )
+			  DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CACHE_LEVEL_3 ;
+		  else
+			internal_error ("HLS level for CACHE scope invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope cache level %d of variable %s (file %s line %d)\n",
+			sym->attr.hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_CORE:
+          DECL_TLS_MODEL (decl) = TLS_MODEL_HLS_CORE ;
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope core of variable %s (file %s line %d)\n",
+            IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_NONE:
+        default:
+	  break;
+      }
+
+      if ( flag_mpc_privatize && !sym->attr.threadprivate && !sym->attr.hls_scope) {
+        fprintf( stderr, 
+          "(Front-end Fortran) "
+          "Automatic privatization to MPC task (variable %s in file %s line %d)\n",
+          IDENTIFIER_POINTER( DECL_NAME(decl) ), 
+          DECL_SOURCE_FILE(decl),
+          DECL_SOURCE_LINE(decl) ) ;
+          DECL_TLS_MODEL(decl) = TLS_MODEL_MPC_TASK ;
+      }
+    }
+  /* MPC HLS END */
 }
 
 
@@ -1606,8 +1687,20 @@
   /* Handle threadprivate procedure pointers.  */
   if (sym->attr.threadprivate
       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))
+{
+#if 1 /* MPC OMP FORTRAN THREADPRIVATE */ 
+    DECL_TLS_MODEL (decl) = TLS_MODEL_MPC_OPENMP ;
+    /* Verbose mode */
+    if ( flag_openmp_verbose && DECL_NAME(decl) ) 
+    {
+      fprintf( stderr, "MPC-OPENMP: Found threadprivate variable %s (file %s line %d)\n"
+	  , IDENTIFIER_POINTER( DECL_NAME(decl) )
+	 , DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+    }
+#else /* MPC OMP FORTRAN THREADPRIVATE */ 
     DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
-
+#endif /* MPC OMP FORTRAN THREADPRIVATE */ 
+}
   attributes = add_attributes_to_decl (sym->attr, NULL_TREE);
   decl_attributes (&decl, attributes, 0);
 
@@ -5528,7 +5621,11 @@
   gfc_traverse_ns (ns, gfc_emit_parameter_debug_info);
 
   if (sym->attr.is_main_program)
+  {
+    /* force the main program to be noinline */
+    DECL_UNINLINABLE(fndecl) = 1;
     create_main_function (fndecl);
+  }
 
   current_procedure_symbol = previous_procedure_symbol;
 }
diff -Naur gcc-4.8.0/gcc/fortran/trans-stmt.h mpc-gcc-4.8.0/gcc/fortran/trans-stmt.h
--- gcc-4.8.0/gcc/fortran/trans-stmt.h	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/trans-stmt.h	2016-04-19 15:29:44.000000000 +0200
@@ -64,6 +64,11 @@
 /* trans-openmp.c */
 tree gfc_trans_omp_directive (gfc_code *);
 
+/* MPC HLS BEGIN */
+/* hls.c */
+tree gfc_trans_hls_directive (gfc_code *);
+/* MPC HLS END */
+
 /* trans-io.c */
 tree gfc_trans_open (gfc_code *);
 tree gfc_trans_close (gfc_code *);
diff -Naur gcc-4.8.0/gcc/fortran/trans.c mpc-gcc-4.8.0/gcc/fortran/trans.c
--- gcc-4.8.0/gcc/fortran/trans.c	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/trans.c	2016-04-19 15:29:44.000000000 +0200
@@ -1648,7 +1648,15 @@
 	case EXEC_OMP_WORKSHARE:
 	  res = gfc_trans_omp_directive (code);
 	  break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_BARRIER:
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  res = gfc_trans_hls_directive (code);
+	  break;
+	/* MPC HLS END */
+	
 	default:
 	  internal_error ("gfc_trans_code(): Bad statement code");
 	}
diff -Naur gcc-4.8.0/gcc/fortran/types.def mpc-gcc-4.8.0/gcc/fortran/types.def
--- gcc-4.8.0/gcc/fortran/types.def	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/fortran/types.def	2016-04-19 15:29:44.000000000 +0200
@@ -89,7 +89,9 @@
 DEF_FUNCTION_TYPE_1 (BT_FN_UINT_UINT, BT_UINT, BT_UINT)
 DEF_FUNCTION_TYPE_1 (BT_FN_PTR_PTR, BT_PTR, BT_PTR)
 DEF_FUNCTION_TYPE_1 (BT_FN_VOID_INT, BT_VOID, BT_INT)
-
+/* MPC HLS BEGIN */
+DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)
+/* MPC HLS END */
 
 DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)
 
diff -Naur gcc-4.8.0/gcc/gcc.c mpc-gcc-4.8.0/gcc/gcc.c
--- gcc-4.8.0/gcc/gcc.c	2013-03-06 07:32:03.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/gcc.c	2016-04-22 08:37:06.000000000 +0200
@@ -730,7 +730,26 @@
 /* We pass any -flto flags on to the linker, which is expected
    to understand them.  In practice, this means it had better be collect2.  */
 /* %{e*} includes -export-dynamic; see comment in common.opt.  */
+
 #ifndef LINK_COMMAND_SPEC
+#if 0 /* MPC OMP */
+#define LINK_COMMAND_SPEC "\
+%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
+    %(linker) " \
+    LINK_PLUGIN_SPEC \
+    "%{flto|flto=*:%<fcompare-debug*} \
+    %{flto} %{flto=*} %l " LINK_PIE_SPEC \
+   "%X %{o*} %{e*} %{N} %{n} %{r}\
+    %{s} %{t} %{u*} %{z} %{Z} %{!nostdlib:%{!nostartfiles:%S}}\
+    %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\
+    %{fgnu-tm:%:include(libitm.spec)%(link_itm)}\
+    %(mflib) " STACK_SPLIT_SPEC "\
+    %{fprofile-arcs|fprofile-generate*|coverage:-lgcov}\
+    %{fsanitize=address:" LIBASAN_SPEC "%{static:%ecannot specify -static with -fsanitize=address}}\
+    %{fsanitize=thread:" LIBTSAN_SPEC "}\
+    %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
+    %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}"
+#else /* MPC OMP */
 #define LINK_COMMAND_SPEC "\
 %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
     %(linker) " \
@@ -747,8 +766,10 @@
     %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} " SANITIZER_SPEC " \
     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
     %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}"
+#endif /* MPC OMP */
 #endif
 
+
 #ifndef LINK_LIBGCC_SPEC
 /* Generate -L options for startfile prefix list.  */
 # define LINK_LIBGCC_SPEC "%D"
diff -Naur gcc-4.8.0/gcc/gimplify.c mpc-gcc-4.8.0/gcc/gimplify.c
--- gcc-4.8.0/gcc/gimplify.c	2013-01-28 15:05:40.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/gimplify.c	2016-04-20 09:39:24.000000000 +0200
@@ -5952,14 +5952,24 @@
   /* Threadprivate variables are predetermined.  */
   if (is_global_var (decl))
     {
+      /* MPC OMP BEGIN / MPC TLS BEGIN */
+#if 0
       if (DECL_THREAD_LOCAL_P (decl))
+#endif
+      if (DECL_MPC_THREAD_LOCAL_P (decl))
+      /* MPC OMP END / MPC TLS END */
 	return omp_notice_threadprivate_variable (ctx, decl, NULL_TREE);
 
       if (DECL_HAS_VALUE_EXPR_P (decl))
 	{
 	  tree value = get_base_address (DECL_VALUE_EXPR (decl));
 
+	  /* MPC OMP BEGIN / MPC TLS BEGIN */
+#if 0
 	  if (value && DECL_P (value) && DECL_THREAD_LOCAL_P (value))
+#endif
+	  if (value && DECL_P (value) && DECL_MPC_THREAD_LOCAL_P (value))
+	  /* MPC OMP END / MPC TLS END */
 	    return omp_notice_threadprivate_variable (ctx, decl, value);
 	}
     }
diff -Naur gcc-4.8.0/gcc/hls-builtins.def mpc-gcc-4.8.0/gcc/hls-builtins.def
--- gcc-4.8.0/gcc/hls-builtins.def	1970-01-01 01:00:00.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/hls-builtins.def	2016-04-19 15:29:44.000000000 +0200
@@ -0,0 +1,8 @@
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_BARRIER, "__sctk__hls_barrier",
+		  BT_FN_VOID_INT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_SINGLE, "__sctk__hls_single",
+		  BT_FN_BOOL_INT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_SINGLE_DONE, "__sctk__hls_single_done",
+		  BT_FN_VOID_INT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_SINGLE_NOWAIT, "__sctk__hls_single_nowait",
+		  BT_FN_BOOL_INT, ATTR_NOTHROW_LIST)
diff -Naur gcc-4.8.0/gcc/mpc-pass.c mpc-gcc-4.8.0/gcc/mpc-pass.c
--- gcc-4.8.0/gcc/mpc-pass.c	1970-01-01 01:00:00.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/mpc-pass.c	2016-04-19 15:29:44.000000000 +0200
@@ -0,0 +1,386 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "tree-inline.h"
+#include "langhooks.h"
+#include "flags.h"
+#include "cgraph.h"
+#include "diagnostic.h"
+#include "timevar.h"
+#include "params.h"
+#include "fibheap.h"
+#include "intl.h"
+#include "tree-pass.h"
+#include "hashtab.h"
+#include "coverage.h"
+#include "ggc.h"
+#include "tree-flow.h"
+#include "rtl.h"
+#include "ipa-prop.h"
+
+extern struct varpool_node *varpool_nodes ;
+
+/* This pass is called only once: IPA pass */
+static unsigned int execute_mpc_warning_global_vars(void)
+{
+	#if 0
+  struct varpool_node *curr_node = NULL ;
+
+  curr_node = varpool_nodes ; 
+
+    if ( dump_file ) {
+      fprintf( dump_file, 
+	  "====================== VARPOOL ================\n" ) ;
+      dump_varpool( dump_file ) ;
+      fprintf( dump_file, 
+	  "===============================================\n" ) ;
+    }
+
+  while ( curr_node != NULL ) {
+    tree t ;
+
+    t = curr_node->decl ;
+
+    if ( dump_file ) 
+    {
+  
+      fprintf( dump_file, "execute_mpc_warning_global_vars: global var\n" ) ;
+      if ( DECL_NAME( t ) ) {
+	fprintf( dump_file, "execute_mpc_warning_global_vars:\tname %s\n",
+	    lang_hooks.decl_printable_name (t,2) ) ;
+      } else {
+	fprintf( dump_file, "execute_mpc_warning_global_vars:\tno name\n" ) ;
+      }
+      if ( DECL_IN_SYSTEM_HEADER(t) ) {
+	fprintf( dump_file, "execute_mpc_warning_global_vars:\tSystem Header!\n" ) ;
+      } else {
+	fprintf( dump_file, "execute_mpc_warning_global_vars:\tnot in system header\n" ) ;
+      }
+      if ( TREE_USED( t ) ) {
+	fprintf( dump_file, "execute_mpc_warning_global_vars:\tused\n" ) ;
+      } else {
+	fprintf( dump_file, "execute_mpc_warning_global_vars:\tnot used\n" ) ;
+      }
+      if ( DECL_THREAD_LOCAL_P( t ) ) {
+	fprintf( dump_file, "execute_mpc_warning_global_vars:\tTLS\n" ) ;
+      } else {
+	fprintf( dump_file, "execute_mpc_warning_global_vars:\tNot TLS\n" ) ;
+      }
+
+    }
+
+    if ( TREE_CODE(t) == VAR_DECL &&
+	is_global_var( t ) &&
+	!DECL_ARTIFICIAL( t ) &&
+	!TREE_READONLY( t ) && 
+	!DECL_IN_SYSTEM_HEADER( t ) ) {
+
+      /* Generate an error if this variable has not been privatized */
+      if ( flag_mpc_privatize && !DECL_THREAD_LOCAL_P(t) && !DECL_IN_SYSTEM_HEADER(t) ) {
+	error( 
+	    "Global variable %s has not been privatized (file %s line %d"
+	    , lang_hooks.decl_printable_name (t,2),
+	    DECL_SOURCE_FILE(t),
+	    DECL_SOURCE_LINE(t) ) ;
+      } else {
+		fprintf( stderr, "Warning: Found global variable %s in file %s line %d\n",
+		lang_hooks.decl_printable_name (t,2), DECL_SOURCE_FILE(t), DECL_SOURCE_LINE(t)) ;
+      }
+
+#endif
+#if 0
+  /* Automatic privatization */
+  if ( !DECL_THREAD_LOCAL_P(t) && !DECL_IN_SYSTEM_HEADER(t) ) {
+	  fprintf( stderr, "\t->(Middle-end) Automatic privatization to MPC task\n" ) ;
+	  DECL_TLS_MODEL(t) = TLS_MODEL_MPC_TASK ; 
+
+	  /* If rtl has been already set for this var, call
+	     make_decl_rtl once again, so that encode_section_info
+	     has a chance to look at the new decl flags.  */
+/*	  if (DECL_RTL_SET_P (t))
+		  make_decl_rtl (t);
+*/
+	  /* varpool_finalize_decl( t ) ; */
+	  /* fprintf( stderr, "\t\t(Now TLS model is %d)\n", DECL_TLS_MODEL(t) ) ; */
+  }
+#endif
+    
+#if 0
+    }
+  }
+#endif
+  return 0 ;
+}
+
+static bool gate_mpc_warning_global_vars (void)
+{
+  return warn_mpc != 0;
+}
+
+struct simple_ipa_opt_pass pass_mpc_warning_global_vars = 
+{
+ {
+  SIMPLE_IPA_PASS,
+  "mpcglobalvars",			/* name */
+  OPTGROUP_NONE,
+  gate_mpc_warning_global_vars,		/* gate */
+  execute_mpc_warning_global_vars,	/* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_EARLY_INLINING,			/* tv_id */
+  0,	                                /* properties_required */
+  0,				/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  TODO_dump_symtab 		        /* todo_flags_finish */
+ }
+};
+
+
+static int is_mpi = 0 ;
+static int is_mpc = 0 ;
+static int is_pthread = 0 ;
+static int is_mpc_thread = 0 ;
+static int is_sctk_thread = 0 ;
+
+
+static tree mpc_thread_mixing_1( tree * t_ptr, int * walk_subtrees ATTRIBUTE_UNUSED, void * s ATTRIBUTE_UNUSED) 
+{
+	tree t = *t_ptr ;
+	//return *t_ptr;
+
+  if ( TREE_CODE(t) == CALL_EXPR ) 
+  {
+    tree callee = get_callee_fndecl( t ) ;
+
+    if ( dump_file ) {
+      fprintf( dump_file, "\tCALL EXPR found\n" ) ;
+      if ( callee == NULL_TREE ) {
+	fprintf( dump_file, "\t -> Don't know the callee\n" ) ;
+      }
+    }
+
+    if ( callee != NULL_TREE && DECL_NAME( callee ) ) {
+      const char * name_callee = IDENTIFIER_POINTER( DECL_NAME( callee ) ) ;
+      if ( dump_file ) {
+	fprintf( dump_file, "\t -> name of the callee <%s>\n",
+	    name_callee ) ;
+      }
+
+      /* Check if this name is instance of MPC, MPI, pthread or mpc_thread */
+      if ( strncmp( name_callee, "MPI", 3 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of MPI\n" ) ;
+	}
+	is_mpi = 1 ;
+      }
+      if ( strncmp( name_callee, "MPC", 3 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of MPC\n" ) ;
+	}
+	is_mpc = 1 ;
+      }
+      if ( strncmp( name_callee, "pthread", 7 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of pthread\n" ) ;
+	}
+	is_pthread = 1 ;
+      }
+      if ( strncmp( name_callee, "mpc_thread", 10 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of MPC Thread\n" ) ;
+	}
+	is_mpc_thread = 1 ;
+      }
+      if ( strncmp( name_callee, "sctk_thread", 11 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of SCTK Thread\n" ) ;
+	}
+	is_sctk_thread = 1 ;
+      }
+
+    }
+  }
+	return NULL_TREE ;
+}
+
+static unsigned int execute_mpc_warning_thread_mixing(void)
+{
+
+	struct cgraph_node *node; 
+	//~ basic_block bb;
+	struct function *fun ;
+	//~ gimple_stmt_iterator gsi;
+
+	/* TODO the call graph contains only functions which are called within this
+	* file (or those which has a body and might be called from outside)
+     -> It seems to be enough to traverse the call graph,
+     check the function with no body
+     check the source file location (e.g., mpc.h)
+	*/
+
+	FOR_EACH_DEFINED_FUNCTION (node) 
+	{
+		tree t ;
+		if ( dump_file ) 
+		{
+			fprintf( dump_file, "===== Checking <%s>\n",
+			cgraph_node_name( node ) ) ;
+		}
+
+		t = node->symbol.decl ;
+
+		if ( TREE_CODE( t ) == FUNCTION_DECL ) 
+		{
+			fun = DECL_STRUCT_FUNCTION (t) ;
+			if ( fun != NULL && DECL_SAVED_TREE( t ) != NULL ) 
+			{
+				//~ FOR_EACH_BB_FN (bb, fun)
+					//~ for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+					//~ {
+						//~ walk_tree_without_duplicates_1( gsi_stmt (gsi), mpc_thread_mixing_1, NULL, NULL) ;
+					//~ }
+			} 
+			else 
+			{
+				if ( dump_file ) 
+				{
+					fprintf( dump_file, "-> Skip because the body is not available\n" ) ;
+				}
+			}
+		}
+	}
+
+	if ( dump_file ) 
+	{
+		fprintf( dump_file, "MPI content? %d\n", is_mpi ) ;
+		fprintf( dump_file, "MPC content? %d\n", is_mpc ) ;
+		fprintf( dump_file, "Pthread content? %d\n", is_pthread ) ;
+		fprintf( dump_file, "MPC thread content? %d\n", is_mpc_thread ) ;
+		fprintf( dump_file, "SCTK thread content? %d\n", is_sctk_thread ) ;
+	}
+
+	if ( is_mpi && is_mpc ) 
+	{
+		warning( 0, "Mixing calls to MPI and MPC is tedious") ;
+	}
+	if ( is_mpc_thread && (is_pthread || is_sctk_thread) ) 
+	{
+		warning( 0, "Mixing calls to pthread and MPC is tedious") ;
+	}
+	(void) mpc_thread_mixing_1;
+	return 0 ;
+}
+
+static bool gate_mpc_warning_thread_mixing(void)
+{
+  return warn_mpc != 0;
+}
+
+struct simple_ipa_opt_pass pass_mpc_warning_thread_mixing = 
+{
+ {
+  SIMPLE_IPA_PASS,
+  "pass_mpc_warning_thread_mixing",	/* name */
+  OPTGROUP_NONE,
+  gate_mpc_warning_thread_mixing,	/* gate */
+  execute_mpc_warning_thread_mixing,	/* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_EARLY_INLINING,			/* tv_id */
+  0,	                                /* properties_required */
+  0,				/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  TODO_dump_symtab 		        /* todo_flags_finish */
+ }
+};
+
+
+static unsigned int execute_mpc_remove_hls_node(void)
+{
+#if 0
+  struct varpool_node *curr_node = NULL ;
+
+  curr_node = varpool_nodes ; 
+
+  while ( curr_node != NULL ) {
+    tree t ;
+
+    t = curr_node->decl ;
+
+	if ( TREE_CODE(t) == VAR_DECL &&
+			is_global_var( t ) &&
+			!DECL_ARTIFICIAL( t ) &&
+			!TREE_READONLY( t ) && 
+			!DECL_IN_SYSTEM_HEADER( t ) ) {
+		if ( DECL_TLS_MODEL(t) == TLS_MODEL_HLS_NODE ) {
+			DECL_TLS_MODEL(t) = TLS_MODEL_NONE ;
+			if (DECL_RTL_SET_P (t))
+				make_decl_rtl (t);
+			fprintf( stderr, "(MPC optimization pass) Optimized HLS node variable %s in fine %s line %d base_var %p\n",
+					lang_hooks.decl_printable_name (t,2),
+					DECL_SOURCE_FILE(t),
+					DECL_SOURCE_LINE(t), t) ;
+
+		}
+	}
+    curr_node = curr_node->next ;
+  }
+
+  struct cgraph_node *node;
+  for (node = cgraph_nodes; node; node = node->next)
+  {
+	  tree decl = node->decl;
+	  struct function *this_cfun = DECL_STRUCT_FUNCTION (decl);
+	  basic_block this_block;
+	  FOR_EACH_BB_FN (this_block, this_cfun)
+	  {
+		  gimple_stmt_iterator gsi;
+		  for (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi)) {
+			  gimple stmt = gsi_stmt (gsi);
+			  if (gimple_code (stmt) == )
+		  }
+	  }
+  }
+
+				if (TREE_CODE (op) == ADDR_EXPR) {
+					fprintf(stderr, "recompute for base_var %p\n", get_base_var(op) );
+					recompute_tree_invariant_for_addr_expr (op);
+				}
+#endif
+
+  return 0 ;
+}
+
+static bool gate_mpc_remove_hls_node (void)
+{
+/*  return flag_mpc_hls != 0; */
+	return 0;
+}
+
+struct simple_ipa_opt_pass pass_mpc_remove_hls_node = 
+{
+ {
+  GIMPLE_PASS,
+  "mpcremovehlsnode",			/* name */
+  OPTGROUP_NONE,
+  gate_mpc_remove_hls_node,		/* gate */
+  execute_mpc_remove_hls_node,	/* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_NONE,			/* tv_id */
+  0,	                                /* properties_required */
+  0,				/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  0 		        /* todo_flags_finish */
+ }
+};
+
+
diff -Naur gcc-4.8.0/gcc/passes.c mpc-gcc-4.8.0/gcc/passes.c
--- gcc-4.8.0/gcc/passes.c	2013-02-20 16:19:13.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/passes.c	2016-04-19 15:29:44.000000000 +0200
@@ -1302,6 +1302,10 @@
   p = &all_small_ipa_passes;
   NEXT_PASS (pass_ipa_free_lang_data);
   NEXT_PASS (pass_ipa_function_and_variable_visibility);
+   /* MPC ADD begin */
+  NEXT_PASS (pass_mpc_warning_global_vars);
+  NEXT_PASS (pass_mpc_warning_thread_mixing);
+  /* MPC ADD end */
   NEXT_PASS (pass_early_local_passes);
     {
       struct opt_pass **p = &pass_early_local_passes.pass.sub;
diff -Naur gcc-4.8.0/gcc/rtl.h mpc-gcc-4.8.0/gcc/rtl.h
--- gcc-4.8.0/gcc/rtl.h	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/rtl.h	2016-04-19 15:29:44.000000000 +0200
@@ -1616,28 +1616,55 @@
 #define SYMBOL_FLAG_SMALL	(1 << 2)
 #define SYMBOL_REF_SMALL_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_SMALL) != 0)
-/* The three-bit field at [5:3] is true for TLS variables; use
+/* MPC HLS BEGIN */
+#if 0
+	/* The three-bit field at [5:3] is true for TLS variables; use
+	   SYMBOL_REF_TLS_MODEL to extract the field as an enum tls_model.  */
+	#define SYMBOL_FLAG_TLS_SHIFT	3
+	#define SYMBOL_REF_TLS_MODEL(RTX) \
+	  ((enum tls_model) ((SYMBOL_REF_FLAGS (RTX) >> SYMBOL_FLAG_TLS_SHIFT) & 7))
+	/* Set if this symbol is not defined in this translation unit.  */
+	#define SYMBOL_FLAG_EXTERNAL	(1 << 6)
+	#define SYMBOL_REF_EXTERNAL_P(RTX) \
+	  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_EXTERNAL) != 0)
+	/* Set if this symbol has a block_symbol structure associated with it.  */
+	#define SYMBOL_FLAG_HAS_BLOCK_INFO (1 << 7)
+	#define SYMBOL_REF_HAS_BLOCK_INFO_P(RTX) \
+	  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_HAS_BLOCK_INFO) != 0)
+	/* Set if this symbol is a section anchor.  SYMBOL_REF_ANCHOR_P implies
+	   SYMBOL_REF_HAS_BLOCK_INFO_P.  */
+	#define SYMBOL_FLAG_ANCHOR	(1 << 8)
+	#define SYMBOL_REF_ANCHOR_P(RTX) \
+	  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_ANCHOR) != 0)
+
+	/* Subsequent bits are available for the target to use.  */
+	#define SYMBOL_FLAG_MACH_DEP_SHIFT	9
+	#define SYMBOL_FLAG_MACH_DEP		(1 << SYMBOL_FLAG_MACH_DEP_SHIFT)
+
+#endif
+/* The three-bit field at [6:3] is true for TLS variables; use
    SYMBOL_REF_TLS_MODEL to extract the field as an enum tls_model.  */
 #define SYMBOL_FLAG_TLS_SHIFT	3
 #define SYMBOL_REF_TLS_MODEL(RTX) \
-  ((enum tls_model) ((SYMBOL_REF_FLAGS (RTX) >> SYMBOL_FLAG_TLS_SHIFT) & 7))
+  ((enum tls_model) ((SYMBOL_REF_FLAGS (RTX) >> SYMBOL_FLAG_TLS_SHIFT) & 15))
 /* Set if this symbol is not defined in this translation unit.  */
-#define SYMBOL_FLAG_EXTERNAL	(1 << 6)
+#define SYMBOL_FLAG_EXTERNAL	(1 << 7)
 #define SYMBOL_REF_EXTERNAL_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_EXTERNAL) != 0)
 /* Set if this symbol has a block_symbol structure associated with it.  */
-#define SYMBOL_FLAG_HAS_BLOCK_INFO (1 << 7)
+#define SYMBOL_FLAG_HAS_BLOCK_INFO (1 << 8)
 #define SYMBOL_REF_HAS_BLOCK_INFO_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_HAS_BLOCK_INFO) != 0)
 /* Set if this symbol is a section anchor.  SYMBOL_REF_ANCHOR_P implies
    SYMBOL_REF_HAS_BLOCK_INFO_P.  */
-#define SYMBOL_FLAG_ANCHOR	(1 << 8)
+#define SYMBOL_FLAG_ANCHOR	(1 << 9)
 #define SYMBOL_REF_ANCHOR_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_ANCHOR) != 0)
 
 /* Subsequent bits are available for the target to use.  */
-#define SYMBOL_FLAG_MACH_DEP_SHIFT	9
+#define SYMBOL_FLAG_MACH_DEP_SHIFT	10
 #define SYMBOL_FLAG_MACH_DEP		(1 << SYMBOL_FLAG_MACH_DEP_SHIFT)
+/* MPC HLS END */
 
 /* If SYMBOL_REF_HAS_BLOCK_INFO_P (RTX), this is the object_block
    structure to which the symbol belongs, or NULL if it has not been
diff -Naur gcc-4.8.0/gcc/tree-pass.h mpc-gcc-4.8.0/gcc/tree-pass.h
--- gcc-4.8.0/gcc/tree-pass.h	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/tree-pass.h	2016-04-19 15:29:44.000000000 +0200
@@ -365,6 +365,12 @@
 extern struct gimple_opt_pass pass_feedback_split_functions;
 extern struct gimple_opt_pass pass_strength_reduction;
 
+/* MPC ADD BEGIN */
+extern struct simple_ipa_opt_pass pass_mpc_warning_global_vars;/* IPA Passes */
+extern struct simple_ipa_opt_pass pass_mpc_warning_thread_mixing;extern struct simple_ipa_opt_pass pass_ipa_lower_emutls;
+extern struct simple_ipa_opt_pass pass_mpc_remove_hls_node;extern struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility;
+/* MPC ADD END */
+
 /* IPA Passes */
 extern struct simple_ipa_opt_pass pass_ipa_lower_emutls;
 extern struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility;
diff -Naur gcc-4.8.0/gcc/tree-profile.c mpc-gcc-4.8.0/gcc/tree-profile.c
--- gcc-4.8.0/gcc/tree-profile.c	2013-01-10 21:38:27.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/tree-profile.c	2016-04-19 15:29:44.000000000 +0200
@@ -565,7 +565,7 @@
 {
  {
   SIMPLE_IPA_PASS,
-  "profile",  		               /* name */
+  "profile",  		               	   /* name */
   OPTGROUP_NONE,                       /* optinfo_flags */
   gate_tree_profile_ipa,               /* gate */
   tree_profiling,                      /* execute */
diff -Naur gcc-4.8.0/gcc/tree.h mpc-gcc-4.8.0/gcc/tree.h
--- gcc-4.8.0/gcc/tree.h	2013-03-09 08:54:02.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/tree.h	2016-04-19 15:29:44.000000000 +0200
@@ -3177,6 +3177,12 @@
    thread-local storage.  */
 #define DECL_THREAD_LOCAL_P(NODE) \
   (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model >= TLS_MODEL_REAL)
+  
+/* MPC BEGIN */
+#define DECL_MPC_THREAD_LOCAL_P(NODE) \
+  (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model >= TLS_MODEL_REAL) && \
+  (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model != TLS_MODEL_MPC_TASK)
+/* MPC END */
 
 /* In a non-local VAR_DECL with static storage duration, true if the
    variable has an initialization priority.  If false, the variable
@@ -3212,7 +3218,12 @@
  ENUM_BITFIELD(symbol_visibility) visibility : 2;
  unsigned visibility_specified : 1;
  /* Belongs to VAR_DECL exclusively.  */
- ENUM_BITFIELD(tls_model) tls_model : 3;
+  /* MPC HLS BEGIN */
+#if 0
+	ENUM_BITFIELD(tls_model) tls_model : 3;
+#endif
+	ENUM_BITFIELD(tls_model) tls_model : 4;
+ /* MPC HLS END */
 
  /* Belong to FUNCTION_DECL exclusively.  */
  unsigned init_priority_p : 1;
diff -Naur gcc-4.8.0/gcc/varasm.c mpc-gcc-4.8.0/gcc/varasm.c
--- gcc-4.8.0/gcc/varasm.c	2013-03-06 09:38:46.000000000 +0100
+++ mpc-gcc-4.8.0/gcc/varasm.c	2016-04-19 15:29:44.000000000 +0200
@@ -5933,7 +5933,7 @@
 {
   enum tls_model kind;
   bool is_local;
-
+  
   is_local = targetm.binds_local_p (decl);
   if (!flag_shlib)
     {
diff -Naur gcc-4.8.0/libgfortran/Makefile.am mpc-gcc-4.8.0/libgfortran/Makefile.am
--- gcc-4.8.0/libgfortran/Makefile.am	2012-03-26 17:16:05.000000000 +0200
+++ mpc-gcc-4.8.0/libgfortran/Makefile.am	2016-04-19 15:29:44.000000000 +0200
@@ -71,6 +71,12 @@
 # Some targets require additional compiler options for IEEE compatibility.
 AM_CFLAGS += $(IEEE_FLAGS)
 
+# Create a temporary lib for build with auto privatization
+gfor_unit_src = \
+io/open.c \
+io/unix.c \
+io/unit.c 
+
 gfor_io_src= \
 io/close.c \
 io/file_pos.c \
@@ -79,13 +85,10 @@
 io/intrinsics.c \
 io/list_read.c \
 io/lock.c \
-io/open.c \
 io/read.c \
 io/size_from_kind.c \
 io/transfer.c \
 io/transfer128.c \
-io/unit.c \
-io/unix.c \
 io/write.c \
 io/fbuf.c
 
@@ -817,6 +820,21 @@
 prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \
     $(gfor_helper_src) $(gfor_io_headers) $(gfor_specific_src)
 
+libgfortranunit_a_SOURCES = $(gfor_unit_src)
+
+# Add libgfortran dirs to system includes in order to avoid auto privatization during build...
+libgfortranunit_a_CFLAGS = \
+-fPIC \
+-fmpc-privatize \
+-isystem $(srcdir) \
+-isystem $(srcdir)/io/ \
+-isystem $(srcdir)/runtime/ \
+-isystem $(srcdir)/config/ \
+-isystem $(srcdir)/caf/ \
+$(AM_CFLAGS)
+
+noinst_LIBRARIES = libgfortranunit.a
+
 if onestep
 # dummy sources for libtool
 BUILT_SOURCES+=libgfortran_c.c libgfortran_f.f90
@@ -842,10 +860,10 @@
 #	$(LTPPFCCOMPILE) -c -o $@ $^ -combine
 
 libgfortran_la_SOURCES = libgfortran_c.c $(filter-out %.c,$(prereq_SRC))
-
+libgfortran_la_LIBADD = libgfortranunit.a
 else
 libgfortran_la_SOURCES = $(prereq_SRC)
-
+libgfortran_la_LIBADD = libgfortranunit.a
 endif
 
 I_M4_DEPS=m4/iparm.m4
diff -Naur gcc-4.8.0/libgfortran/Makefile.in mpc-gcc-4.8.0/libgfortran/Makefile.in
--- gcc-4.8.0/libgfortran/Makefile.in	2013-03-22 11:16:00.000000000 +0100
+++ mpc-gcc-4.8.0/libgfortran/Makefile.in	2016-04-19 15:29:44.000000000 +0200
@@ -16,6 +16,7 @@
 @SET_MAKE@
 
 
+
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
@@ -66,6 +67,15 @@
 CONFIG_HEADER = config.h
 CONFIG_CLEAN_FILES = libgfortran.spec
 CONFIG_CLEAN_VPATH_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+ARFLAGS = cru
+libgfortranunit_a_AR = $(AR) $(ARFLAGS)
+libgfortranunit_a_LIBADD =
+am__objects_1 = libgfortranunit_a-open.$(OBJEXT) \
+	libgfortranunit_a-unix.$(OBJEXT) \
+	libgfortranunit_a-unit.$(OBJEXT)
+am_libgfortranunit_a_OBJECTS = $(am__objects_1)
+libgfortranunit_a_OBJECTS = $(am_libgfortranunit_a_OBJECTS)
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
 am__vpath_adj = case $$p in \
     $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
@@ -101,15 +111,14 @@
 libcaf_single_la_LIBADD =
 am_libcaf_single_la_OBJECTS = single.lo
 libcaf_single_la_OBJECTS = $(am_libcaf_single_la_OBJECTS)
-libgfortran_la_LIBADD =
-am__objects_1 = backtrace.lo bounds.lo compile_options.lo \
+am__objects_2 = backtrace.lo bounds.lo compile_options.lo \
 	convert_char.lo environ.lo error.lo fpu.lo main.lo memory.lo \
 	pause.lo stop.lo string.lo select.lo
-am__objects_2 = all_l1.lo all_l2.lo all_l4.lo all_l8.lo all_l16.lo
-am__objects_3 = any_l1.lo any_l2.lo any_l4.lo any_l8.lo any_l16.lo
-am__objects_4 = count_1_l.lo count_2_l.lo count_4_l.lo count_8_l.lo \
+am__objects_3 = all_l1.lo all_l2.lo all_l4.lo all_l8.lo all_l16.lo
+am__objects_4 = any_l1.lo any_l2.lo any_l4.lo any_l8.lo any_l16.lo
+am__objects_5 = count_1_l.lo count_2_l.lo count_4_l.lo count_8_l.lo \
 	count_16_l.lo
-am__objects_5 = maxloc0_4_i1.lo maxloc0_8_i1.lo maxloc0_16_i1.lo \
+am__objects_6 = maxloc0_4_i1.lo maxloc0_8_i1.lo maxloc0_16_i1.lo \
 	maxloc0_4_i2.lo maxloc0_8_i2.lo maxloc0_16_i2.lo \
 	maxloc0_4_i4.lo maxloc0_8_i4.lo maxloc0_16_i4.lo \
 	maxloc0_4_i8.lo maxloc0_8_i8.lo maxloc0_16_i8.lo \
@@ -118,7 +127,7 @@
 	maxloc0_4_r8.lo maxloc0_8_r8.lo maxloc0_16_r8.lo \
 	maxloc0_4_r10.lo maxloc0_8_r10.lo maxloc0_16_r10.lo \
 	maxloc0_4_r16.lo maxloc0_8_r16.lo maxloc0_16_r16.lo
-am__objects_6 = maxloc1_4_i1.lo maxloc1_8_i1.lo maxloc1_16_i1.lo \
+am__objects_7 = maxloc1_4_i1.lo maxloc1_8_i1.lo maxloc1_16_i1.lo \
 	maxloc1_4_i2.lo maxloc1_8_i2.lo maxloc1_16_i2.lo \
 	maxloc1_4_i4.lo maxloc1_8_i4.lo maxloc1_16_i4.lo \
 	maxloc1_4_i8.lo maxloc1_8_i8.lo maxloc1_16_i8.lo \
@@ -127,10 +136,10 @@
 	maxloc1_4_r8.lo maxloc1_8_r8.lo maxloc1_16_r8.lo \
 	maxloc1_4_r10.lo maxloc1_8_r10.lo maxloc1_16_r10.lo \
 	maxloc1_4_r16.lo maxloc1_8_r16.lo maxloc1_16_r16.lo
-am__objects_7 = maxval_i1.lo maxval_i2.lo maxval_i4.lo maxval_i8.lo \
+am__objects_8 = maxval_i1.lo maxval_i2.lo maxval_i4.lo maxval_i8.lo \
 	maxval_i16.lo maxval_r4.lo maxval_r8.lo maxval_r10.lo \
 	maxval_r16.lo
-am__objects_8 = minloc0_4_i1.lo minloc0_8_i1.lo minloc0_16_i1.lo \
+am__objects_9 = minloc0_4_i1.lo minloc0_8_i1.lo minloc0_16_i1.lo \
 	minloc0_4_i2.lo minloc0_8_i2.lo minloc0_16_i2.lo \
 	minloc0_4_i4.lo minloc0_8_i4.lo minloc0_16_i4.lo \
 	minloc0_4_i8.lo minloc0_8_i8.lo minloc0_16_i8.lo \
@@ -139,7 +148,7 @@
 	minloc0_4_r8.lo minloc0_8_r8.lo minloc0_16_r8.lo \
 	minloc0_4_r10.lo minloc0_8_r10.lo minloc0_16_r10.lo \
 	minloc0_4_r16.lo minloc0_8_r16.lo minloc0_16_r16.lo
-am__objects_9 = minloc1_4_i1.lo minloc1_8_i1.lo minloc1_16_i1.lo \
+am__objects_10 = minloc1_4_i1.lo minloc1_8_i1.lo minloc1_16_i1.lo \
 	minloc1_4_i2.lo minloc1_8_i2.lo minloc1_16_i2.lo \
 	minloc1_4_i4.lo minloc1_8_i4.lo minloc1_16_i4.lo \
 	minloc1_4_i8.lo minloc1_8_i8.lo minloc1_16_i8.lo \
@@ -148,60 +157,60 @@
 	minloc1_4_r8.lo minloc1_8_r8.lo minloc1_16_r8.lo \
 	minloc1_4_r10.lo minloc1_8_r10.lo minloc1_16_r10.lo \
 	minloc1_4_r16.lo minloc1_8_r16.lo minloc1_16_r16.lo
-am__objects_10 = minval_i1.lo minval_i2.lo minval_i4.lo minval_i8.lo \
+am__objects_11 = minval_i1.lo minval_i2.lo minval_i4.lo minval_i8.lo \
 	minval_i16.lo minval_r4.lo minval_r8.lo minval_r10.lo \
 	minval_r16.lo
-am__objects_11 = product_i1.lo product_i2.lo product_i4.lo \
+am__objects_12 = product_i1.lo product_i2.lo product_i4.lo \
 	product_i8.lo product_i16.lo product_r4.lo product_r8.lo \
 	product_r10.lo product_r16.lo product_c4.lo product_c8.lo \
 	product_c10.lo product_c16.lo
-am__objects_12 = sum_i1.lo sum_i2.lo sum_i4.lo sum_i8.lo sum_i16.lo \
+am__objects_13 = sum_i1.lo sum_i2.lo sum_i4.lo sum_i8.lo sum_i16.lo \
 	sum_r4.lo sum_r8.lo sum_r10.lo sum_r16.lo sum_c4.lo sum_c8.lo \
 	sum_c10.lo sum_c16.lo
-am__objects_13 = bessel_r4.lo bessel_r8.lo bessel_r10.lo bessel_r16.lo
-am__objects_14 = iall_i1.lo iall_i2.lo iall_i4.lo iall_i8.lo \
+am__objects_14 = bessel_r4.lo bessel_r8.lo bessel_r10.lo bessel_r16.lo
+am__objects_15 = iall_i1.lo iall_i2.lo iall_i4.lo iall_i8.lo \
 	iall_i16.lo
-am__objects_15 = iany_i1.lo iany_i2.lo iany_i4.lo iany_i8.lo \
+am__objects_16 = iany_i1.lo iany_i2.lo iany_i4.lo iany_i8.lo \
 	iany_i16.lo
-am__objects_16 = iparity_i1.lo iparity_i2.lo iparity_i4.lo \
+am__objects_17 = iparity_i1.lo iparity_i2.lo iparity_i4.lo \
 	iparity_i8.lo iparity_i16.lo
-am__objects_17 = norm2_r4.lo norm2_r8.lo norm2_r10.lo norm2_r16.lo
-am__objects_18 = parity_l1.lo parity_l2.lo parity_l4.lo parity_l8.lo \
+am__objects_18 = norm2_r4.lo norm2_r8.lo norm2_r10.lo norm2_r16.lo
+am__objects_19 = parity_l1.lo parity_l2.lo parity_l4.lo parity_l8.lo \
 	parity_l16.lo
-am__objects_19 = matmul_i1.lo matmul_i2.lo matmul_i4.lo matmul_i8.lo \
+am__objects_20 = matmul_i1.lo matmul_i2.lo matmul_i4.lo matmul_i8.lo \
 	matmul_i16.lo matmul_r4.lo matmul_r8.lo matmul_r10.lo \
 	matmul_r16.lo matmul_c4.lo matmul_c8.lo matmul_c10.lo \
 	matmul_c16.lo
-am__objects_20 = matmul_l4.lo matmul_l8.lo matmul_l16.lo
-am__objects_21 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \
+am__objects_21 = matmul_l4.lo matmul_l8.lo matmul_l16.lo
+am__objects_22 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \
 	transpose_r4.lo transpose_r8.lo transpose_r10.lo \
 	transpose_r16.lo transpose_c4.lo transpose_c8.lo \
 	transpose_c10.lo transpose_c16.lo
-am__objects_22 = shape_i4.lo shape_i8.lo shape_i16.lo
-am__objects_23 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo
-am__objects_24 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo
-am__objects_25 = cshift1_4.lo cshift1_8.lo cshift1_16.lo
-am__objects_26 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \
+am__objects_23 = shape_i4.lo shape_i8.lo shape_i16.lo
+am__objects_24 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo
+am__objects_25 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo
+am__objects_26 = cshift1_4.lo cshift1_8.lo cshift1_16.lo
+am__objects_27 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \
 	reshape_r4.lo reshape_r8.lo reshape_r10.lo reshape_r16.lo \
 	reshape_c4.lo reshape_c8.lo reshape_c10.lo reshape_c16.lo
-am__objects_27 = in_pack_i1.lo in_pack_i2.lo in_pack_i4.lo \
+am__objects_28 = in_pack_i1.lo in_pack_i2.lo in_pack_i4.lo \
 	in_pack_i8.lo in_pack_i16.lo in_pack_r4.lo in_pack_r8.lo \
 	in_pack_r10.lo in_pack_r16.lo in_pack_c4.lo in_pack_c8.lo \
 	in_pack_c10.lo in_pack_c16.lo
-am__objects_28 = in_unpack_i1.lo in_unpack_i2.lo in_unpack_i4.lo \
+am__objects_29 = in_unpack_i1.lo in_unpack_i2.lo in_unpack_i4.lo \
 	in_unpack_i8.lo in_unpack_i16.lo in_unpack_r4.lo \
 	in_unpack_r8.lo in_unpack_r10.lo in_unpack_r16.lo \
 	in_unpack_c4.lo in_unpack_c8.lo in_unpack_c10.lo \
 	in_unpack_c16.lo
-am__objects_29 = exponent_r4.lo exponent_r8.lo exponent_r10.lo \
+am__objects_30 = exponent_r4.lo exponent_r8.lo exponent_r10.lo \
 	exponent_r16.lo
-am__objects_30 = fraction_r4.lo fraction_r8.lo fraction_r10.lo \
+am__objects_31 = fraction_r4.lo fraction_r8.lo fraction_r10.lo \
 	fraction_r16.lo
-am__objects_31 = nearest_r4.lo nearest_r8.lo nearest_r10.lo \
+am__objects_32 = nearest_r4.lo nearest_r8.lo nearest_r10.lo \
 	nearest_r16.lo
-am__objects_32 = set_exponent_r4.lo set_exponent_r8.lo \
+am__objects_33 = set_exponent_r4.lo set_exponent_r8.lo \
 	set_exponent_r10.lo set_exponent_r16.lo
-am__objects_33 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_r16_i4.lo \
+am__objects_34 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_r16_i4.lo \
 	pow_c4_i4.lo pow_c8_i4.lo pow_c10_i4.lo pow_c16_i4.lo \
 	pow_i4_i8.lo pow_i8_i8.lo pow_i16_i8.lo pow_r4_i8.lo \
 	pow_r8_i8.lo pow_r10_i8.lo pow_r16_i8.lo pow_c4_i8.lo \
@@ -209,43 +218,42 @@
 	pow_i8_i16.lo pow_i16_i16.lo pow_r4_i16.lo pow_r8_i16.lo \
 	pow_r10_i16.lo pow_r16_i16.lo pow_c4_i16.lo pow_c8_i16.lo \
 	pow_c10_i16.lo pow_c16_i16.lo
-am__objects_34 = rrspacing_r4.lo rrspacing_r8.lo rrspacing_r10.lo \
+am__objects_35 = rrspacing_r4.lo rrspacing_r8.lo rrspacing_r10.lo \
 	rrspacing_r16.lo
-am__objects_35 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \
+am__objects_36 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \
 	spacing_r16.lo
-am__objects_36 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \
+am__objects_37 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \
 	pack_i16.lo pack_r4.lo pack_r8.lo pack_r10.lo pack_r16.lo \
 	pack_c4.lo pack_c8.lo pack_c10.lo pack_c16.lo
-am__objects_37 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \
+am__objects_38 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \
 	unpack_i16.lo unpack_r4.lo unpack_r8.lo unpack_r10.lo \
 	unpack_r16.lo unpack_c4.lo unpack_c8.lo unpack_c10.lo \
 	unpack_c16.lo
-am__objects_38 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \
+am__objects_39 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \
 	spread_i16.lo spread_r4.lo spread_r8.lo spread_r10.lo \
 	spread_r16.lo spread_c4.lo spread_c8.lo spread_c10.lo \
 	spread_c16.lo
-am__objects_39 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \
+am__objects_40 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \
 	cshift0_i8.lo cshift0_i16.lo cshift0_r4.lo cshift0_r8.lo \
 	cshift0_r10.lo cshift0_r16.lo cshift0_c4.lo cshift0_c8.lo \
 	cshift0_c10.lo cshift0_c16.lo
-am__objects_40 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \
-	$(am__objects_5) $(am__objects_6) $(am__objects_7) \
-	$(am__objects_8) $(am__objects_9) $(am__objects_10) \
-	$(am__objects_11) $(am__objects_12) $(am__objects_13) \
-	$(am__objects_14) $(am__objects_15) $(am__objects_16) \
-	$(am__objects_17) $(am__objects_18) $(am__objects_19) \
-	$(am__objects_20) $(am__objects_21) $(am__objects_22) \
-	$(am__objects_23) $(am__objects_24) $(am__objects_25) \
-	$(am__objects_26) $(am__objects_27) $(am__objects_28) \
-	$(am__objects_29) $(am__objects_30) $(am__objects_31) \
-	$(am__objects_32) $(am__objects_33) $(am__objects_34) \
-	$(am__objects_35) $(am__objects_36) $(am__objects_37) \
-	$(am__objects_38) $(am__objects_39)
-am__objects_41 = close.lo file_pos.lo format.lo inquire.lo \
-	intrinsics.lo list_read.lo lock.lo open.lo read.lo \
-	size_from_kind.lo transfer.lo transfer128.lo unit.lo unix.lo \
-	write.lo fbuf.lo
-am__objects_42 = associated.lo abort.lo access.lo args.lo \
+am__objects_41 = $(am__objects_3) $(am__objects_4) $(am__objects_5) \
+	$(am__objects_6) $(am__objects_7) $(am__objects_8) \
+	$(am__objects_9) $(am__objects_10) $(am__objects_11) \
+	$(am__objects_12) $(am__objects_13) $(am__objects_14) \
+	$(am__objects_15) $(am__objects_16) $(am__objects_17) \
+	$(am__objects_18) $(am__objects_19) $(am__objects_20) \
+	$(am__objects_21) $(am__objects_22) $(am__objects_23) \
+	$(am__objects_24) $(am__objects_25) $(am__objects_26) \
+	$(am__objects_27) $(am__objects_28) $(am__objects_29) \
+	$(am__objects_30) $(am__objects_31) $(am__objects_32) \
+	$(am__objects_33) $(am__objects_34) $(am__objects_35) \
+	$(am__objects_36) $(am__objects_37) $(am__objects_38) \
+	$(am__objects_39) $(am__objects_40)
+am__objects_42 = close.lo file_pos.lo format.lo inquire.lo \
+	intrinsics.lo list_read.lo lock.lo read.lo size_from_kind.lo \
+	transfer.lo transfer128.lo write.lo fbuf.lo
+am__objects_43 = associated.lo abort.lo access.lo args.lo \
 	bit_intrinsics.lo c99_functions.lo chdir.lo chmod.lo clock.lo \
 	cpu_time.lo cshift0.lo ctime.lo date_and_time.lo dtime.lo \
 	env.lo eoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo \
@@ -260,8 +268,8 @@
 	system_clock.lo time.lo transpose_generic.lo umask.lo \
 	unlink.lo unpack_generic.lo in_pack_generic.lo \
 	in_unpack_generic.lo
-am__objects_43 =
-am__objects_44 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \
+am__objects_44 =
+am__objects_45 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \
 	_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \
 	_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \
 	_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \
@@ -285,18 +293,18 @@
 	_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \
 	_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \
 	_anint_r8.lo _anint_r10.lo _anint_r16.lo
-am__objects_45 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \
+am__objects_46 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \
 	_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \
 	_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \
 	_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \
 	_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \
 	_mod_r10.lo _mod_r16.lo
-am__objects_46 = misc_specifics.lo
-am__objects_47 = $(am__objects_44) $(am__objects_45) $(am__objects_46) \
+am__objects_47 = misc_specifics.lo
+am__objects_48 = $(am__objects_45) $(am__objects_46) $(am__objects_47) \
 	dprod_r8.lo f2c_specifics.lo
-am__objects_48 = $(am__objects_1) $(am__objects_40) $(am__objects_41) \
-	$(am__objects_42) $(am__objects_43) $(am__objects_47)
-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_48)
+am__objects_49 = $(am__objects_2) $(am__objects_41) $(am__objects_42) \
+	$(am__objects_43) $(am__objects_44) $(am__objects_48)
+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_49)
 @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo
 libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)
 libgfortranbegin_la_LIBADD =
@@ -327,8 +335,8 @@
 FCCOMPILE = $(FC) $(AM_FCFLAGS) $(FCFLAGS)
 LTFCCOMPILE = $(LIBTOOL) --tag=FC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=compile $(FC) $(AM_FCFLAGS) $(FCFLAGS)
-SOURCES = $(libcaf_single_la_SOURCES) $(libgfortran_la_SOURCES) \
-	$(libgfortranbegin_la_SOURCES)
+SOURCES = $(libgfortranunit_a_SOURCES) $(libcaf_single_la_SOURCES) \
+	$(libgfortran_la_SOURCES) $(libgfortranbegin_la_SOURCES)
 MULTISRCTOP = 
 MULTIBUILDTOP = 
 MULTIDIRS = 
@@ -522,6 +530,13 @@
 	      -I$(srcdir)/$(MULTISRCTOP)../libgcc \
 	      -I$(MULTIBUILDTOP)../libgcc
 
+
+# Create a temporary lib for build with auto privatization
+gfor_unit_src = \
+io/open.c \
+io/unix.c \
+io/unit.c 
+
 gfor_io_src = \
 io/close.c \
 io/file_pos.c \
@@ -530,13 +545,10 @@
 io/intrinsics.c \
 io/list_read.c \
 io/lock.c \
-io/open.c \
 io/read.c \
 io/size_from_kind.c \
 io/transfer.c \
 io/transfer128.c \
-io/unit.c \
-io/unix.c \
 io/write.c \
 io/fbuf.c
 
@@ -1258,6 +1270,20 @@
 prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \
     $(gfor_helper_src) $(gfor_io_headers) $(gfor_specific_src)
 
+libgfortranunit_a_SOURCES = $(gfor_unit_src)
+
+# Add libgfortran dirs to system includes in order to avoid auto privatization during build...
+libgfortranunit_a_CFLAGS = \
+-fPIC \
+-fmpc-privatize \
+-isystem $(srcdir) \
+-isystem $(srcdir)/io/ \
+-isystem $(srcdir)/runtime/ \
+-isystem $(srcdir)/config/ \
+-isystem $(srcdir)/caf/ \
+$(AM_CFLAGS)
+
+noinst_LIBRARIES = libgfortranunit.a
 @onestep_FALSE@libgfortran_la_SOURCES = $(prereq_SRC)
 
 #libgfortran_f.o: $(filter %.f %.f90,$(prereq_SRC))
@@ -1272,6 +1298,8 @@
 #libgfortran_F.lo: 
 #	$(LTPPFCCOMPILE) -c -o $@ $^ -combine
 @onestep_TRUE@libgfortran_la_SOURCES = libgfortran_c.c $(filter-out %.c,$(prereq_SRC))
+@onestep_FALSE@libgfortran_la_LIBADD = libgfortranunit.a
+@onestep_TRUE@libgfortran_la_LIBADD = libgfortranunit.a
 I_M4_DEPS = m4/iparm.m4
 I_M4_DEPS0 = $(I_M4_DEPS) m4/iforeach.m4
 I_M4_DEPS1 = $(I_M4_DEPS) m4/ifunction.m4
@@ -1333,6 +1361,13 @@
 	-rm -f config.h stamp-h1
 libgfortran.spec: $(top_builddir)/config.status $(srcdir)/libgfortran.spec.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libgfortranunit.a: $(libgfortranunit_a_OBJECTS) $(libgfortranunit_a_DEPENDENCIES) $(EXTRA_libgfortranunit_a_DEPENDENCIES) 
+	-rm -f libgfortranunit.a
+	$(libgfortranunit_a_AR) libgfortranunit.a $(libgfortranunit_a_OBJECTS) $(libgfortranunit_a_LIBADD)
+	$(RANLIB) libgfortranunit.a
 install-cafexeclibLTLIBRARIES: $(cafexeclib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
 	test -z "$(cafexeclibdir)" || $(MKDIR_P) "$(DESTDIR)$(cafexeclibdir)"
@@ -1579,6 +1614,9 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iso_c_generated_procs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/kill.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortran_c.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortranunit_a-open.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortranunit_a-unit.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortranunit_a-unix.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/link.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/list_read.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock.Plo@am__quote@
@@ -1737,7 +1775,6 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/norm2_r16.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/norm2_r4.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/norm2_r8.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/open.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c10.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c16.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c4.Plo@am__quote@
@@ -1891,8 +1928,6 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transpose_r4.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transpose_r8.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/umask.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unit.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unix.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unlink.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_c10.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_c16.Plo@am__quote@
@@ -2354,6 +2389,48 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
 
+libgfortranunit_a-open.o: io/open.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-open.o -MD -MP -MF $(DEPDIR)/libgfortranunit_a-open.Tpo -c -o libgfortranunit_a-open.o `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-open.Tpo $(DEPDIR)/libgfortranunit_a-open.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/open.c' object='libgfortranunit_a-open.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-open.o `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
+
+libgfortranunit_a-open.obj: io/open.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-open.obj -MD -MP -MF $(DEPDIR)/libgfortranunit_a-open.Tpo -c -o libgfortranunit_a-open.obj `if test -f 'io/open.c'; then $(CYGPATH_W) 'io/open.c'; else $(CYGPATH_W) '$(srcdir)/io/open.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-open.Tpo $(DEPDIR)/libgfortranunit_a-open.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/open.c' object='libgfortranunit_a-open.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-open.obj `if test -f 'io/open.c'; then $(CYGPATH_W) 'io/open.c'; else $(CYGPATH_W) '$(srcdir)/io/open.c'; fi`
+
+libgfortranunit_a-unix.o: io/unix.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unix.o -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unix.Tpo -c -o libgfortranunit_a-unix.o `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unix.Tpo $(DEPDIR)/libgfortranunit_a-unix.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unix.c' object='libgfortranunit_a-unix.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unix.o `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
+
+libgfortranunit_a-unix.obj: io/unix.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unix.obj -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unix.Tpo -c -o libgfortranunit_a-unix.obj `if test -f 'io/unix.c'; then $(CYGPATH_W) 'io/unix.c'; else $(CYGPATH_W) '$(srcdir)/io/unix.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unix.Tpo $(DEPDIR)/libgfortranunit_a-unix.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unix.c' object='libgfortranunit_a-unix.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unix.obj `if test -f 'io/unix.c'; then $(CYGPATH_W) 'io/unix.c'; else $(CYGPATH_W) '$(srcdir)/io/unix.c'; fi`
+
+libgfortranunit_a-unit.o: io/unit.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unit.o -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unit.Tpo -c -o libgfortranunit_a-unit.o `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unit.Tpo $(DEPDIR)/libgfortranunit_a-unit.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unit.c' object='libgfortranunit_a-unit.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unit.o `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
+
+libgfortranunit_a-unit.obj: io/unit.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unit.obj -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unit.Tpo -c -o libgfortranunit_a-unit.obj `if test -f 'io/unit.c'; then $(CYGPATH_W) 'io/unit.c'; else $(CYGPATH_W) '$(srcdir)/io/unit.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unit.Tpo $(DEPDIR)/libgfortranunit_a-unit.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unit.c' object='libgfortranunit_a-unit.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unit.obj `if test -f 'io/unit.c'; then $(CYGPATH_W) 'io/unit.c'; else $(CYGPATH_W) '$(srcdir)/io/unit.c'; fi`
+
 single.lo: caf/single.c
 @am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT single.lo -MD -MP -MF $(DEPDIR)/single.Tpo -c -o single.lo `test -f 'caf/single.c' || echo '$(srcdir)/'`caf/single.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/single.Tpo $(DEPDIR)/single.Plo
@@ -5140,13 +5217,6 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o lock.lo `test -f 'io/lock.c' || echo '$(srcdir)/'`io/lock.c
 
-open.lo: io/open.c
-@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT open.lo -MD -MP -MF $(DEPDIR)/open.Tpo -c -o open.lo `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/open.Tpo $(DEPDIR)/open.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/open.c' object='open.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o open.lo `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
-
 read.lo: io/read.c
 @am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT read.lo -MD -MP -MF $(DEPDIR)/read.Tpo -c -o read.lo `test -f 'io/read.c' || echo '$(srcdir)/'`io/read.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/read.Tpo $(DEPDIR)/read.Plo
@@ -5175,20 +5245,6 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o transfer128.lo `test -f 'io/transfer128.c' || echo '$(srcdir)/'`io/transfer128.c
 
-unit.lo: io/unit.c
-@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unit.lo -MD -MP -MF $(DEPDIR)/unit.Tpo -c -o unit.lo `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/unit.Tpo $(DEPDIR)/unit.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unit.c' object='unit.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unit.lo `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
-
-unix.lo: io/unix.c
-@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unix.lo -MD -MP -MF $(DEPDIR)/unix.Tpo -c -o unix.lo `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/unix.Tpo $(DEPDIR)/unix.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unix.c' object='unix.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unix.lo `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
-
 write.lo: io/write.c
 @am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT write.lo -MD -MP -MF $(DEPDIR)/write.Tpo -c -o write.lo `test -f 'io/write.c' || echo '$(srcdir)/'`io/write.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/write.Tpo $(DEPDIR)/write.Plo
@@ -5746,7 +5802,8 @@
 check-am: all-am
 check: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) check-am
-all-am: Makefile $(LTLIBRARIES) all-multi $(DATA) config.h
+all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \
+		config.h
 installdirs:
 	for dir in "$(DESTDIR)$(cafexeclibdir)" "$(DESTDIR)$(myexeclibdir)" "$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(toolexeclibdir)"; do \
 	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
@@ -5786,8 +5843,8 @@
 clean: clean-am clean-multi
 
 clean-am: clean-cafexeclibLTLIBRARIES clean-generic clean-libtool \
-	clean-myexeclibLTLIBRARIES clean-toolexeclibLTLIBRARIES \
-	mostlyclean-am
+	clean-myexeclibLTLIBRARIES clean-noinstLIBRARIES \
+	clean-toolexeclibLTLIBRARIES mostlyclean-am
 
 distclean: distclean-am distclean-multi
 	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
@@ -5868,7 +5925,7 @@
 
 .PHONY: CTAGS GTAGS all all-am all-multi am--refresh check check-am \
 	clean clean-cafexeclibLTLIBRARIES clean-generic clean-libtool \
-	clean-multi clean-myexeclibLTLIBRARIES \
+	clean-multi clean-myexeclibLTLIBRARIES clean-noinstLIBRARIES \
 	clean-toolexeclibLTLIBRARIES ctags distclean distclean-compile \
 	distclean-generic distclean-hdr distclean-libtool \
 	distclean-multi distclean-tags dvi dvi-am html html-am info \
diff -Naur gcc-4.8.0/libgfortran/gfortran.map mpc-gcc-4.8.0/libgfortran/gfortran.map
--- gcc-4.8.0/libgfortran/gfortran.map	2012-12-20 19:15:13.000000000 +0100
+++ mpc-gcc-4.8.0/libgfortran/gfortran.map	2016-04-19 15:29:44.000000000 +0200
@@ -30,6 +30,7 @@
     _gfortran_chmod_func;
     _gfortran_chmod_i4_sub;
     _gfortran_chmod_i8_sub;
+    _gfortran_close_units;
     _gfortran_compare_string;
     _gfortran_concat_string;
     _gfortran_count_1_l;
@@ -165,6 +166,7 @@
     _gfortran_idate_i8;
     _gfortran_ierrno_i4;
     _gfortran_ierrno_i8;
+    _gfortran_init_units;
     _gfortran_internal_pack;
     _gfortran_internal_unpack;
     _gfortran_irand;
@@ -1027,6 +1029,7 @@
     __iso_c_binding_c_f_pointer_l4;
     __iso_c_binding_c_f_pointer_l8;
     __iso_c_binding_c_f_pointer_u0;
+    __sctk__tls_get_addr__task_scope;
   local:
     *;
 };
diff -Naur gcc-4.8.0/libgfortran/io/unit.c mpc-gcc-4.8.0/libgfortran/io/unit.c
--- gcc-4.8.0/libgfortran/io/unit.c	2013-01-14 19:20:58.000000000 +0100
+++ mpc-gcc-4.8.0/libgfortran/io/unit.c	2016-04-19 15:29:44.000000000 +0200
@@ -27,6 +27,7 @@
 #include "fbuf.h"
 #include "format.h"
 #include "unix.h"
+#include "libgfortran.h"
 #include <stdlib.h>
 #include <string.h>
 
@@ -638,6 +639,7 @@
   for (i = 0; i < sizeof (max_offset) * 8 - 1; i++)
     max_offset = max_offset + ((gfc_offset) 1 << i);
 }
+iexport(init_units);
 
 
 static int
@@ -716,6 +718,7 @@
     close_unit_1 (unit_root, 1);
   __gthread_mutex_unlock (&unit_lock);
 }
+iexport(close_units);
 
 
 /* High level interface to truncate a file, i.e. flush format buffers,
@@ -836,3 +839,16 @@
     }
   return num;
 }
+
+/* Just a fake __sctk__tls_get_addr__task_scope to allow MPC to test the compiler during configuration */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+void * __attribute__ ((weak))
+__sctk__tls_get_addr__task_scope (tls_index * tmp)
+{
+    return NULL;
+}
diff -Naur gcc-4.8.0/libgfortran/libgfortran.h mpc-gcc-4.8.0/libgfortran/libgfortran.h
--- gcc-4.8.0/libgfortran/libgfortran.h	2013-01-14 19:20:58.000000000 +0100
+++ mpc-gcc-4.8.0/libgfortran/libgfortran.h	2016-04-19 15:29:44.000000000 +0200
@@ -813,10 +813,10 @@
 /* io.c */
 
 extern void init_units (void);
-internal_proto(init_units);
+iexport_proto(init_units);
 
 extern void close_units (void);
-internal_proto(close_units);
+iexport_proto(close_units);
 
 extern int unit_to_fd (int);
 internal_proto(unit_to_fd);
diff -Naur gcc-4.8.0/libgfortran/runtime/main.c mpc-gcc-4.8.0/libgfortran/runtime/main.c
--- gcc-4.8.0/libgfortran/runtime/main.c	2013-01-14 19:20:58.000000000 +0100
+++ mpc-gcc-4.8.0/libgfortran/runtime/main.c	2016-04-19 15:29:44.000000000 +0200
@@ -221,8 +221,9 @@
 
   /* Must be first */
   init_variables ();
-
-  init_units ();
+  
+  //Deported to mpc with TLS context
+  //init_units ();
   set_fpu ();
   init_compile_options ();
 
@@ -247,7 +248,8 @@
 static void __attribute__((destructor))
 cleanup (void)
 {
-  close_units ();
+  //Deported to mpc with TLS context
+  //close_units ();
   
   if (please_free_exe_path_when_done)
     free ((char *) exe_path);
