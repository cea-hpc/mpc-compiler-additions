diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 6c5adc0bb..18867502e 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -899,7 +899,7 @@ RTL_H = $(RTL_BASE_H) $(FLAGS_H) genrtl.h
 READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h
 PARAMS_H = params.h params-enum.h params.def
 BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def \
-	gtm-builtins.def sanitizer.def cilkplus.def cilk-builtins.def
+	gtm-builtins.def sanitizer.def cilkplus.def cilk-builtins.def hls-builtins.def
 INTERNAL_FN_DEF = internal-fn.def
 INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)
 TREE_CORE_H = tree-core.h coretypes.h all-tree.def tree.def \
@@ -1368,6 +1368,7 @@ OBJS = \
 	mode-switching.o \
 	modulo-sched.o \
 	multiple_target.o \
+	mpc-pass.o \
 	omp-low.o \
 	omp-simd-clone.o \
 	optabs.o \
@@ -2082,6 +2083,11 @@ version.o: $(REVISION) $(DATESTAMP) $(BASEVER) $(DEVPHASE)
 
 # lto-compress.o needs $(ZLIBINC) added to the include flags.
 CFLAGS-lto-compress.o += $(ZLIBINC)
+mpc-pass.o : mpc-pass.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
+   $(RTL_H) $(GIMPLE_H) $(TREE_INLINE_H) langhooks.h $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TIMEVAR_H) $(FLAGS_H) $(EXPR_H) $(TOPLEV_H) tree-pass.h \
+   $(GGC_H) except.h $(SPLAY_TREE_H) $(OPTABS_H) $(CFGLOOP_H) \
+   tree-iterator.h
 
 bversion.h: s-bversion; @true
 s-bversion: BASE-VER
@@ -2394,6 +2400,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \
   $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \
   $(srcdir)/omp-low.c \
   $(srcdir)/omp-low.h \
+  $(srcdir)/mpc-pass.c \
   $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \
   $(srcdir)/cgraphclones.c \
   $(srcdir)/tree-phinodes.c \
diff --git a/gcc/builtin-types.def b/gcc/builtin-types.def
index 7fab9f831..64d3a7713 100644
--- a/gcc/builtin-types.def
+++ b/gcc/builtin-types.def
@@ -229,6 +229,7 @@ DEF_FUNCTION_TYPE_1 (BT_FN_UINT16_UINT16, BT_UINT16, BT_UINT16)
 DEF_FUNCTION_TYPE_1 (BT_FN_UINT32_UINT32, BT_UINT32, BT_UINT32)
 DEF_FUNCTION_TYPE_1 (BT_FN_UINT64_UINT64, BT_UINT64, BT_UINT64)
 DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)
+
 DEF_FUNCTION_TYPE_1 (BT_FN_PTR_CONST_PTR, BT_PTR, BT_CONST_PTR)
 DEF_FUNCTION_TYPE_1 (BT_FN_CONST_PTR_CONST_PTR, BT_CONST_PTR, BT_CONST_PTR)
 DEF_FUNCTION_TYPE_1 (BT_FN_BND_CONST_PTR, BT_BND, BT_CONST_PTR)
@@ -435,7 +436,6 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I2_INT, BT_VOID, BT_VOLATILE_PTR, BT_I2, BT
 DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I4_INT, BT_VOID, BT_VOLATILE_PTR, BT_I4, BT_INT)
 DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I8_INT, BT_VOID, BT_VOLATILE_PTR, BT_I8, BT_INT)
 DEF_FUNCTION_TYPE_3 (BT_FN_VOID_VPTR_I16_INT, BT_VOID, BT_VOLATILE_PTR, BT_I16, BT_INT)
-DEF_FUNCTION_TYPE_3 (BT_FN_INT_PTRPTR_SIZE_SIZE, BT_INT, BT_PTR_PTR, BT_SIZE, BT_SIZE)
 DEF_FUNCTION_TYPE_3 (BT_FN_PTR_CONST_PTR_CONST_PTR_SIZE, BT_PTR, BT_CONST_PTR, BT_CONST_PTR, BT_SIZE)
 DEF_FUNCTION_TYPE_3 (BT_FN_VOID_CONST_PTR_BND_CONST_PTR, BT_VOID, BT_CONST_PTR, BT_BND, BT_CONST_PTR)
 DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_INT_INT_INTPTR, BT_BOOL, BT_INT, BT_INT,
@@ -557,6 +557,7 @@ DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR_INT,
 		     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,
 		     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,
 		     BT_BOOL, BT_UINT, BT_PTR, BT_INT)
+
 DEF_FUNCTION_TYPE_9 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_UINT_PTR_PTR,
 		     BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE, BT_PTR,
 		     BT_PTR, BT_PTR, BT_UINT, BT_PTR, BT_PTR)
diff --git a/gcc/builtins.def b/gcc/builtins.def
index 2fc7f65d9..7e23bc717 100644
--- a/gcc/builtins.def
+++ b/gcc/builtins.def
@@ -195,6 +195,17 @@ along with GCC; see the file COPYING3.  If not see
   DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, BT_LAST, BT_LAST, false, false, \
 	       false, ATTR_LAST, false, false)
 
+/* MPC OMP BEGIN */
+/* Builtin used by the implementation of MPC OpenMP.  None of these are
+   actually implemented in the compiler; they're all in the MPC library.  */
+#undef DEF_MPC_BUILTIN
+#define DEF_MPC_BUILTIN(ENUM, NAME, TYPE, ATTRS) \
+  DEF_BUILTIN (ENUM, "__builtin_" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \
+               false, true, true, ATTRS, false, \
+	       (flag_openmp || flag_tree_parallelize_loops \
+		|| flag_offload_abi != OFFLOAD_ABI_UNSET))
+/* MPC OMP END */
+
 /* Builtin used by the implementation of GNU TM.  These
    functions are mapped to the actual implementation of the STM library. */
 #undef DEF_TM_BUILTIN
@@ -828,7 +839,7 @@ DEF_GCC_BUILTIN        (BUILT_IN_POPCOUNT, "popcount", BT_FN_INT_UINT, ATTR_CONS
 DEF_GCC_BUILTIN        (BUILT_IN_POPCOUNTIMAX, "popcountimax", BT_FN_INT_UINTMAX, ATTR_CONST_NOTHROW_LEAF_LIST)
 DEF_GCC_BUILTIN        (BUILT_IN_POPCOUNTL, "popcountl", BT_FN_INT_ULONG, ATTR_CONST_NOTHROW_LEAF_LIST)
 DEF_GCC_BUILTIN        (BUILT_IN_POPCOUNTLL, "popcountll", BT_FN_INT_ULONGLONG, ATTR_CONST_NOTHROW_LEAF_LIST)
-DEF_EXT_LIB_BUILTIN    (BUILT_IN_POSIX_MEMALIGN, "posix_memalign", BT_FN_INT_PTRPTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)
+DEF_EXT_LIB_BUILTIN    (BUILT_IN_POSIX_MEMALIGN, "posix_memalign", BT_FN_INT_PTR, ATTR_NOTHROW_NONNULL_LEAF)
 DEF_GCC_BUILTIN        (BUILT_IN_PREFETCH, "prefetch", BT_FN_VOID_CONST_PTR_VAR, ATTR_NOVOPS_LEAF_LIST)
 DEF_LIB_BUILTIN        (BUILT_IN_REALLOC, "realloc", BT_FN_PTR_PTR_SIZE, ATTR_NOTHROW_LEAF_LIST)
 DEF_GCC_BUILTIN        (BUILT_IN_RETURN, "return", BT_FN_VOID_PTR, ATTR_NORETURN_NOTHROW_LEAF_LIST)
@@ -932,6 +943,10 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, "LINE", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)
 /* Offloading and Multi Processing builtins.  */
 #include "omp-builtins.def"
 
+/* MPC HLS BEGIN */
+#include "hls-builtins.def"
+/* MPC HLS END */
+
 /* Cilk keywords builtins.  */
 #include "cilk-builtins.def"
 
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index f2846bb26..3f6efee67 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -504,6 +504,12 @@ const struct c_common_resword c_common_reswords[] =
   { "__signed",		RID_SIGNED,	0 },
   { "__signed__",	RID_SIGNED,	0 },
   { "__thread",		RID_THREAD,	0 },
+  /* MPC begin */
+  { "__task",		RID_TASK,	0 },
+  { "__process",		RID_PROCESS,	0 },
+  { "__openmp",		RID_OPENMP,	0 },
+ 
+  /* MPC end */
   { "__transaction_atomic", RID_TRANSACTION_ATOMIC, 0 },
   { "__transaction_relaxed", RID_TRANSACTION_RELAXED, 0 },
   { "__transaction_cancel", RID_TRANSACTION_CANCEL, 0 },
@@ -572,6 +578,9 @@ const struct c_common_resword c_common_reswords[] =
   { "template",		RID_TEMPLATE,	D_CXXONLY | D_CXXWARN },
   { "this",		RID_THIS,	D_CXXONLY | D_CXXWARN },
   { "thread_local",	RID_THREAD,	D_CXXONLY | D_CXX11 | D_CXXWARN },
+  { "process_local",	RID_PROCESS,	D_CXXONLY | D_CXX11 | D_CXXWARN },
+  { "task_local",	RID_TASK,	D_CXXONLY | D_CXX11 | D_CXXWARN },
+  { "openmp_local",	RID_OPENMP,	D_CXXONLY | D_CXX11 | D_CXXWARN },
   { "throw",		RID_THROW,	D_CXX_OBJC | D_CXXWARN },
   { "true",		RID_TRUE,	D_CXXONLY | D_CXXWARN },
   { "try",		RID_TRY,	D_CXX_OBJC | D_CXXWARN },
@@ -12376,6 +12385,11 @@ keyword_is_storage_class_specifier (enum rid keyword)
     case RID_AUTO:
     case RID_MUTABLE:
     case RID_THREAD:
+		/* MPC TLS BEGIN */
+	case RID_PROCESS:
+	case RID_TASK:
+	case RID_OPENMP:
+		/* MPC TLS END */
       return true;
     default:
       return false;
diff --git a/gcc/c-family/c-common.h b/gcc/c-family/c-common.h
index dd74d0dd6..2b88ce1b0 100644
--- a/gcc/c-family/c-common.h
+++ b/gcc/c-family/c-common.h
@@ -69,6 +69,9 @@ enum rid
   RID_VOLATILE, RID_SIGNED,  RID_AUTO,  RID_RESTRICT,
   RID_NORETURN, RID_ATOMIC,
 
+  /* MPC Extension */
+  RID_PROCESS, RID_TASK,RID_OPENMP,
+
   /* C extensions */
   RID_COMPLEX, RID_THREAD, RID_SAT,
 
diff --git a/gcc/c-family/c-cppbuiltin.c b/gcc/c-family/c-cppbuiltin.c
index 3d4587e6d..9d52adf77 100644
--- a/gcc/c-family/c-cppbuiltin.c
+++ b/gcc/c-family/c-cppbuiltin.c
@@ -1227,11 +1227,10 @@ c_cpp_builtins (cpp_reader *pfile)
   else if (flag_stack_protect == 1)
     cpp_define (pfile, "__SSP__=1");
 
-  if (flag_openacc)
+ if (flag_openacc)
     cpp_define (pfile, "_OPENACC=201306");
-
-  if (flag_openmp)
-    cpp_define (pfile, "_OPENMP=201511");
+ if (flag_openmp)
+    cpp_define (pfile, "_OPENMP=201107");
 
   for (i = 0; i < NUM_INT_N_ENTS; i ++)
     if (int_n_enabled_p[i])
diff --git a/gcc/c-family/c-omp.c b/gcc/c-family/c-omp.c
index 1691c40f1..f5d4f61ef 100644
--- a/gcc/c-family/c-omp.c
+++ b/gcc/c-family/c-omp.c
@@ -131,6 +131,7 @@ c_finish_omp_barrier (location_t loc)
   tree x;
 
   x = builtin_decl_explicit (BUILT_IN_GOMP_BARRIER);
+  /* MPC OMP end */
   x = build_call_expr_loc (loc, x, 0);
   add_stmt (x);
 }
@@ -143,7 +144,7 @@ void
 c_finish_omp_taskwait (location_t loc)
 {
   tree x;
-
+ 
   x = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);
   x = build_call_expr_loc (loc, x, 0);
   add_stmt (x);
@@ -157,8 +158,8 @@ void
 c_finish_omp_taskyield (location_t loc)
 {
   tree x;
-
-  x = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD);
+  	
+  x = builtin_decl_explicit (BUILT_IN_GOMP_TASKYIELD); 
   x = build_call_expr_loc (loc, x, 0);
   add_stmt (x);
 }
diff --git a/gcc/c-family/c-opts.c b/gcc/c-family/c-opts.c
index fec58bcf9..45c85a6b5 100644
--- a/gcc/c-family/c-opts.c
+++ b/gcc/c-family/c-opts.c
@@ -40,6 +40,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "mkdeps.h"
 #include "dumpfile.h"
 
+#include <sys/time.h>
+
 #ifndef DOLLARS_IN_IDENTIFIERS
 # define DOLLARS_IN_IDENTIFIERS true
 #endif
@@ -1383,6 +1385,66 @@ c_finish_options (void)
 
   include_cursor = 0;
   push_command_line_include ();
+
+
+	/* MPC_BEGIN */
+	if( !(cpp_get_options (parse_in)->lang == CLK_ASM) && getenv("MPC_DYN_PRIV_ENABLED") )
+	{
+		pch_cpp_save_state ();
+		
+		struct timeval tv;
+		gettimeofday( &tv, NULL);
+		
+		srand( getpid());
+		int rnd[4];
+		rnd[0] = rand();
+		rnd[1] = (int)tv.tv_sec;
+		rnd[2] = (int)tv.tv_usec;
+		srand(rnd[2] + rnd[0]);
+		rnd[3] = rand();;
+		
+		char fname[20];
+		char file_cont[500];
+		
+		snprintf(fname, 20, "/tmp/tmp-gcc-XXXXXX" );
+		snprintf(file_cont, 500, "void _%d%d%d%d(){}", rnd[0], rnd[1], rnd[2], rnd[3] );
+		
+		int fd = mkstemp(fname);
+		
+		if( fd < 0 )
+		{
+			perror("mkstemp");
+			abort();
+		}
+		
+		int to_w = strlen( file_cont );
+		int ret = 0;
+		
+		
+		while( (ret = write(fd, file_cont, to_w) ) )
+		{
+			if( ret < 0 )
+			{
+				if( errno == EAGAIN )
+					continue;
+				perror("write");
+				abort();
+			}
+			
+			to_w -= ret;
+			
+			if( to_w <= 0 )
+				break;
+		}
+		
+		
+		close( fd );
+		
+		cpp_push_include (parse_in, fname);
+		
+		unlink( fname );
+	}
+	/* MPC_END */
 }
 
 /* Give CPP the next file given by -include, if any.  */
diff --git a/gcc/c-family/c-pragma.c b/gcc/c-family/c-pragma.c
index c73aa8221..97e3753f8 100644
--- a/gcc/c-family/c-pragma.c
+++ b/gcc/c-family/c-pragma.c
@@ -1522,6 +1522,30 @@ init_pragma (void)
     cpp_register_deferred_pragma (parse_in, NULL, "simd", PRAGMA_CILK_SIMD,
 				  true, false);
 
+  /* MPC HLS BEGIN */
+  if (flag_mpc_hls && !flag_preprocess_only)
+    {
+      struct mpc_hls_pragma_def { const char *name; unsigned int id; };
+      static const struct mpc_hls_pragma_def mpc_hls_pragmas[] = {
+	{ "node",    PRAGMA_HLS_NODE },
+	{ "numa",    PRAGMA_HLS_NUMA },
+	{ "socket",  PRAGMA_HLS_SOCKET },
+	{ "cache",   PRAGMA_HLS_CACHE },
+	{ "core",    PRAGMA_HLS_CORE },
+	{ "single",  PRAGMA_HLS_SINGLE },
+	{ "barrier", PRAGMA_HLS_BARRIER },
+      } ;
+
+      const int n_mpc_hls_pragmas = sizeof (mpc_hls_pragmas) / 
+	sizeof (*mpc_hls_pragmas);
+      int i;
+
+      for (i = 0; i < n_mpc_hls_pragmas; ++i)
+	cpp_register_deferred_pragma (parse_in, "hls", mpc_hls_pragmas[i].name,
+				      mpc_hls_pragmas[i].id, true, true);
+    }
+  /* MPC HLS END */
+  
   if (!flag_preprocess_only)
     cpp_register_deferred_pragma (parse_in, "GCC", "pch_preprocess",
 				  PRAGMA_GCC_PCH_PREPROCESS, false, false);
diff --git a/gcc/c-family/c-pragma.h b/gcc/c-family/c-pragma.h
index 65f10db6e..0ef846836 100644
--- a/gcc/c-family/c-pragma.h
+++ b/gcc/c-family/c-pragma.h
@@ -69,10 +69,18 @@ enum pragma_kind {
 
   /* Top level clause to handle all Cilk Plus pragma simd clauses.  */
   PRAGMA_CILK_SIMD,
-
-  /* This pragma handles setting of grainsize for a _Cilk_for.  */
+    /* This pragma handles setting of grainsize for a _Cilk_for.  */
   PRAGMA_CILK_GRAINSIZE,
 
+  /* MPC HLS BEGIN */
+  PRAGMA_HLS_NODE,
+  PRAGMA_HLS_NUMA,
+  PRAGMA_HLS_SOCKET,
+  PRAGMA_HLS_CACHE,
+  PRAGMA_HLS_CORE,
+  PRAGMA_HLS_SINGLE,
+  PRAGMA_HLS_BARRIER,
+  /* MPC HLS END */
   PRAGMA_GCC_PCH_PREPROCESS,
   PRAGMA_IVDEP,
 
diff --git a/gcc/c-family/c.opt b/gcc/c-family/c.opt
index 88038a076..47369e6ea 100644
--- a/gcc/c-family/c.opt
+++ b/gcc/c-family/c.opt
@@ -577,6 +577,12 @@ Wmissing-declarations
 C ObjC C++ ObjC++ Var(warn_missing_declarations) Warning
 Warn about global functions without previous declarations.
 
+; MPC HLS BEGIN 
+Wmpc
+C C++ Var(warn_mpc) Warning LangEnabledBy(C C++, Wall)
+Warn about MPC-related and thread-safety issues
+; MPC HLS END
+
 Wmissing-field-initializers
 C ObjC C++ ObjC++ Var(warn_missing_field_initializers) Warning EnabledBy(Wextra)
 Warn about missing fields in struct initializers.
@@ -1287,6 +1293,27 @@ flax-vector-conversions
 C ObjC C++ ObjC++ Var(flag_lax_vector_conversions)
 Allow implicit conversions between vectors with differing numbers of subparts and/or differing element types.
 
+; MPC TLS BEGIN 
+fmpc-privatize
+C C++ Var(flag_mpc_privatize)
+Privatize every global variable to make MPI codes MPC compliant.
+
+fmpi-privatize
+C C++ Var(flag_mpi_privatize)
+Privatize every global variable to make MPI codes MPC compliant using standard TLS mechanism.
+; MPC TLS END 
+
+; MPC HLS BEGIN
+fhls
+C C++ Var(flag_mpc_hls)
+Enable Hierarchical Local Storage (HLS) directives
+
+fhls-verbose
+C C++ Var(flag_mpc_hls_verbose)
+Enable verbose output for Hierarchical Local Storage (HLS) directives
+; MPC HLS END
+
+
 fms-extensions
 C ObjC C++ ObjC++ Var(flag_ms_extensions)
 Don't warn about uses of Microsoft extensions.
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index b237e93b9..acc9776cb 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -210,6 +210,9 @@ struct GTY(()) lang_identifier {
   struct c_binding *label_binding;  /* labels */
 };
 
+/* MPC BEGIN */
+extern bool mpc_decl_match_invalid_header(tree decl);
+/* MPC END */
 /* Validate c-lang.c's assumptions.  */
 extern char C_SIZEOF_STRUCT_LANG_IDENTIFIER_isnt_accurate
 [(sizeof(struct lang_identifier) == C_SIZEOF_STRUCT_LANG_IDENTIFIER) ? 1 : -1];
@@ -2111,13 +2114,24 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,
     {
       /* Only variables can be thread-local, and all declarations must
 	 agree on this property.  */
-      if (C_DECL_THREADPRIVATE_P (olddecl) && !DECL_THREAD_LOCAL_P (newdecl))
+     /* MPC HLS BEGIN */
+#if 0
+    if (C_DECL_THREADPRIVATE_P (olddecl) && !DECL_THREAD_LOCAL_P (newdecl))
+#endif
+	  /* newdecl can be modified by mpc-privatize */
+    if (C_DECL_THREADPRIVATE_P (olddecl))
 	{
 	  /* Nothing to check.  Since OLDDECL is marked threadprivate
 	     and NEWDECL does not have a thread-local attribute, we
 	     will merge the threadprivate attribute into NEWDECL.  */
 	  ;
 	}
+	else if (DECL_TLS_MODEL(olddecl) >= TLS_MODEL_HLS_NODE)
+	{
+	  /* same as above but for HLS variables */
+	  ;
+	}
+      /* MPC HLS END */
       else if (DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl))
 	{
 	  if (DECL_THREAD_LOCAL_P (newdecl))
@@ -2455,6 +2469,14 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)
   if (VAR_P (olddecl) && C_DECL_THREADPRIVATE_P (olddecl))
     C_DECL_THREADPRIVATE_P (newdecl) = 1;
 
+	/* MPC HLS BEGIN */
+  /* merge the HLS attribute */
+  if (TREE_CODE (olddecl) == VAR_DECL && DECL_TLS_MODEL (olddecl) >= TLS_MODEL_HLS_NODE )
+    {
+        set_decl_tls_model (newdecl, DECL_TLS_MODEL (olddecl)); 
+    }
+/* MPC HLS END */
+	
   if (CODE_CONTAINS_STRUCT (TREE_CODE (olddecl), TS_DECL_WITH_VIS))
     {
       /* Copy the assembler name.
@@ -4297,6 +4319,8 @@ quals_from_declspecs (const struct c_declspecs *specs)
 	      && !specs->complex_p
 	      && !specs->inline_p
 	      && !specs->noreturn_p
+	      && !specs->task_p
+	      && !specs->process_p
 	      && !specs->thread_p);
   return quals;
 }
@@ -4631,6 +4655,49 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,
     record_inline_static (input_location, current_function_decl,
 			  decl, csi_modifiable);
 
+/* MPC TLS BEGIN */
+#if 1
+  if ( flag_mpi_privatize && 
+      TREE_CODE(decl) == VAR_DECL && 
+      ( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) && 
+      ( !TREE_READONLY( decl ) || !(initializer_constant_valid_p (decl, TREE_TYPE (decl))) ) && 
+      !DECL_THREAD_LOCAL_P(decl) &&
+	  !mpc_decl_match_invalid_header(decl)
+      /*!DECL_IN_SYSTEM_HEADER(decl) && */
+	  /*strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&*/
+	  /*strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0*/
+      ) {
+    fprintf( stderr, 
+	"(Front-end C) Automatic privatization to TLS (variable %s in file %s line %d)\n",
+	lang_hooks.decl_printable_name (decl,2), 
+	DECL_SOURCE_FILE(decl),
+	DECL_SOURCE_LINE(decl) ) ;
+    
+        set_decl_tls_model (decl, decl_default_tls_model (decl)); 
+  }
+  if ( flag_mpc_privatize && 
+      TREE_CODE(decl) == VAR_DECL && 
+      ( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) && 
+      ( !TREE_READONLY( decl ) || !(initializer_constant_valid_p (decl, TREE_TYPE (decl))) ) && 
+      !DECL_THREAD_LOCAL_P(decl)  &&
+	  !mpc_decl_match_invalid_header(decl)
+      /*!DECL_IN_SYSTEM_HEADER(decl) && */
+	  /*strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&*/
+	  /*strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0*/
+      ) {
+    fprintf( stderr, 
+	"(Front-end C) Automatic privatization to MPC task (variable %s in file %s line %d)\n",
+	lang_hooks.decl_printable_name (decl,2), 
+	DECL_SOURCE_FILE(decl),
+	DECL_SOURCE_LINE(decl) ) ;
+    
+	
+        set_decl_tls_model (decl, TLS_MODEL_MPC_TASK); 
+  }
+#endif
+/* MPC TLS END */
+
+
   if (c_dialect_objc ()
       && VAR_OR_FUNCTION_DECL_P (decl))
       objc_check_global_decl (decl);
@@ -5368,6 +5435,9 @@ grokdeclarator (const struct c_declarator *declarator,
 {
   tree type = declspecs->type;
   bool threadp = declspecs->thread_p;
+  bool taskp = declspecs->task_p;
+  bool processp = declspecs->process_p;
+  bool openmpp = declspecs->openmp_p;
   enum c_storage_class storage_class = declspecs->storage_class;
   int constp;
   int restrictp;
@@ -6734,8 +6804,22 @@ grokdeclarator (const struct c_declarator *declarator,
 
 	if (threadp)
 	  set_decl_tls_model (decl, decl_default_tls_model (decl));
+	/* MPC TLS BEGIN */
+	if(flag_mpc_privatize)
+	{
+		if(threadp)
+        	set_decl_tls_model (decl, TLS_MODEL_MPC_THREAD); 
+		else if(taskp)
+        	set_decl_tls_model (decl, TLS_MODEL_MPC_TASK); 
+		else if(processp)
+        	set_decl_tls_model (decl, TLS_MODEL_MPC_PROCESS); 
+		else if(openmpp)
+        	set_decl_tls_model (decl, TLS_MODEL_MPC_OPENMP); 
+	}
+	/* MPC TLS END */
       }
 
+		
     if ((storage_class == csc_extern
 	 || (storage_class == csc_none
 	     && TREE_CODE (type) == FUNCTION_TYPE
@@ -9500,6 +9584,11 @@ build_null_declspecs (void)
   ret->storage_class = csc_none;
   ret->expr_const_operands = true;
   ret->typespec_kind = ctsk_none;
+  /* MPC TLS BEGIN */
+  ret->task_p = false;
+  ret->process_p = false;
+  ret->openmp_p = false;
+  /* MPC TLS END */
   ret->address_space = ADDR_SPACE_GENERIC;
   return ret;
 }
@@ -10382,6 +10471,50 @@ declspecs_add_scspec (source_location loc,
 	  specs->locations[cdw_thread] = loc;
 	}
       break;
+	/* MPC TLS BEGIN */
+	case RID_PROCESS:
+      dupe = specs->process_p;
+      if (specs->storage_class == csc_auto)
+	error ("%<__process%> used with %<auto%>");
+      else if (specs->storage_class == csc_register)
+	error ("%<__process%> used with %<register%>");
+      else if (specs->storage_class == csc_typedef)
+	error ("%<__process%> used with %<typedef%>");
+      else
+	{
+	  specs->process_p = true;
+	  specs->locations[cdw_process] = loc;
+	}
+	  break;
+	case RID_TASK:
+      dupe = specs->task_p;
+      if (specs->storage_class == csc_auto)
+	error ("%<__task%> used with %<auto%>");
+      else if (specs->storage_class == csc_register)
+	error ("%<__task%> used with %<register%>");
+      else if (specs->storage_class == csc_typedef)
+	error ("%<__task%> used with %<typedef%>");
+      else
+	{
+	  specs->task_p = true;
+	  specs->locations[cdw_task] = loc;
+	}
+	  break;
+	case RID_OPENMP:
+      dupe = specs->openmp_p;
+      if (specs->storage_class == csc_auto)
+	error ("%<__openmp%> used with %<auto%>");
+      else if (specs->storage_class == csc_register)
+	error ("%<__openmp%> used with %<register%>");
+      else if (specs->storage_class == csc_typedef)
+	error ("%<__openmp%> used with %<typedef%>");
+      else
+	{
+	  specs->openmp_p = true;
+	  specs->locations[cdw_task] = loc;
+	}
+	  break;
+	/* MPC TLS END */
     case RID_AUTO:
       n = csc_auto;
       break;
@@ -10390,6 +10523,14 @@ declspecs_add_scspec (source_location loc,
       /* Diagnose "__thread extern".  */
       if (specs->thread_p && specs->thread_gnu_p)
 	error ("%<__thread%> before %<extern%>");
+	  /* MPC TLS BEGIN */
+	  else if(specs->task_p)
+	error ("%<__task%> before %<extern%>");
+	  else if(specs->process_p)
+	error ("%<__process%> before %<extern%>");
+	  else if(specs->openmp_p)
+	error ("%<__process%> before %<extern%>");
+	  /* MPC TLS END */
       break;
     case RID_REGISTER:
       n = csc_register;
@@ -10399,6 +10540,14 @@ declspecs_add_scspec (source_location loc,
       /* Diagnose "__thread static".  */
       if (specs->thread_p && specs->thread_gnu_p)
 	error ("%<__thread%> before %<static%>");
+	  /* MPC TLS BEGIN */
+	  else if(specs->task_p)
+	error ("%<__task%> before %<static%>");
+	  else if(specs->process_p)
+	error ("%<__process%> before %<static%>");
+	  else if(specs->openmp_p)
+	error ("%<__process%> before %<static%>");
+	  /* MPC TLS END */
       break;
     case RID_TYPEDEF:
       n = csc_typedef;
@@ -10425,13 +10574,25 @@ declspecs_add_scspec (source_location loc,
 	{
 	  specs->storage_class = n;
 	  specs->locations[cdw_storage_class] = loc;
+	  /* MPC TLS BEGIN */
+#if 0
 	  if (n != csc_extern && n != csc_static && specs->thread_p)
-	    {
+	  {
 	      error ("%qs used with %qE",
 		     specs->thread_gnu_p ? "__thread" : "_Thread_local",
 		     scspec);
 	      specs->thread_p = false;
+	  }
+#endif
+	  if (n != csc_extern && n != csc_static && (specs->thread_p || specs->process_p || specs->task_p || specs->openmp_p))
+	    {
+	      error ("%<__openmp>, %<__thread%>, %<__task%> or %<__process%> used with %qE", scspec);
+	      specs->thread_p = false;
+	      specs->task_p = false;
+	      specs->process_p = false;
+	      specs->openmp_p = false;
 	    }
+	  /* MPC TLS END */
 	}
     }
   return specs;
@@ -10813,8 +10974,7 @@ collect_all_refs (const char *source_file)
 
 /* Iterate over all global declarations and call CALLBACK.  */
 
-static void
-for_each_global_decl (void (*callback) (tree decl))
+void for_each_global_decl (void (*callback) (tree decl))
 {
   tree t;
   tree decls;
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index c9eb8ddba..9dfe099ff 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -704,6 +704,11 @@ c_token_starts_declspecs (c_token *token)
 	case RID_NORETURN:
 	case RID_AUTO:
 	case RID_THREAD:
+	/* MPC TLS BEGIN */
+	case RID_TASK:
+	case RID_PROCESS:
+	case RID_OPENMP:
+	/* MPC TLS END */
 	case RID_UNSIGNED:
 	case RID_LONG:
 	case RID_SHORT:
@@ -1357,6 +1362,12 @@ enum pragma_context { pragma_external, pragma_struct, pragma_param,
 		      pragma_stmt, pragma_compound };
 static bool c_parser_pragma (c_parser *, enum pragma_context, bool *);
 static bool c_parser_omp_target (c_parser *, enum pragma_context, bool *);
+/* MPC HLS BEGIN */
+static void c_parser_hls_scope(c_parser *);
+static void c_parser_hls_single(c_parser *);
+static void c_parser_hls_barrier(c_parser *);
+/* MPC HLS END */
+
 static void c_parser_omp_end_declare_target (c_parser *);
 static void c_parser_omp_declare (c_parser *, enum pragma_context);
 static bool c_parser_omp_ordered (c_parser *, enum pragma_context, bool *);
@@ -1432,7 +1443,6 @@ c_parser_translation_unit (c_parser *parser)
 	}
       while (c_parser_next_token_is_not (parser, CPP_EOF));
     }
-
   unsigned int i;
   tree decl;
   FOR_EACH_VEC_ELT (incomplete_record_decls, i, decl)
@@ -2461,6 +2471,11 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,
 	case RID_NORETURN:
 	case RID_AUTO:
 	case RID_THREAD:
+	/* MPC TLS BEGIN */
+	case RID_PROCESS:
+	case RID_TASK:
+	case RID_OPENMP:
+	/* MPC TLS END */
 	  if (!scspec_ok)
 	    goto out;
 	  attrs_ok = true;
@@ -3418,8 +3433,8 @@ c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,
 	       || c_parser_peek_token (parser)->id_kind == C_ID_CLASSNAME))
 	  || c_parser_peek_token (parser)->id_kind == C_ID_ID))
     {
-      struct c_declarator *inner
-	= build_id_declarator (c_parser_peek_token (parser)->value);
+	  struct c_declarator *inner
+       = build_id_declarator (c_parser_peek_token (parser)->value);
       *seen_id = true;
       inner->id_loc = c_parser_peek_token (parser)->location;
       c_parser_consume_token (parser);
@@ -3940,6 +3955,11 @@ c_parser_attribute_any_word (c_parser *parser)
 	case RID_RESTRICT:
 	case RID_COMPLEX:
 	case RID_THREAD:
+	/* MPC TLS BEGIN */
+	case RID_TASK:
+	case RID_PROCESS:
+	case RID_OPENMP:
+	/* MPC TLS END */
 	case RID_INT:
 	case RID_CHAR:
 	case RID_FLOAT:
@@ -10169,7 +10189,7 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)
       c_parser_error (parser, "%<#pragma GCC pch_preprocess%> must be first");
       c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);
       return false;
-
+	
     case PRAGMA_CILK_SIMD:
       if (!c_parser_cilk_verify_simd (parser, context))
 	return false;
@@ -10194,6 +10214,32 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)
       c_parser_cilk_grainsize (parser, if_p);
       return false;
 
+	/* MPC HLS BEGIN */
+
+    case PRAGMA_HLS_NODE:
+    case PRAGMA_HLS_NUMA:
+    case PRAGMA_HLS_SOCKET:
+    case PRAGMA_HLS_CACHE:
+   case PRAGMA_HLS_CORE:
+      c_parser_hls_scope (parser);
+      return false ;
+
+    case PRAGMA_HLS_SINGLE:
+      c_parser_hls_single (parser);
+      return false ;
+
+    case PRAGMA_HLS_BARRIER:
+      if (context != pragma_compound)
+	{
+	  if (context == pragma_stmt)
+	    c_parser_error (parser, "%<#pragma hls barrier%> may only be "
+			    "used in compound statements");
+	  goto bad_stmt;
+	}
+      c_parser_hls_barrier (parser);
+      return false ;
+
+      /* MPC HLS END */
     default:
       if (id < PRAGMA_FIRST_EXTERNAL)
 	{
@@ -17225,12 +17271,22 @@ c_parser_omp_threadprivate (c_parser *parser)
 	error_at (loc, "%<threadprivate%> %qE has incomplete type", v);
       else
 	{
-	  if (! DECL_THREAD_LOCAL_P (v))
-	    {
+
+
+#if 1 	/* MPC OMP C THREADPRIVATE */
+	/* Even if this variable is already a TLS, it should be at the
+	 * lowest level (OpenMP in MPC) */
+	if (DECL_TLS_MODEL (v) != TLS_MODEL_MPC_OPENMP)
+	{
+	      set_decl_tls_model (v, TLS_MODEL_MPC_OPENMP);
+#else /* MPC OMP C THREADPRIVATE */ 
+	if (! DECL_THREAD_LOCAL_P (v))
+ 	{
 	      set_decl_tls_model (v, decl_default_tls_model (v));
-	      /* If rtl has been already set for this var, call
-		 make_decl_rtl once again, so that encode_section_info
-		 has a chance to look at the new decl flags.  */
+#endif /* MPC OMP C THREADPRIVATE */ 
+       /* If rtl has been already set for this var, call
+	* make_decl_rtl once again, so that encode_section_info
+	*  has a chance to look at the new decl flags.  */
 	      if (DECL_RTL_SET_P (v))
 		make_decl_rtl (v);
 	    }
@@ -17865,6 +17921,241 @@ c_parser_transaction_cancel (c_parser *parser)
   return build1 (NOP_EXPR, void_type_node, error_mark_node);
 }
 
+
+
+/* MPC HLS BEGIN */
+
+static void c_parser_hls_scope(c_parser *parser) 
+{
+  tree vars, t;
+  enum pragma_kind p_kind;
+  char hls_string[32];
+  enum tls_model tls_type = TLS_MODEL_NONE;
+  int hls_level = 0 ;
+  location_t loc ;
+
+  p_kind = c_parser_peek_token (parser)->pragma_kind;
+  loc = c_parser_peek_token (parser)->location;
+  c_parser_consume_pragma (parser);
+ 
+  /* get variables */
+  vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);
+  
+  /* check if there is a level clause */
+  if ( c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL) ) {
+	  if ( c_parser_next_token_is (parser, CPP_NAME) ) {
+		  const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);
+		  if (strcmp ("level", p) == 0) {
+			  tree t ;
+			  c_parser_consume_token (parser);
+			  c_parser_require (parser, CPP_OPEN_PAREN, "expected %<(%>");
+			  t = c_parser_expr_no_commas (parser, NULL).value;
+			  if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE) {
+				  hls_level = tree_to_shwi(t);
+			  }else{
+				  c_parser_error (parser, "expected integer expression");
+			  }
+			  if ( hls_level <= 0 ) {
+				  c_parser_error (parser, "HLS: level should be strictly positive");
+				  hls_level = 0 ;
+			  }
+			  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, "expected %<)%>");
+		  }else {
+			  c_parser_error (parser, "HLS: expected %<level%> clause or empty");
+		  }
+	  }else{
+		  c_parser_error (parser, "HLS: expected %<level%> clause or empty");
+	  }
+  }
+  c_parser_skip_to_pragma_eol (parser);
+
+  /* set hls scope and level */
+  switch (p_kind)
+  {
+	  case PRAGMA_HLS_NODE:
+		  tls_type = TLS_MODEL_HLS_NODE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope node") ;
+		  sprintf ( hls_string, "node" );
+		  break;
+	  case PRAGMA_HLS_NUMA:
+		  if ( hls_level > 2 ) {
+			  warning_at (loc, 0, "HLS: max level is 2 for scope numa");
+			  hls_level = 2 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_1 ;
+		  sprintf ( hls_string, "numa level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_SOCKET:
+		  tls_type = TLS_MODEL_HLS_SOCKET ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "socket" );
+		  break;
+	  case PRAGMA_HLS_CACHE:
+		  if ( hls_level > 4 ) {
+			  warning_at (loc, 0, "HLS: max level is 3 for scope cache");
+			  hls_level = 3 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 3 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_3 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_1 ;
+		  sprintf ( hls_string, "cache level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_CORE:
+		  tls_type = TLS_MODEL_HLS_CORE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "core" );
+		  break;
+	  default:
+		  gcc_unreachable ();
+  }
+
+  /* Mark every variable in VARS to be assigned HLS
+     with the corresponding level.  */
+  for (t = vars; t; t = TREE_CHAIN (t))
+  {
+	  tree v = TREE_PURPOSE (t);
+
+	  if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+	  else if (! TREE_STATIC (v) && ! DECL_EXTERNAL (v))
+		  error ("automatic variable %qE cannot be %<HLS-%s%>", v, hls_string);
+	  else if (! COMPLETE_TYPE_P (TREE_TYPE (v))) 
+		  error ("variable %<HLS-%s%> %qE has incomplete type", hls_string, v);
+	  else if (TREE_USED (v) && DECL_TLS_MODEL(v) != tls_type)
+		  error ("%qE declared %<HLS-%s%> after first use", v, hls_string);
+	  else 
+	  {
+		  set_decl_tls_model (v, tls_type);	
+		  if ( flag_mpc_hls_verbose ) {
+			  fprintf( stderr , "HLS: Privatization to scope %s of variable %s (file %s line %d)\n", 
+					  hls_string, IDENTIFIER_POINTER( DECL_NAME(v) ), DECL_SOURCE_FILE(v), DECL_SOURCE_LINE(v) ) ;
+		  } 
+	  }
+  }
+}
+
+static void c_parser_hls_barrier(c_parser *parser) 
+{
+  tree vars, t, x, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, larger_tls_type = TLS_MODEL_HLS_CORE;
+  
+  loc = c_parser_peek_token (parser)->location;
+  c_parser_consume_pragma (parser);
+
+  /* get the larger tls type */
+  vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+
+      if (TREE_CODE (v) != VAR_DECL)
+        error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+        error ("%qD is not declared HLS", v);
+      else if ( tls_type < larger_tls_type )
+        larger_tls_type = tls_type ;
+    } 
+
+  c_parser_skip_to_pragma_eol (parser);
+  
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE ) ;
+  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_BARRIER);
+  x = build_call_expr (x, 1, arg);
+  add_stmt (x);
+  SET_EXPR_LOCATION (x, loc);
+}
+
+
+static void c_parser_hls_single(c_parser *parser) 
+{
+  tree vars, t, x, cond, then_block, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, previous_tls_type = TLS_MODEL_NONE;
+  char clause_nowait = 0 ;
+
+  loc = c_parser_peek_token (parser)->location;
+  c_parser_consume_pragma (parser);
+
+  /* check all vars have the same HLS scope
+	 and store this scope in tls_model */
+  vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+      if ( t == vars )
+        previous_tls_type = tls_type ;
+
+      if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+		  error ("%qD is not declared HLS", v);
+      else if ( tls_type != previous_tls_type )
+		  error ("%qD has incorrect HLS scope", v);
+    } 
+
+  /* get nowait clause */
+  if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL)) {
+	  if (c_parser_next_token_is (parser, CPP_NAME)) {
+		  const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);
+		  if (!strcmp ("nowait", p)) {
+			  clause_nowait = 1 ;
+			  c_parser_consume_token (parser);
+		  }else
+			  c_parser_error (parser, "HLS: expected %<nowait%> clause or empty");
+	  }else{
+		  c_parser_error (parser, "HLS: expected %<nowait%> clause or empty");
+	  }
+  }
+	  
+  c_parser_skip_to_pragma_eol (parser);
+  
+  
+  /* get single body */
+  then_block = push_stmt_list ();
+  c_parser_statement (parser, NULL);
+  if ( !clause_nowait ) {
+	  /* in case of blocking single, add a call at the end of the
+	     then block to exit the barrier entered when evaluating
+	     the condition of the if */
+	  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE );
+	  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_SINGLE_DONE);
+	  x = build_call_expr (x, 1, arg);
+	  SET_EXPR_LOCATION (x, loc);
+	  add_stmt (x) ;
+  }
+  then_block = pop_stmt_list (then_block);
+  
+  /* build call to hls_single */
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE );
+  cond = builtin_decl_explicit(clause_nowait ? BUILT_IN_MPC_HLS_SINGLE_NOWAIT : BUILT_IN_MPC_HLS_SINGLE);
+  cond = build_call_expr (cond, 1, arg);
+  SET_EXPR_LOCATION (cond, loc);
+  
+  /* add the if statement */
+  /* if ( hls_single() ) then { block in single ; hls_single_end() ; } */
+  x = build3 (COND_EXPR, void_type_node, cond, then_block, NULL);
+  SET_EXPR_LOCATION (x, loc);
+  add_stmt (x);
+}
+
+/* MPC HLS END */
+
 /* Parse a single source file.  */
 
 void
diff --git a/gcc/c/c-tree.h b/gcc/c/c-tree.h
index bb12a200f..8a93c8a8e 100644
--- a/gcc/c/c-tree.h
+++ b/gcc/c/c-tree.h
@@ -259,6 +259,11 @@ enum c_declspec_word {
   cdw_inline,
   cdw_noreturn,
   cdw_thread,
+  /* MPC TLS BEGIN */
+  cdw_process,
+  cdw_task,
+  cdw_openmp,
+  /* MPC TLS END */
   cdw_const,
   cdw_volatile,
   cdw_restrict,
@@ -344,6 +349,14 @@ struct c_declspecs {
   BOOL_BITFIELD thread_p : 1;
   /* Whether "__thread" rather than "_Thread_local" was specified.  */
   BOOL_BITFIELD thread_gnu_p : 1;
+  /* MPC TLS BEGIN */
+  /* Whether "__process" was specified.  */
+  BOOL_BITFIELD task_p : 1;
+  /* Whether "__task" was specified.  */
+  BOOL_BITFIELD process_p : 1;
+  /* Whether "__openmp" was specified.  */
+  BOOL_BITFIELD openmp_p : 1;
+  /* MPC TLS END */
   /* Whether "const" was specified.  */
   BOOL_BITFIELD const_p : 1;
   /* Whether "volatile" was specified.  */
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
index 09cca41ad..a213f9630 100644
--- a/gcc/c/c-typeck.c
+++ b/gcc/c/c-typeck.c
@@ -4488,6 +4488,7 @@ build_unary_op (location_t location,
 	  goto return_build_unary_op;
 	}
 
+	  
       val = build1 (ADDR_EXPR, argtype, arg);
 
       ret = val;
@@ -6702,7 +6703,7 @@ store_init_value (location_t init_loc, tree decl, tree init, tree origtype)
   if (init)
     npc = null_pointer_constant_p (init);
   value = digest_init (init_loc, type, init, origtype, npc,
-      		       true, TREE_STATIC (decl));
+      		       true, getenv("MPC_DYN_PRIV_ENABLED")?0:TREE_STATIC( decl ));
 
   /* Store the expression if valid; else report error.  */
 
@@ -7126,8 +7127,11 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,
 	       && !initializer_constant_valid_p (inside_init,
 						 TREE_TYPE (inside_init)))
 	{
-	  error_init (init_loc, "initializer element is not constant");
-	  inside_init = error_mark_node;
+	  if( !getenv("MPC_DYN_PRIV_ENABLED") )
+	  {
+		  error_init (0, "initializer element is not constant");
+		  inside_init = error_mark_node;
+	  }
 	}
       else if (require_constant && !maybe_const)
 	pedwarn_init (init_loc, OPT_Wpedantic,
@@ -7164,23 +7168,26 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,
       /* Check to see if we have already given an error message.  */
       if (inside_init == error_mark_node)
 	;
-      else if (require_constant && !TREE_CONSTANT (inside_init))
-	{
-	  error_init (init_loc, "initializer element is not constant");
-	  inside_init = error_mark_node;
-	}
-      else if (require_constant
-	       && !initializer_constant_valid_p (inside_init,
-						 TREE_TYPE (inside_init)))
-	{
-	  error_init (init_loc, "initializer element is not computable at "
-		      "load time");
-	  inside_init = error_mark_node;
+     else
+     {
+		 if( !getenv("MPC_DYN_PRIV_ENABLED") )
+		 {
+		 
+				if (require_constant && !TREE_CONSTANT (inside_init))
+				{
+	                                error_init (init_loc, "initializer element is not constant");
+					inside_init = error_mark_node;
+				}
+				else if (require_constant && !initializer_constant_valid_p (inside_init, TREE_TYPE (inside_init)))
+				{
+	                                error_init (init_loc, "initializer element is not computable at load time");
+					inside_init = error_mark_node;
+				}
+				else if (require_constant && !maybe_const)
+					pedwarn_init (init_loc, OPT_Wpedantic,
+		    			  "initializer element is not a constant expression");
+		}
 	}
-      else if (require_constant && !maybe_const)
-	pedwarn_init (init_loc, OPT_Wpedantic,
-		      "initializer element is not a constant expression");
-
       return inside_init;
     }
 
@@ -8688,8 +8695,11 @@ output_init_element (location_t loc, tree value, tree origtype,
     {
       if (require_constant_value)
 	{
-	  error_init (loc, "initializer element is not constant");
-	  value = error_mark_node;
+		if( !getenv("MPC_DYN_PRIV_ENABLED") )
+		{
+			error_init (0, "initializer element is not constant");
+			value = error_mark_node;
+		}
 	}
       else if (require_constant_elements)
 	pedwarn (loc, OPT_Wpedantic,
@@ -13357,7 +13367,12 @@ c_finish_omp_clauses (tree clauses, bool is_omp, bool declare_simd)
 	    {
 	      const char *share_name = NULL;
 
+	      /* MPC OMP BEGIN */
+	      #if 0 /* MPC OMP BEGIN */
 	      if (VAR_P (t) && DECL_THREAD_LOCAL_P (t))
+	      #else
+	      if (VAR_P (t) && DECL_MPC_THREAD_LOCAL_P (t))
+	      #endif /* MPC OMP END */
 		share_name = "threadprivate";
 	      else switch (c_omp_predetermined_sharing (t))
 		{
diff --git a/gcc/cgraph.h b/gcc/cgraph.h
index 0d5806b45..8c44604b5 100644
--- a/gcc/cgraph.h
+++ b/gcc/cgraph.h
@@ -1827,7 +1827,11 @@ public:
      function local statics.   */
   unsigned dynamically_initialized : 1;
 
+#if 0 /* MPC TLS BEGIN */
   ENUM_BITFIELD(tls_model) tls_model : 3;
+#else
+  ENUM_BITFIELD(tls_model) tls_model : 5;
+#endif /* MPC TLS END */
 
   /* Set if the variable is known to be used by single function only.
      This is computed by ipa_signle_use pass and used by late optimizations
diff --git a/gcc/cgraphbuild.c b/gcc/cgraphbuild.c
index 52ab840a0..0c1fded73 100644
--- a/gcc/cgraphbuild.c
+++ b/gcc/cgraphbuild.c
@@ -60,6 +60,10 @@ record_reference (tree *tp, int *walk_subtrees, void *data)
   switch (TREE_CODE (t))
     {
     case VAR_DECL:
+	    	#if 1 /* MPC PRIV-PLUGIN BEGIN */
+		break;
+		#else
+		#endif /* MPC PRIV-PLUGIN END */
     case FUNCTION_DECL:
       gcc_unreachable ();
       break;
diff --git a/gcc/common.opt b/gcc/common.opt
index 67048db7c..05d8987e0 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -2611,6 +2611,12 @@ fverbose-asm
 Common Report Var(flag_verbose_asm)
 Add extra commentary to assembler output.
 
+; MPC OMP begin
+fopenmp-verbose
+Common Report Var(flag_openmp_verbose)
+Add extra information about the OpenMP transformation
+; MPC OMP end 
+
 fvisibility=
 Common Joined RejectNegative Enum(symbol_visibility) Var(default_visibility) Init(VISIBILITY_DEFAULT)
 -fvisibility=[default|internal|hidden|protected]	Set the default symbol visibility.
diff --git a/gcc/config/i386/i386-protos.h b/gcc/config/i386/i386-protos.h
index ff47bc156..cd785d5e8 100644
--- a/gcc/config/i386/i386-protos.h
+++ b/gcc/config/i386/i386-protos.h
@@ -224,6 +224,24 @@ extern unsigned int ix86_get_callcvt (const_tree);
 
 extern rtx ix86_tls_module_base (void);
 
+/* MPC TLS BEGIN */
+extern rtx ix86_tls_get_addr__openmp_scope (void);
+extern rtx ix86_tls_get_addr__task_scope (void);
+extern rtx ix86_tls_get_addr__process_scope (void);
+extern rtx ix86_tls_get_addr__thread_scope (void);
+/* MPC TLS END */
+
+/* MPC HLS BEGIN */
+extern rtx ix86_tls_get_addr__node_scope (void);
+extern rtx ix86_tls_get_addr__numa_level_2_scope (void);
+extern rtx ix86_tls_get_addr__numa_level_1_scope (void);
+extern rtx ix86_tls_get_addr__socket_scope (void);
+extern rtx ix86_tls_get_addr__cache_level_3_scope (void);
+extern rtx ix86_tls_get_addr__cache_level_2_scope (void);
+extern rtx ix86_tls_get_addr__cache_level_1_scope (void);
+extern rtx ix86_tls_get_addr__core_scope (void);
+/* MPC HLS END */
+
 extern void ix86_expand_vector_init (bool, rtx, rtx);
 extern void ix86_expand_vector_set (bool, rtx, rtx, int);
 extern void ix86_expand_vector_extract (bool, rtx, rtx, int);
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index c1bdcc7ee..6ed8881c4 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -15259,7 +15259,11 @@ static GTY(()) rtx ix86_tls_symbol;
 static rtx
 ix86_tls_get_addr (void)
 {
-  if (!ix86_tls_symbol)
+  /* MPC TLS BEGIN */
+#if 0
+  if (!ix86_tls_symbol) 
+#endif
+  /* MPC TLS END */
     {
       const char *sym
 	= ((TARGET_ANY_GNU_TLS && !TARGET_64BIT)
@@ -15279,6 +15283,188 @@ ix86_tls_get_addr (void)
   return ix86_tls_symbol;
 }
 
+/* MPC TLS BEGIN */
+rtx
+ix86_tls_get_addr__openmp_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_openmp"
+					    : "__extls_get_addr_openmp");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__process_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_process"
+					    : "__extls_get_addr_process");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__task_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_task"
+					    : "__extls_get_addr_task");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__thread_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_thread"
+					    : "__extls_get_addr_thread");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__node_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_node"
+					    : "__extls_get_addr_node");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__numa_level_2_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_numa_level_2"
+					    : "__extls_get_addr_numa_level_2");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__numa_level_1_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_numa_level_1"
+					    : "__extls_get_addr_numa_level_1");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__socket_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_socket"
+					    : "__extls_get_addr_socket");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__cache_level_3_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_cache_level_3"
+					    : "__extls_get_addr_cache_level_3");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__cache_level_2_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_cache_level_2"
+					    : "__extls_get_addr_cache_level_2");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__cache_level_1_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_cache_level_1"
+					    : "__extls_get_addr_cache_level_1");
+    }
+
+  return ix86_tls_symbol;
+}
+
+rtx
+ix86_tls_get_addr__core_scope (void)
+{
+  /* if (!ix86_tls_symbol) */
+    {
+      ix86_tls_symbol = gen_rtx_SYMBOL_REF (Pmode,
+					    (TARGET_ANY_GNU_TLS
+					     && !TARGET_64BIT)
+					    ? "__extls_get_addr_core"
+					    : "__extls_get_addr_core");
+    }
+
+  return ix86_tls_symbol;
+}
+  /* MPC TLS END */
+  
 /* Construct the SYMBOL_REF for the _TLS_MODULE_BASE_ symbol.  */
 
 static GTY(()) rtx ix86_tls_module_base_symbol;
@@ -15310,15 +15496,65 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)
   machine_mode tp_mode = Pmode;
   int type;
 
-  /* Fall back to global dynamic model if tool chain cannot support local
-     dynamic.  */
   if (TARGET_SUN_TLS && !TARGET_64BIT
       && !HAVE_AS_IX86_TLSLDMPLT && !HAVE_AS_IX86_TLSLDM
       && model == TLS_MODEL_LOCAL_DYNAMIC)
     model = TLS_MODEL_GLOBAL_DYNAMIC;
 
+/* MPC HLS BEGIN */
+	rtx caddr = NULL; 
+	/* MPC HLS END */
   switch (model)
     {
+	/* MPC TLS BEGIN */
+	case TLS_MODEL_MPC_PROCESS:
+  	  caddr = !caddr?ix86_tls_get_addr__process_scope ():caddr;
+	case TLS_MODEL_MPC_THREAD:
+	  caddr = !caddr?ix86_tls_get_addr__thread_scope ():caddr;
+	case TLS_MODEL_MPC_TASK:
+	 caddr = !caddr?ix86_tls_get_addr__task_scope ():caddr;
+	case TLS_MODEL_MPC_OPENMP:
+	  caddr = !caddr?ix86_tls_get_addr__openmp_scope ():caddr;
+    case TLS_MODEL_HLS_NODE:
+	  caddr = !caddr?ix86_tls_get_addr__node_scope ():caddr;
+    case TLS_MODEL_HLS_NUMA_LEVEL_2:
+	  caddr = !caddr?ix86_tls_get_addr__numa_level_2_scope ():caddr;
+    case TLS_MODEL_HLS_NUMA_LEVEL_1:
+	  caddr = !caddr?ix86_tls_get_addr__numa_level_1_scope ():caddr;
+    case TLS_MODEL_HLS_SOCKET:
+	  caddr = !caddr?ix86_tls_get_addr__socket_scope ():caddr;
+    case TLS_MODEL_HLS_CACHE_LEVEL_3:
+	  caddr = !caddr?ix86_tls_get_addr__cache_level_3_scope ():caddr;
+    case TLS_MODEL_HLS_CACHE_LEVEL_2:
+	  caddr = !caddr?ix86_tls_get_addr__cache_level_2_scope ():caddr;
+    case TLS_MODEL_HLS_CACHE_LEVEL_1:
+	  caddr = !caddr?ix86_tls_get_addr__cache_level_1_scope ():caddr;
+    case TLS_MODEL_HLS_CORE:
+	  caddr = !caddr?ix86_tls_get_addr__core_scope ():caddr;
+ 	  
+	  dest = gen_reg_rtx (Pmode);
+      tp = TARGET_GNU2_TLS ? get_thread_pointer (Pmode, true) : 0;
+
+      if (TARGET_64BIT && ! TARGET_GNU2_TLS)
+	  {
+		  rtx rax = gen_rtx_REG (Pmode, AX_REG);
+	      rtx_insn *insns;
+
+	      start_sequence ();
+	      emit_call_insn
+		(ix86_gen_tls_global_dynamic_64 (rax, x, caddr));
+	      insns = get_insns ();
+	      end_sequence ();
+
+	      if (GET_MODE (x) != Pmode)
+		x = gen_rtx_ZERO_EXTEND (Pmode, x);
+
+	      RTL_CONST_CALL_P (insns) = 1;
+	      emit_libcall_block (insns, dest, rax, x);
+	}
+
+      break;
+      /* MPC TLS END */
     case TLS_MODEL_GLOBAL_DYNAMIC:
       dest = gen_reg_rtx (Pmode);
 
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 7fbbea619..f86686388 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -13601,6 +13601,344 @@
   ""
   "ix86_tls_descriptor_calls_expanded_in_cfun = true;")
 
+;; MPC TLS BEGIN
+(define_expand "tls_mpc_openmp_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__openmp_scope();
+})
+
+(define_expand "tls_mpc_process_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__process_scope();
+})
+
+(define_expand "tls_mpc_thread_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__thread_scope();
+})
+
+(define_expand "tls_mpc_task_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__task_scope();
+})
+
+(define_expand "tls_hls_node_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__node_scope();
+})
+
+(define_expand "tls_hls_numa_level_2_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__numa_level_2_scope();
+})
+
+(define_expand "tls_hls_numa_level_1_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__numa_level_1_scope();
+})
+
+(define_expand "tls_hls_socket_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__socket_scope();
+})
+
+(define_expand "tls_hls_cache_level_3_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__cache_level_3_scope();
+})
+
+(define_expand "tls_hls_cache_level_2_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__cache_level_2_scope();
+})
+
+(define_expand "tls_hls_cache_level_1_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__cache_level_1_scope();
+})
+
+(define_expand "tls_hls_core_32"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (unspec:SI
+		    [(match_dup 2)
+		     (match_operand:SI 1 "tls_symbolic_operand" "")
+		     (match_dup 3)]
+		    UNSPEC_TLS_GD))
+	      (clobber (match_scratch:SI 4 ""))
+	      (clobber (match_scratch:SI 5 ""))
+	      (clobber (reg:CC FLAGS_REG))])]
+  ""
+{
+  if (flag_pic)
+    operands[2] = pic_offset_table_rtx;
+  else
+    {
+      operands[2] = gen_reg_rtx (Pmode);
+      emit_insn (gen_set_got (operands[2]));
+    }
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_32
+		  (operands[0], operands[1], operands[2]));
+       DONE;
+    }
+  operands[3] = ix86_tls_get_addr__core_scope();
+})
+;; MPC TLS END
+
 (define_insn "*tls_global_dynamic_64_<mode>"
   [(set (match_operand:P 0 "register_operand" "=a")
 	(call:P
@@ -13660,6 +13998,194 @@
   "TARGET_64BIT"
   "ix86_tls_descriptor_calls_expanded_in_cfun = true;")
 
+
+;; MPC TLS BEGIN
+(define_expand "tls_mpc_openmp_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__openmp_scope ();
+})
+
+(define_expand "tls_mpc_process_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__process_scope ();
+})
+
+(define_expand "tls_mpc_task_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__task_scope ();
+})
+
+(define_expand "tls_mpc_thread_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__thread_scope ();
+})
+
+(define_expand "tls_hls_node_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__node_scope ();
+})
+(define_expand "tls_hls_numa_level_2_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__numa_level_2_scope ();
+})
+(define_expand "tls_hls_numa_level_1_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__numa_level_1_scope ();
+})
+(define_expand "tls_hls_socket_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__socket_scope ();
+})
+(define_expand "tls_hls_cache_level_3_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__cache_level_3_scope ();
+})
+(define_expand "tls_hls_cache_level_2_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__cache_level_2_scope ();
+})
+(define_expand "tls_hls_cache_level_1_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__cache_level_1_scope ();
+})
+(define_expand "tls_hls_core_64"
+  [(parallel [(set (match_operand:DI 0 "register_operand" "")
+		   (call:DI (mem:QI (match_dup 2)) (const_int 0)))
+	      (unspec:DI [(match_operand:DI 1 "tls_symbolic_operand" "")]
+			 UNSPEC_TLS_GD)])]
+  ""
+{
+  if (TARGET_GNU2_TLS)
+    {
+       emit_insn (gen_tls_dynamic_gnu2_64
+		  (operands[0], operands[1]));
+       DONE;
+    }
+  operands[2] = ix86_tls_get_addr__core_scope ();
+})
+;; MPC TLS END
+
 (define_insn "*tls_local_dynamic_base_32_gnu"
   [(set (match_operand:SI 0 "register_operand" "=a")
 	(unspec:SI
diff --git a/gcc/coretypes.h b/gcc/coretypes.h
index 12067fdf5..26e864ed8 100644
--- a/gcc/coretypes.h
+++ b/gcc/coretypes.h
@@ -164,7 +164,23 @@ enum tls_model {
   TLS_MODEL_GLOBAL_DYNAMIC = TLS_MODEL_REAL,
   TLS_MODEL_LOCAL_DYNAMIC,
   TLS_MODEL_INITIAL_EXEC,
-  TLS_MODEL_LOCAL_EXEC
+  TLS_MODEL_LOCAL_EXEC,
+  /* MPC TLS BEGIN */
+  TLS_MODEL_MPC_OPENMP,
+  TLS_MODEL_MPC_THREAD,
+  TLS_MODEL_MPC_TASK,
+  TLS_MODEL_MPC_PROCESS,
+  /* MPC TLS END */
+  /* MPC HLS BEGIN */
+  TLS_MODEL_HLS_NODE,
+  TLS_MODEL_HLS_NUMA_LEVEL_2,
+  TLS_MODEL_HLS_NUMA_LEVEL_1,
+  TLS_MODEL_HLS_SOCKET,
+  TLS_MODEL_HLS_CACHE_LEVEL_3,
+  TLS_MODEL_HLS_CACHE_LEVEL_2,
+  TLS_MODEL_HLS_CACHE_LEVEL_1,
+  TLS_MODEL_HLS_CORE
+  /* MPC HLS END */
 };
 
 /* Types of ABI for an offload compiler.  */
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index f4322afbb..4d15f031b 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -5273,6 +5273,11 @@ enum cp_decl_spec {
   ds_constexpr,
   ds_complex,
   ds_thread,
+  /* MPC TLS BEGIN */
+  ds_process,
+  ds_task,
+  ds_openmp,
+  /* MPC TLS END */
   ds_type_spec,
   ds_redefined_builtin_type_spec,
   ds_attribute,
@@ -6455,6 +6460,10 @@ extern bool generic_lambda_fn_p			(tree);
 extern void maybe_add_lambda_conv_op            (tree);
 extern bool is_lambda_ignored_entity            (tree);
 
+/* MPC HLS BEGIN */
+extern void finish_hls_scope			(tree vars);
+/* MPC HLS END */
+
 /* in tree.c */
 extern int cp_tree_operand_length		(const_tree);
 extern int cp_tree_code_length			(enum tree_code);
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 07870d189..3cccbe929 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -242,6 +242,9 @@ struct GTY(()) incomplete_var {
   tree incomplete_type;
 };
 
+/* MPC BEGIN */
+extern bool mpc_decl_match_invalid_header(tree decl);
+/* MPC END */
 
 static GTY(()) vec<incomplete_var, va_gc> *incomplete_vars;
 
@@ -2114,6 +2117,16 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)
 
 	      CP_DECL_THREADPRIVATE_P (newdecl) = 1;
 	    }
+	    /* MPC HLS BEGIN */
+	  if (DECL_LANG_SPECIFIC (olddecl)
+	      && DECL_TLS_MODEL (olddecl) >= TLS_MODEL_HLS_NODE )
+	    {
+	      /* Allocate a LANG_SPECIFIC structure for NEWDECL, if needed.  */
+	      if (!DECL_LANG_SPECIFIC (newdecl))
+		retrofit_lang_decl (newdecl);
+	     set_decl_tls_model (newdecl, DECL_TLS_MODEL(olddecl));
+	    }
+           /* MPC HLS END */
 	}
 
       /* An explicit specialization of a function template or of a member
@@ -2845,7 +2858,11 @@ redeclaration_error_message (tree newdecl, tree olddecl)
 	   && CP_DECL_THREAD_LOCAL_P (newdecl) != CP_DECL_THREAD_LOCAL_P (olddecl)
 	   && (! DECL_LANG_SPECIFIC (olddecl)
 	       || ! CP_DECL_THREADPRIVATE_P (olddecl)
-	       || CP_DECL_THREAD_LOCAL_P (newdecl)))
+	       || CP_DECL_THREAD_LOCAL_P (newdecl))
+	       /* MPC HLS BEGIN */
+	   && (! DECL_LANG_SPECIFIC (olddecl)
+	       || ! (DECL_TLS_MODEL (olddecl) >= TLS_MODEL_HLS_NODE) ) )
+/* MPC HLS END */
     {
       /* Only variables can be thread-local, and all declarations must
 	 agree on this property.  */
@@ -4690,6 +4707,24 @@ check_tag_decl (cp_decl_specifier_seq *declspecs,
 	error_at (declspecs->locations[ds_thread],
 		  "%<__thread%> can only be specified for objects "
 		  "and functions");
+ 
+      
+       else if (decl_spec_seq_has_spec_p (declspecs, ds_process))
+	error_at (declspecs->locations[ds_process],
+		  "process qualifier can only be specified for objects "
+		  "and functions");
+          
+      else if (decl_spec_seq_has_spec_p (declspecs,ds_task))
+	error_at (declspecs->locations[ds_task],
+		  "task qualifier can only be specified for objects "
+		  "and functions");
+          
+      else if (decl_spec_seq_has_spec_p (declspecs, ds_openmp))
+	error_at (declspecs->locations[ds_openmp],
+		  "openmp qualifier can only be specified for objects "
+		  "and functions");
+          
+                     
       else if (saw_typedef)
 	warning_at (declspecs->locations[ds_typedef], 0,
 		    "%<typedef%> was ignored in this declaration");
@@ -4917,6 +4952,51 @@ start_decl (const cp_declarator *declarator,
     warning_at (DECL_SOURCE_LOCATION (decl), 0,
 		"inline function %qD given attribute noinline", decl);
 
+/* MPC TLS BEGIN */
+  if ( flag_mpi_privatize &&
+	TREE_CODE(decl) == VAR_DECL &&
+	( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) &&
+	!mpc_decl_match_invalid_header(decl) &&
+	!TREE_READONLY( decl ) &&
+	!TREE_CONSTANT( decl ) &&
+	!DECL_THREAD_LOCAL_P(decl)
+    /*strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&*/
+	/*strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0*/
+  ) {
+    fprintf( stderr,
+      "(Front-end C++) Automatic privatization to TLS "
+      "(variable %s in file %s line %d)\n",
+      lang_decl_name( decl, 2 , 0),
+      DECL_SOURCE_FILE(decl),
+      DECL_SOURCE_LINE(decl) ) ;
+
+    CP_DECL_THREAD_LOCAL_P(decl) = true;
+    if (!processing_template_decl)
+	    set_decl_tls_model (decl, decl_default_tls_model (decl));
+  }
+  if ( flag_mpc_privatize &&
+	TREE_CODE(decl) == VAR_DECL &&
+	( TREE_STATIC( decl ) || DECL_EXTERNAL(decl) ) &&
+	!mpc_decl_match_invalid_header(decl) &&
+	!TREE_READONLY( decl ) &&
+	!TREE_CONSTANT( decl ) &&
+	DECL_TLS_MODEL(decl) != TLS_MODEL_MPC_TASK &&
+	!DECL_THREAD_LOCAL_P(decl)
+	/*strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmp.h", 7 ) != 0 &&*/
+	/*strncmp(basename(DECL_SOURCE_FILE(decl)), "mpcmicrothread.h", 16 ) != 0*/
+  ) {
+		fprintf( stderr,
+		  "(Front-end C++) Automatic privatization to MPC task "
+		  "(variable %s in file %s line %d)\n",
+		  lang_decl_name( decl, 2 , 0),
+		  DECL_SOURCE_FILE(decl),
+		  DECL_SOURCE_LINE(decl) ) ;
+		CP_DECL_THREAD_LOCAL_P(decl) = true;
+		if (!processing_template_decl)
+			set_decl_tls_model (decl, TLS_MODEL_MPC_TASK);	
+  }
+  /* MPC TLS END */
+  
   if (TYPE_P (context) && COMPLETE_TYPE_P (complete_type (context)))
     {
       bool this_tmpl = (processing_template_decl
@@ -6609,6 +6689,21 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
       && (DECL_INITIAL (decl) || init))
     DECL_INITIALIZED_IN_CLASS_P (decl) = 1;
 
+  /* MPC BEGIN */
+  if ( flag_mpc_privatize && 
+      (DECL_TLS_MODEL(decl) == TLS_MODEL_MPC_TASK) && 
+      (TREE_READONLY( decl ) || TREE_CONSTANT( decl ) ) ) 
+  {
+    fprintf( stderr, "(Front-end C++) Automatic un-privatization from MPC task "
+        "(variable %s in file %s line %d)\n",
+        lang_decl_name( decl, 2 , 0),
+        DECL_SOURCE_FILE(decl),
+        DECL_SOURCE_LINE(decl) ) ;
+    CP_DECL_THREAD_LOCAL_P (decl) = false;
+    set_decl_tls_model (decl, TLS_MODEL_NONE);
+  }
+  /* MPC END */
+
   if (TREE_CODE (decl) != FUNCTION_DECL
       && (auto_node = type_uses_auto (type)))
     {
@@ -7016,6 +7111,24 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,
     TREE_READONLY (decl) = 1;
 
   invoke_plugin_callbacks (PLUGIN_FINISH_DECL, decl);
+  
+  /* MPC TLS BEGIN */
+  tree mpc_type = TREE_TYPE(decl);
+	  if ( flag_mpc_privatize && 
+			  CP_DECL_THREAD_LOCAL_P(decl) &&
+			  /* if the decl is constant itself or constant by type transitivity */
+			  (TREE_READONLY( decl ) || TREE_CONSTANT( decl ) || (mpc_type && (TREE_READONLY( mpc_type ) || TREE_CONSTANT( mpc_type )))
+		) )
+	  {
+		  fprintf( stderr, "(Front-end C++) Automatic un-privatization from MPC task "
+	  		"(variable %s in file %s line %d)\n",
+				  lang_decl_name( decl, 2 , 0),
+	  			  DECL_SOURCE_FILE(decl),
+				  DECL_SOURCE_LINE(decl) ) ;
+		  CP_DECL_THREAD_LOCAL_P(decl) = false;
+          set_decl_tls_model (decl, TLS_MODEL_NONE);
+	  }
+  /* MPC TLS END */
 }
 
 /* Returns a declaration for a VAR_DECL as if:
@@ -7169,6 +7282,24 @@ get_thread_atexit_node (void)
   return decay_conversion (atexit_fndecl, tf_warning_or_error);
 }
 
+/* MPC BEGIN */
+static tree
+get_thread_mpc_atexit_node(void)
+{
+  /* The declaration for `__cxa_thread_atexit' is:
+
+     int __cxa_thread_atexit (void (*)(void *), void *, void *) */
+  tree fn_type = build_function_type_list (integer_type_node,
+					   get_atexit_fn_ptr_type (),
+					   ptr_type_node, ptr_type_node,
+					   NULL_TREE);
+
+  /* Now, build the function declaration.  */
+  tree atexit_fndecl = build_library_fn_ptr ("__cxa_thread_mpc_atexit", fn_type, ECF_LEAF | ECF_NOTHROW);
+  return decay_conversion (atexit_fndecl, tf_warning_or_error);
+}
+/* MPC END */
+
 /* Returns the __dso_handle VAR_DECL.  */
 
 static tree
@@ -7323,11 +7454,21 @@ register_dtor_fn (tree decl)
   /* Call atexit with the cleanup function.  */
   mark_used (cleanup);
   cleanup = build_address (cleanup);
-
+  
+  /* MPC BEGIN */
+  if(flag_mpc_privatize 
+		  && DECL_TLS_MODEL(decl) == TLS_MODEL_MPC_TASK) 
+  {
+	  atex_node = get_thread_mpc_atexit_node();
+  }
+  else
+  {
   if (CP_DECL_THREAD_LOCAL_P (decl))
     atex_node = get_thread_atexit_node ();
   else
     atex_node = get_atexit_node ();
+  }
+  /*MPC END */
 
   if (use_dtor)
     {
@@ -8460,7 +8601,36 @@ grokvardecl (tree type,
       TREE_PUBLIC (decl) = DECL_EXTERNAL (decl);
     }
 
-  if (decl_spec_seq_has_spec_p (declspecs, ds_thread))
+  /* MPC BEGIN */
+  if(flag_mpc_privatize)
+  {
+	  if (decl_spec_seq_has_spec_p (declspecs, ds_process))
+	  {
+		  CP_DECL_THREAD_LOCAL_P (decl) = true;
+		  if (!processing_template_decl)
+			  set_decl_tls_model (decl, TLS_MODEL_MPC_PROCESS);
+	  }
+	  else if (decl_spec_seq_has_spec_p (declspecs, ds_task))
+	  {
+		  CP_DECL_THREAD_LOCAL_P (decl) = true;
+		  if (!processing_template_decl)
+			  set_decl_tls_model (decl, TLS_MODEL_MPC_TASK);
+	  }
+	  else if (decl_spec_seq_has_spec_p (declspecs, ds_thread))
+	  {
+		  CP_DECL_THREAD_LOCAL_P (decl) = true;
+		  if (!processing_template_decl)
+			  set_decl_tls_model (decl, TLS_MODEL_MPC_THREAD);
+	  }
+	  else if (decl_spec_seq_has_spec_p (declspecs, ds_openmp))
+	  {
+		  CP_DECL_THREAD_LOCAL_P (decl) = true;
+		  if (!processing_template_decl)
+			  set_decl_tls_model (decl, TLS_MODEL_MPC_OPENMP);
+	  }
+  }
+  /* MPC END */
+  else if (decl_spec_seq_has_spec_p (declspecs, ds_thread))
     {
       if (DECL_EXTERNAL (decl) || TREE_STATIC (decl))
 	{
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index b3cc99a7d..9ff421ec2 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -50,6 +50,8 @@ along with GCC; see the file COPYING3.  If not see
 
 extern cpp_reader *parse_in;
 
+/* MPC BEGIN */
+extern bool mpc_decl_match_invalid_header(tree decl);
 /* This structure contains information about the initializations
    and/or destructions required for a particular priority level.  */
 typedef struct priority_info_s {
@@ -1003,7 +1005,7 @@ grokfield (const cp_declarator *declarator,
       else if (!VAR_P (value))
 	gcc_unreachable ();
     }
-
+    
   /* Pass friend decls back.  */
   if ((TREE_CODE (value) == FUNCTION_DECL
        || TREE_CODE (value) == TEMPLATE_DECL)
@@ -1014,7 +1016,46 @@ grokfield (const cp_declarator *declarator,
   if (VAR_P (value))
     DECL_CONTEXT (value) = current_class_type;
 
-  if (processing_template_decl && VAR_OR_FUNCTION_DECL_P (value))
+/* MPC TLS BEGIN */
+  if ( flag_mpi_privatize &&
+	TREE_CODE(value) == VAR_DECL &&
+	( TREE_STATIC( value ) || DECL_EXTERNAL(value) ) &&
+	!mpc_decl_match_invalid_header(value) &&
+	!TREE_READONLY( value ) &&
+	!TREE_CONSTANT( value ) &&
+	!DECL_THREAD_LOCAL_P(value)
+  ) {
+    fprintf( stderr,
+		    "(Front-end C++) Automatic privatization to TLS "
+		    "(variable %s in file %s line %d)\n",
+		    lang_decl_name( value, 2 , 0),
+		    DECL_SOURCE_FILE(value),
+		    DECL_SOURCE_LINE(value) ) ;
+    CP_DECL_THREAD_LOCAL_P(value) = true;
+    if (!processing_template_decl)
+	    set_decl_tls_model (value, decl_default_tls_model (value));
+  }
+  if ( flag_mpc_privatize &&
+		  TREE_CODE(value) == VAR_DECL &&
+		  ( TREE_STATIC( value ) || DECL_EXTERNAL(value) ) &&
+		  !mpc_decl_match_invalid_header(value) &&
+		  !TREE_READONLY( value ) &&
+		  !TREE_CONSTANT( value ) &&
+		  !DECL_THREAD_LOCAL_P(value)
+     ) {
+	  fprintf( stderr,
+			  "(Front-end C++) Automatic privatization to MPC task "
+			  "(variable %s in file %s line %d)\n",
+			  lang_decl_name( value, 2 , 0),
+			  DECL_SOURCE_FILE(value),
+			  DECL_SOURCE_LINE(value) ) ;
+	  CP_DECL_THREAD_LOCAL_P(value) = true;
+	  if (!processing_template_decl)
+		  set_decl_tls_model (value, TLS_MODEL_MPC_TASK);
+  }
+  /* MPC TLS END */
+  
+    if (processing_template_decl && VAR_OR_FUNCTION_DECL_P (value))
     {
       value = push_template_decl (value);
       if (error_operand_p (value))
@@ -1033,8 +1074,25 @@ grokfield (const cp_declarator *declarator,
     {
     case VAR_DECL:
       finish_static_data_member_decl (value, init, init_const_expr_p,
-				      asmspec_tree, flags);
-      return value;
+			  asmspec_tree, flags);
+	  /* MPC TLS BEGIN */
+	  if ( flag_mpc_privatize && 
+			  CP_DECL_THREAD_LOCAL_P (value) && 
+			  /* if the decl is constant itself or constant by type transitivity */
+			  (TREE_READONLY( value ) || TREE_CONSTANT( value ) || (TREE_TYPE(value) && (TREE_READONLY( TREE_TYPE(value) ) || TREE_CONSTANT( TREE_TYPE(value) )))
+			 ) ) 
+	  {
+		  fprintf( stderr,
+				  "(Front-end C++) Automatic un-privatization from MPC task "
+				  "(variable %s in file %s line %d)\n",
+				  lang_decl_name( value, 2 , 0),
+				  DECL_SOURCE_FILE(value),
+				  DECL_SOURCE_LINE(value) ) ;
+		  CP_DECL_THREAD_LOCAL_P (value) = false;
+          set_decl_tls_model (value, TLS_MODEL_NONE);
+	  }
+	  /* MPC TLS END */
+	  return value;
 
     case FIELD_DECL:
       if (asmspec)
@@ -4336,7 +4394,20 @@ handle_tls_init (void)
   DECL_IGNORED_P (guard) = true;
   TREE_USED (guard) = true;
   CP_DECL_THREAD_LOCAL_P (guard) = true;
+  
+  
+  #if 0 /* MPC PRIV-PLUGIN BEGIN */
   set_decl_tls_model (guard, decl_default_tls_model (guard));
+  #else
+  if(flag_mpc_privatize)
+  {
+      set_decl_tls_model (guard, TLS_MODEL_MPC_TASK);
+  }
+  else
+  {
+    set_decl_tls_model (guard, decl_default_tls_model (guard));
+  }
+  #endif /* MPC PRIV-PLUGIN END */
   pushdecl_top_level_and_finish (guard, NULL_TREE);
 
   tree fn = get_local_tls_init_fn ();
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index df8e74370..4a1921214 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -955,6 +955,11 @@ cp_lexer_next_token_is_decl_specifier_keyword (cp_lexer *lexer)
     case RID_EXTERN:
     case RID_MUTABLE:
     case RID_THREAD:
+		/*MPC TLS BEGIN*/
+	case RID_PROCESS:
+	case RID_TASK:
+	case RID_OPENMP:
+		/* MPC TLS END */
       /* Elaborated type specifiers.  */
     case RID_ENUM:
     case RID_CLASS:
@@ -12739,6 +12744,23 @@ cp_parser_decl_specifier_seq (cp_parser* parser,
 	  ds = ds_thread;
 	  cp_lexer_consume_token (parser->lexer);
 	  break;
+	/* MPC TLS BEGIN */
+	case RID_PROCESS:
+	  /* Consume the token.  */
+	  ds = ds_process;
+	  cp_lexer_consume_token (parser->lexer);
+	  break;
+	case RID_TASK:
+	  /* Consume the token.  */
+	  ds = ds_task;
+	  cp_lexer_consume_token (parser->lexer);
+	  break;
+	case RID_OPENMP:
+	  /* Consume the token.  */
+	  ds = ds_openmp;
+	  cp_lexer_consume_token (parser->lexer);
+	  break;
+	 /* MPC TLS END */
 
 	default:
 	  /* We did not yet find a decl-specifier yet.  */
@@ -26787,7 +26809,6 @@ set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,
 			     cp_decl_spec ds, cp_token *token)
 {
   gcc_assert (ds < ds_last);
-
   if (decl_specs == NULL)
     return;
 
@@ -26797,7 +26818,7 @@ set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,
     {
       decl_specs->locations[ds] = location;
       if (ds == ds_thread)
-	decl_specs->gnu_thread_keyword_p = token_is__thread (token);
+		decl_specs->gnu_thread_keyword_p = token_is__thread (token);
     }
   else
     {
@@ -36850,7 +36871,273 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok, bool *if_p)
 
   protected_set_expr_location (stmt, pragma_tok->location);
 }
-
+
+
+void make_decl_rtl (tree decl);
+
+
+/* MPC HLS BEGIN */
+static void
+cp_parser_hls_scope(cp_parser *parser, cp_token *pragma_tok)
+{
+  tree vars,t;
+  char hls_string[32];
+  enum tls_model tls_type;
+  const unsigned int id = cp_parser_pragma_kind(pragma_tok);
+  
+  const location_t loc = pragma_tok->location;
+  int hls_level = 0 ;
+
+  /* get variables */
+  vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);
+
+  /* check if there is a level clause */
+  if ( cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL) ) {
+	  if ( cp_lexer_next_token_is (parser->lexer, CPP_NAME) ) {
+		  tree id = cp_lexer_peek_token (parser->lexer)->u.value;
+		  const char *p = IDENTIFIER_POINTER (id);
+		  if (strcmp ("level", p) == 0) {
+			  tree t;
+			  cp_lexer_consume_token (parser->lexer);
+			  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);
+			  t = cp_parser_constant_expression (parser, false, NULL);
+			  t = fold_non_dependent_expr (t);
+			  if (INTEGRAL_TYPE_P (TREE_TYPE (t))) {
+				  hls_level = tree_to_shwi(t);
+				  if ( hls_level <= 0 ) {
+					  cp_parser_error (parser, "HLS: level should be strictly positive");
+					  hls_level = 0 ;
+					  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+				  }else{
+					  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);
+				  }
+			  }else{
+				  cp_parser_error (parser,"HLS: level argument needs positive constant integer expression");
+				  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+			  }
+		  }else{
+			  cp_parser_error (parser, "HLS: expected %<level%> clause or empty");
+			  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+		  }
+	  }else{
+		  cp_parser_error (parser, "HLS: expected %<level%> clause or empty");
+		  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+	  }
+  }
+
+  cp_parser_require_pragma_eol (parser, pragma_tok);
+
+  switch (id)
+  {
+	  case PRAGMA_HLS_NODE:
+		  tls_type = TLS_MODEL_HLS_NODE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope node") ;
+		  sprintf ( hls_string, "node" );
+		  break;
+	  case PRAGMA_HLS_NUMA:
+		  if ( hls_level > 2 ) {
+			  warning_at (loc, 0, "HLS: max level is 2 for scope numa");
+			  hls_level = 2 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_NUMA_LEVEL_1 ;
+		  sprintf ( hls_string, "numa level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_SOCKET:
+		  tls_type = TLS_MODEL_HLS_SOCKET ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "socket" );
+		  break;
+	  case PRAGMA_HLS_CACHE:
+		  if ( hls_level > 4 ) {
+			  warning_at (loc, 0, "HLS: max level is 3 for scope cache");
+			  hls_level = 3 ;
+		  }
+		  if ( hls_level == 0 )
+			  hls_level = 1 ;
+		  if ( hls_level == 3 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_3 ;
+		  if ( hls_level == 2 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_2 ;
+		  if ( hls_level == 1 )
+			  tls_type = TLS_MODEL_HLS_CACHE_LEVEL_1 ;
+		  sprintf ( hls_string, "cache level %d", hls_level );
+		  break;
+	  case PRAGMA_HLS_CORE:
+		  tls_type = TLS_MODEL_HLS_CORE ;
+		  if ( hls_level > 0 )
+			  warning_at (loc, 0, "HLS: level clause unsupported for scope socket") ;
+		  sprintf ( hls_string, "core" );
+		  break;
+	  default:
+		  gcc_unreachable ();
+  }
+
+  /* Mark every variable in VARS to be assigned HLS
+	 with the corresponding level.  */
+  for (t = vars; t; t = TREE_CHAIN (t))
+  {
+	  tree v = TREE_PURPOSE (t);
+
+	  if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+      else if (! TREE_STATIC (v) && ! DECL_EXTERNAL (v))
+		  error ("automatic variable %qE cannot be %<HLS-%s%>", v, hls_string);
+      else if (! COMPLETE_TYPE_P (TREE_TYPE (v))) 
+		  error ("variable %<HLS-%s%> %qE has incomplete type", hls_string, v);
+      else if (TREE_USED (v) && DECL_TLS_MODEL(v) != tls_type ) 
+		  error ("%qE declared %<HLS-%s%> after first use", v, hls_string);
+      else if (TREE_STATIC (v) && TYPE_P (CP_DECL_CONTEXT (v))
+	       && CP_DECL_CONTEXT (v) != current_class_type)
+		  error ("%<HLS-%s%> %qE directive not "
+	       "in %qT definition", hls_string, v, CP_DECL_CONTEXT (v));
+      else 
+	  {
+		  /* Allocate a LANG_SPECIFIC structure for V, if needed.  */
+		  if (DECL_LANG_SPECIFIC (v) == NULL)
+		  {
+			  retrofit_lang_decl (v);
+
+			  /* Make sure that DECL_DISCRIMINATOR_P continues to be true
+				 after the allocation of the lang_decl structure.  */
+			  if (DECL_DISCRIMINATOR_P (v))
+				  DECL_LANG_SPECIFIC (v)->u.base.u2sel = 1;
+		  }
+
+		  set_decl_tls_model (v, tls_type);
+
+		  {
+			  /* If rtl has been already set for this var, call
+				 make_decl_rtl once again, so that encode_section_info
+				 has a chance to look at the new decl flags.  */
+			  if (DECL_RTL_SET_P (v))
+				  make_decl_rtl (v);
+		  }
+		  if ( flag_mpc_hls_verbose ) {
+			  fprintf( stderr , "HLS: Privatization to %s scope of variable %s (file %s line %d)\n",
+					  hls_string, IDENTIFIER_POINTER( DECL_NAME(v) ),
+					  DECL_SOURCE_FILE(v), DECL_SOURCE_LINE(v) ) ;
+		  } 
+	  }
+	}
+}
+
+static void
+cp_parser_hls_barrier(cp_parser *parser, cp_token *pragma_tok)
+{
+  tree vars, t, x, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, larger_tls_type = TLS_MODEL_NONE;
+
+  larger_tls_type = TLS_MODEL_HLS_CORE ;
+  
+  loc = pragma_tok->location;
+
+  /* get the larger tls type */
+  vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+
+      if (TREE_CODE (v) != VAR_DECL)
+        error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+        error ("%qD is not declared HLS", v);
+      else if ( tls_type < larger_tls_type )
+        larger_tls_type = tls_type ;
+    } 
+
+  cp_parser_require_pragma_eol (parser, pragma_tok);
+  
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE ) ;
+  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_BARRIER);
+  x = build_call_expr (x, 1, arg);
+  add_stmt (x);
+  SET_EXPR_LOCATION (x, loc);
+}
+
+static void
+cp_parser_hls_single(cp_parser *parser, cp_token *pragma_tok) {
+  tree vars, t, x, cond, then_block, arg;
+  location_t loc;
+  enum tls_model tls_type = TLS_MODEL_NONE, previous_tls_type = TLS_MODEL_NONE;
+  char clause_nowait = 0 ;
+
+  loc = pragma_tok->location;
+
+  /* check all vars have the same HLS scope
+	 and store this scope in tls_model */
+  vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);
+  for (t = vars; t; t = TREE_CHAIN (t))
+    {
+      tree v = TREE_PURPOSE (t);
+      tls_type = DECL_TLS_MODEL (v);
+      if ( t == vars )
+        previous_tls_type = tls_type ;
+
+      if (TREE_CODE (v) != VAR_DECL)
+		  error ("%qD is not a variable", v);
+      else if ( tls_type < TLS_MODEL_HLS_NODE )
+		  error ("%qD is not declared HLS", v);
+      else if ( tls_type != previous_tls_type )
+		  error ("%qD has incorrect HLS scope", v);
+    } 
+
+  /* get nowait clause */
+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)) {
+	  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)) {
+		  tree id = cp_lexer_peek_token (parser->lexer)->u.value;
+		  const char *p = IDENTIFIER_POINTER (id);
+		  if (!strcmp ("nowait", p)) {
+			  clause_nowait = 1 ;
+			  cp_lexer_consume_token (parser->lexer);
+		  }else{
+			  cp_parser_error (parser, "expected %<nowait%> clause or empty");
+			  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+		  }
+	  }else{
+		  cp_parser_error (parser, "expected %<nowait%> clause or empty");
+		  cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+	  }
+  }
+	  
+  cp_parser_require_pragma_eol (parser, pragma_tok);
+
+  /* get single body */
+  then_block = push_stmt_list ();
+  cp_parser_statement (parser, NULL_TREE, false, NULL);
+  if ( !clause_nowait ) {
+	  /* in case of blocking single, add a call at the end of the
+	     then block to exit the barrier entered when evaluating
+	     the condition of the if */
+	  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE );
+	  x = builtin_decl_explicit(BUILT_IN_MPC_HLS_SINGLE_DONE);
+	  x = build_call_expr (x, 1, arg);
+	  SET_EXPR_LOCATION (x, loc);
+	  add_stmt (x) ;
+  }
+  then_block = pop_stmt_list (then_block);
+  
+  /* add the if statement */
+  /* if ( hls_single() ) then { then_block ; hls_single_done(); } */
+  arg = build_int_cst ( integer_type_node, tls_type - TLS_MODEL_HLS_NODE ) ;
+  cond = builtin_decl_explicit(clause_nowait ? BUILT_IN_MPC_HLS_SINGLE_NOWAIT : BUILT_IN_MPC_HLS_SINGLE);
+  cond = build_call_expr (cond, 1, arg);
+  SET_EXPR_LOCATION (cond, loc);
+  x = build3 (COND_EXPR, void_type_node, cond, then_block, NULL);
+  SET_EXPR_LOCATION (x, loc);
+  add_stmt (x);
+}
+
+/* MPC HLS END */
+
 /* Transactional Memory parsing routines.  */
 
 /* Parse a transaction attribute.
@@ -37409,7 +37696,6 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)
 		"%<#pragma omp section%> may only be used in "
 		"%<#pragma omp sections%> construct");
       break;
-
     case PRAGMA_IVDEP:
       {
 	if (context == pragma_external)
@@ -37431,7 +37717,26 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)
 	cp_parser_iteration_statement (parser, if_p, true);
 	return true;
       }
-
+      
+    /* MPC HLS BEGIN */
+    
+    case PRAGMA_HLS_NODE:
+    case PRAGMA_HLS_NUMA:
+    case PRAGMA_HLS_SOCKET:
+    case PRAGMA_HLS_CACHE:
+    case PRAGMA_HLS_CORE:
+      cp_parser_hls_scope (parser, pragma_tok);
+      return false ;
+
+    case PRAGMA_HLS_BARRIER:
+      cp_parser_hls_barrier (parser, pragma_tok);
+      return false ;
+
+    case PRAGMA_HLS_SINGLE:
+      cp_parser_hls_single (parser, pragma_tok);
+      return false ;
+
+      /* MPC HLS END */
     case PRAGMA_CILK_SIMD:
       if (context == pragma_external)
 	{
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index a338c5194..e2c84cd39 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -7209,7 +7209,11 @@ finish_omp_clauses (tree clauses, bool allow_fields, bool declare_simd)
 	{
 	  const char *share_name = NULL;
 
+#if 1 /* MPC OMP C++ THREADPRIVATE */ 
+          if (VAR_P (t) && DECL_TLS_MODEL (t) == TLS_MODEL_MPC_OPENMP)
+#else /* MPC OMP C++ THREADPRIVATE */ 
 	  if (VAR_P (t) && CP_DECL_THREAD_LOCAL_P (t))
+#endif /* MPC OMP C++ THREADPRIVATE */
 	    share_name = "threadprivate";
 	  else switch (cxx_omp_predetermined_sharing (t))
 	    {
@@ -7451,10 +7455,19 @@ finish_omp_threadprivate (tree vars)
 		DECL_LANG_SPECIFIC (v)->u.base.u2sel = 1;
 	    }
 
-	  if (! CP_DECL_THREAD_LOCAL_P (v))
+          #if 1 /* MPC OMP C++ THREADPRIVATE */
+  	  /* Even if this variable is already a TLS, it should be at the
+	   * lowest level (OpenMP in MPC) */
+          if (DECL_TLS_MODEL (v) != TLS_MODEL_MPC_OPENMP)
+          {
+	    CP_DECL_THREAD_LOCAL_P (v) = true;
+            set_decl_tls_model (v, TLS_MODEL_MPC_OPENMP );
+          #else /* MPC OMP C++ THREADPRIVATE */ 
+	  if (! DECL_THREAD_LOCAL_P (v))
 	    {
 	      CP_DECL_THREAD_LOCAL_P (v) = true;
-	      set_decl_tls_model (v, decl_default_tls_model (v));
+	      DECL_TLS_MODEL (v) = decl_default_tls_model (v);
+          #endif /* MPC OMP C++ THREADPRIVATE */ 
 	      /* If rtl has been already set for this var, call
 		 make_decl_rtl once again, so that encode_section_info
 		 has a chance to look at the new decl flags.  */
diff --git a/gcc/fortran/Make-lang.in b/gcc/fortran/Make-lang.in
index 33d226644..6bc7310b8 100644
--- a/gcc/fortran/Make-lang.in
+++ b/gcc/fortran/Make-lang.in
@@ -58,7 +58,7 @@ F95_PARSER_OBJS = fortran/arith.o fortran/array.o fortran/bbt.o \
     fortran/iresolve.o fortran/match.o fortran/matchexp.o fortran/misc.o \
     fortran/module.o fortran/openmp.o fortran/options.o fortran/parse.o \
     fortran/primary.o fortran/resolve.o fortran/scanner.o fortran/simplify.o \
-    fortran/st.o fortran/symbol.o fortran/target-memory.o
+    fortran/st.o fortran/symbol.o fortran/target-memory.o fortran/hls.o
 
 F95_OBJS = $(F95_PARSER_OBJS) $(FORTRAN_TARGET_OBJS) \
     fortran/convert.o fortran/dependency.o fortran/f95-lang.o \
diff --git a/gcc/fortran/f95-lang.c b/gcc/fortran/f95-lang.c
index ea9c0ef2d..6c062d048 100644
--- a/gcc/fortran/f95-lang.c
+++ b/gcc/fortran/f95-lang.c
@@ -1217,14 +1217,30 @@ gfc_init_builtin_functions (void)
 #undef DEF_GOACC_BUILTIN_COMPILER
 #define DEF_GOACC_BUILTIN_COMPILER(code, name, type, attr) \
       gfc_define_builtin (name, builtin_types[type], code, name, attr);
+#undef DEF_MPC_BUILTIN
+#define DEF_MPC_BUILTIN(code, name, type, attr) /* ignore */
 #undef DEF_GOMP_BUILTIN
 #define DEF_GOMP_BUILTIN(code, name, type, attr) /* ignore */
 #include "../omp-builtins.def"
 #undef DEF_GOACC_BUILTIN
 #undef DEF_GOACC_BUILTIN_COMPILER
 #undef DEF_GOMP_BUILTIN
+#undef DEF_MPC_BUILTIN
     }
 
+    /* MPC HLS BEGIN */
+  if (gfc_option.flag_hls)
+  {
+#undef DEF_MPC_BUILTIN
+#define DEF_MPC_BUILTIN(code, name, type, attr) \
+	  gfc_define_builtin ("__builtin_" name, builtin_types[type], \
+			  code, name, attr == ATTR_CONST_NOTHROW_LIST);
+#include "../hls-builtins.def"
+#undef DEF_MPC_BUILTIN
+  }
+  /* MPC HLS END */
+
+    
   if (flag_openmp || flag_openmp_simd || flag_tree_parallelize_loops)
     {
 #undef DEF_GOACC_BUILTIN
@@ -1235,6 +1251,7 @@ gfc_init_builtin_functions (void)
 #define DEF_GOMP_BUILTIN(code, name, type, attr) \
       gfc_define_builtin ("__builtin_" name, builtin_types[type], \
 			  code, name, attr);
+			  
 #include "../omp-builtins.def"
 #undef DEF_GOACC_BUILTIN
 #undef DEF_GOACC_BUILTIN_COMPILER
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index 0bb71cb18..ca200450b 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -235,6 +235,12 @@ enum gfc_statement
   ST_OMP_END_PARALLEL_DO_SIMD, ST_OMP_DECLARE_SIMD, ST_OMP_DECLARE_REDUCTION,
   ST_OMP_TARGET, ST_OMP_END_TARGET, ST_OMP_TARGET_DATA, ST_OMP_END_TARGET_DATA,
   ST_OMP_TARGET_UPDATE, ST_OMP_DECLARE_TARGET,
+  /* MPC HLS BEGIN */
+  ST_HLS_SCOPE,
+  ST_HLS_SINGLE,
+  ST_HLS_END_SINGLE,
+  ST_HLS_BARRIER,
+  /* MPC HLS END */
   ST_OMP_TEAMS, ST_OMP_END_TEAMS, ST_OMP_DISTRIBUTE, ST_OMP_END_DISTRIBUTE,
   ST_OMP_DISTRIBUTE_SIMD, ST_OMP_END_DISTRIBUTE_SIMD,
   ST_OMP_DISTRIBUTE_PARALLEL_DO, ST_OMP_END_DISTRIBUTE_PARALLEL_DO,
@@ -617,6 +623,15 @@ enum init_local_integer
   GFC_INIT_INTEGER_ON
 };
 
+/* MPC HLS BEGIN */
+
+typedef enum gfc_hls_scope
+{
+	HLS_SCOPE_NONE, HLS_SCOPE_NODE, HLS_SCOPE_NUMA,
+	HLS_SCOPE_SOCKET, HLS_SCOPE_CACHE, HLS_SCOPE_CORE
+} gfc_hls_scope ;
+/* MPC HLS END */
+
 enum gfc_reverse
 {
   GFC_ENABLE_REVERSE,
@@ -728,6 +743,11 @@ typedef struct
     implied_index:1, subref_array_pointer:1, proc_pointer:1, asynchronous:1,
     contiguous:1, fe_temp: 1;
 
+ /* MPC HLS BEGIN */
+  ENUM_BITFIELD (gfc_hls_scope) hls_scope:4;
+  unsigned hls_level:2;
+  /* MPC HLS END */
+  
   /* For CLASS containers, the pointer attribute is sometimes set internally
      even though it was not directly specified.  In this case, keep the
      "real" (original) value here.  */
@@ -1528,6 +1548,10 @@ typedef struct gfc_common_head
 {
   locus where;
   char use_assoc, saved, threadprivate, omp_declare_target;
+  /* MPC HLS BEGIN */
+  gfc_hls_scope hls_scope;
+  unsigned int hls_level;
+  /* MPC HLS END */
   char name[GFC_MAX_SYMBOL_LEN + 1];
   struct gfc_symbol *head;
   const char* binding_label;
@@ -2399,6 +2423,10 @@ enum gfc_exec_op
   EXEC_OMP_PARALLEL_DO_SIMD, EXEC_OMP_TARGET, EXEC_OMP_TARGET_DATA,
   EXEC_OMP_TEAMS, EXEC_OMP_DISTRIBUTE, EXEC_OMP_DISTRIBUTE_SIMD,
   EXEC_OMP_DISTRIBUTE_PARALLEL_DO, EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD,
+  /* MPC HLS BEGIN */
+  EXEC_HLS_BARRIER, EXEC_HLS_SINGLE, EXEC_HLS_SINGLE_NOWAIT,
+  EXEC_HLS_END_SINGLE,
+  /* MPC HLS END */
   EXEC_OMP_TARGET_TEAMS, EXEC_OMP_TEAMS_DISTRIBUTE,
   EXEC_OMP_TEAMS_DISTRIBUTE_SIMD, EXEC_OMP_TARGET_TEAMS_DISTRIBUTE,
   EXEC_OMP_TARGET_TEAMS_DISTRIBUTE_SIMD,
@@ -2475,6 +2503,13 @@ typedef struct gfc_code
     gfc_omp_namelist *omp_namelist;
     bool omp_bool;
     gfc_omp_atomic_op omp_atomic;
+     /* MPC HLS BEGIN */
+	struct 
+	{
+		gfc_hls_scope scope;
+		unsigned int level;
+	} hls ;
+	/* MPC HLS END */
   }
   ext;		/* Points to additional structures required by statement */
 
@@ -2539,7 +2574,14 @@ typedef struct
   int fpe;
   int fpe_summary;
   int rtcheck;
-
+  /* MPC GLOBAL BEGIN */
+  //~ int warn_mpc;
+  //~ int flag_mpc_privatize;
+  /* MPC GLOBAL END */
+  /* MPC HLS BEGIN */
+  int flag_hls;
+  int flag_hls_verbose;
+  /* MPC HLS END */
   int warn_std;
   int allow_std;
 }
@@ -2810,6 +2852,11 @@ bool gfc_add_target (symbol_attribute *, locus *);
 bool gfc_add_dummy (symbol_attribute *, const char *, locus *);
 bool gfc_add_generic (symbol_attribute *, const char *, locus *);
 bool gfc_add_common (symbol_attribute *, locus *);
+
+/* MPC HLS BEGIN */
+bool gfc_add_hls_scope (symbol_attribute *, const char *, locus *, gfc_hls_scope, unsigned int);
+/* MPC HLS END */
+
 bool gfc_add_in_common (symbol_attribute *, const char *, locus *);
 bool gfc_add_in_equivalence (symbol_attribute *, const char *, locus *);
 bool gfc_add_data (symbol_attribute *, const char *, locus *);
diff --git a/gcc/fortran/hls.c b/gcc/fortran/hls.c
new file mode 100644
index 000000000..ce52bb747
--- /dev/null
+++ b/gcc/fortran/hls.c
@@ -0,0 +1,445 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "hash-set.h"
+#include "machmode.h"
+#include "vec.h"
+#include "double-int.h"
+#include "input.h"
+#include "alias.h"
+#include "symtab.h"
+#include "wide-int.h"
+#include "inchash.h"
+#include "tree.h"
+#include "gfortran.h"
+#include "match.h"
+#include "trans.h"
+#include "trans-stmt.h"
+#include "fold-const.h"
+
+static match gfc_match_hls_eos (void)
+{
+  locus old_loc;
+  char c;
+
+  old_loc = gfc_current_locus;
+  gfc_gobble_whitespace ();
+
+  c = gfc_next_ascii_char ();
+  switch (c)
+    {
+    case '!':
+      do
+	c = gfc_next_ascii_char ();
+      while (c != '\n');
+      /* Fall through */
+
+    case '\n':
+      return MATCH_YES;
+    }
+
+  gfc_current_locus = old_loc;
+  return MATCH_NO;
+}
+
+static match gfc_match_hls_scope (gfc_hls_scope scope)
+{
+  char n[GFC_MAX_SYMBOL_LEN+1];
+  gfc_symbol *sym;
+  match m;
+  gfc_symtree *st;
+  gfc_expr *expr_level;
+  int level = 1;
+  locus old_loc = gfc_current_locus; 
+  locus loc_var_list, loc_after_level ;
+  int level_clause_found = 0 ;
+  
+  m = gfc_match (" (");
+  if (m != MATCH_YES)
+    return m;
+
+  loc_var_list = gfc_current_locus;
+
+  /* skip variables */
+  while (1) {
+	  if ( gfc_match_symbol (&sym, 0) != MATCH_YES
+		&& ( gfc_match (" / %n /", n) != MATCH_YES || n[0] == '\0' ) )
+		  goto syntax ;
+	  m = gfc_match_char (',') ;
+	  if ( m == MATCH_ERROR )
+		  goto syntax; 
+	  if ( m == MATCH_YES ) {
+		  continue;
+	  }
+	  m = gfc_match_char (')') ;
+	  if ( m == MATCH_ERROR )
+		  goto syntax; 
+	  if ( m == MATCH_YES ) {
+		  break;
+	  }
+  }
+
+  m = gfc_match (" level ( %e ) ", &expr_level);
+  if ( m == MATCH_ERROR )
+	  goto syntax;
+  if ( m == MATCH_YES ) {
+	  level_clause_found = 1 ;
+	  /* level clause present */
+	  gfc_extract_int(expr_level, &level);
+	  if ( level <= 0 ) {
+		  gfc_error("HLS: level should contain a positive integer at %C");
+		  goto cleanup;
+	  }
+	  gfc_free_expr(expr_level);
+	  switch (scope){
+		  case HLS_SCOPE_NONE:
+			  gfc_error("HLS: scope cannot be none at %C");
+			  goto cleanup;
+		  case HLS_SCOPE_NODE:
+		  case HLS_SCOPE_SOCKET:
+		  case HLS_SCOPE_CORE:
+			  gfc_error("HLS: level clause not valid for scopes node, socket and core at %C");
+			  goto cleanup;
+		  case HLS_SCOPE_NUMA:
+			  if ( level > 2 ) {
+				  gfc_error("HLS: level is at most 2 for scope NUMA at %C");
+				  goto cleanup;
+			  }
+			  break;
+		  case HLS_SCOPE_CACHE:
+			  if ( level > 3 ) {
+				  gfc_error("HLS: level is at most 3 for scope CACHE at %C");
+				  goto cleanup;
+			  }
+			  break ;
+	  }
+	  loc_after_level = gfc_current_locus ;
+  }
+  
+  /* go back to variables list */
+  gfc_current_locus = loc_var_list ;
+   
+  for (;;)
+    {
+      m = gfc_match_symbol (&sym, 0);
+      switch (m)
+	{
+	case MATCH_YES:
+	  if (sym->attr.in_common)
+	    gfc_error_now ("HLS variable at %C is an element of "
+			   "a COMMON block");
+	  else if (gfc_add_hls_scope (&sym->attr, sym->name,
+		   &sym->declared_at, scope, level) == false)
+	    goto cleanup;
+	  goto next_item;
+	case MATCH_NO:
+	  break;
+	case MATCH_ERROR:
+	  goto cleanup;
+	}
+
+      m = gfc_match (" / %n /", n);
+      if (m == MATCH_ERROR)
+	goto cleanup;
+      if (m == MATCH_NO || n[0] == '\0')
+	goto syntax;
+
+      st = gfc_find_symtree (gfc_current_ns->common_root, n);
+      if (st == NULL)
+	{
+	  gfc_error ("COMMON block /%s/ not found at %C", n);
+	  goto cleanup;
+	}
+      st->n.common->hls_scope = scope;
+      for (sym = st->n.common->head; sym; sym = sym->common_next)
+	if (gfc_add_hls_scope (&sym->attr, sym->name,
+				   &sym->declared_at, scope, level) == false)
+	  goto cleanup;
+
+    next_item:
+      if (gfc_match_char (')') == MATCH_YES)
+	break;
+      if (gfc_match_char (',') != MATCH_YES)
+	goto syntax;
+    }
+
+  /* skip level clause if found */
+  if ( level_clause_found == 1 ) 
+	  gfc_current_locus = loc_after_level ;
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in !$HLS list at %C");
+
+cleanup:
+  gfc_current_locus = old_loc;
+  return MATCH_ERROR;
+}
+
+match gfc_match_hls_node (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_NODE ) ;
+}
+
+match gfc_match_hls_numa (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_NUMA ) ;
+}
+
+match gfc_match_hls_socket (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_SOCKET ) ;
+}
+
+match gfc_match_hls_cache (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_CACHE ) ;
+}
+
+match gfc_match_hls_core (void)
+{
+  return gfc_match_hls_scope ( HLS_SCOPE_CORE ) ;
+}
+
+match gfc_match_hls_single (void)
+{
+  locus old_loc;
+  bool nowait ;
+  char n[GFC_MAX_SYMBOL_LEN+1];
+  gfc_symbol *sym;
+  match m;
+  gfc_symtree *st;
+  gfc_hls_scope scope = HLS_SCOPE_NONE ;
+  unsigned int level = 1;
+
+  old_loc = gfc_current_locus;
+
+  m = gfc_match (" (");
+  if (m != MATCH_YES)
+	  return m;
+
+  for (;;)
+  {
+	  m = gfc_match_symbol (&sym, 0);
+	  switch (m)
+	  {
+		  case MATCH_YES:
+			  if ( sym->attr.hls_scope == HLS_SCOPE_NONE )
+				  gfc_error_now ("variable at %C has not been declared HLS");
+			  else if ( scope != HLS_SCOPE_NONE )
+			  {
+				  if ( sym->attr.hls_scope != scope || sym->attr.hls_level != level )
+					  gfc_error_now ("variable at %C has incorrect HLS scope");
+			  }else{
+				  scope = sym->attr.hls_scope ;
+				  level = sym->attr.hls_level ;
+			  }
+			  goto next_item;
+		  case MATCH_NO:
+			  break;
+		  case MATCH_ERROR:
+			  goto cleanup;
+	  }
+
+	  m = gfc_match (" / %n /", n);
+	  if (m == MATCH_ERROR)
+		  goto cleanup;
+	  if (m == MATCH_NO || n[0] == '\0')
+		  goto syntax;
+
+	  st = gfc_find_symtree (gfc_current_ns->common_root, n);
+	  if (st == NULL)
+	  {
+		  gfc_error ("COMMON block /%s/ not found at %C", n);
+		  goto cleanup;
+	  }
+	  if ( st->n.common->hls_scope == HLS_SCOPE_NONE )
+	  {
+		  gfc_error_now ("variable at %C has not been declared HLS");
+		  goto next_item;
+	  }else if ( scope != HLS_SCOPE_NONE )
+	  {
+		  if ( st->n.common->hls_scope != scope || st->n.common->hls_level != level )
+			  gfc_error_now ("variable at %C has incorrect HLS scope");
+	  }else{
+		  scope = st->n.common->hls_scope ;
+		  level = st->n.common->hls_level ;
+	  }
+
+next_item:
+	  if (gfc_match_char (')') == MATCH_YES)
+		  break;
+	  if (gfc_match_char (',') != MATCH_YES)
+		  goto syntax;
+  }
+
+    
+  nowait = gfc_match ("% nowait") == MATCH_YES ;
+
+  if (gfc_match_hls_eos () != MATCH_YES)
+	  return MATCH_ERROR;
+
+  if ( nowait )
+ 	 new_st.op = EXEC_HLS_SINGLE_NOWAIT;
+  else
+	 new_st.op = EXEC_HLS_SINGLE;
+  new_st.ext.hls.scope = scope ;
+  new_st.ext.hls.level = level ;
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in !$HLS SINGLE at %C");
+
+cleanup:
+  gfc_current_locus = old_loc;
+  return MATCH_ERROR;
+}
+
+match gfc_match_hls_end_single (void)
+{
+  if (gfc_match_hls_eos () != MATCH_YES)
+	  return MATCH_ERROR;
+
+  new_st.op = EXEC_HLS_END_SINGLE;
+  return MATCH_YES;
+}
+
+match gfc_match_hls_barrier (void)
+{
+  locus old_loc;
+  char n[GFC_MAX_SYMBOL_LEN+1];
+  gfc_symbol *sym;
+  match m;
+  gfc_symtree *st;
+  gfc_hls_scope min_scope = HLS_SCOPE_CORE ;
+  unsigned int max_level = 1;
+
+  old_loc = gfc_current_locus;
+
+  m = gfc_match (" (");
+  if (m != MATCH_YES)
+	  return m;
+
+  for (;;)
+  {
+	  m = gfc_match_symbol (&sym, 0);
+	  switch (m)
+	  {
+		  case MATCH_YES:
+			  if ( sym->attr.hls_scope == HLS_SCOPE_NONE )
+				  gfc_error_now ("variable at %C has not been declared HLS");
+			  else if ( sym->attr.hls_scope < min_scope ) {
+				  min_scope = sym->attr.hls_scope ;
+				  max_level = sym->attr.hls_level ;
+			  }
+			  else if ( sym->attr.hls_scope == min_scope && sym->attr.hls_level > max_level )
+				  max_level = sym->attr.hls_level ;
+			  goto next_item;
+		  case MATCH_NO:
+			  break;
+		  case MATCH_ERROR:
+			  goto cleanup;
+	  }
+
+	  m = gfc_match (" / %n /", n);
+	  if (m == MATCH_ERROR)
+		  goto cleanup;
+	  if (m == MATCH_NO || n[0] == '\0')
+		  goto syntax;
+
+	  st = gfc_find_symtree (gfc_current_ns->common_root, n);
+	  if (st == NULL)
+	  {
+		  gfc_error ("COMMON block /%s/ not found at %C", n);
+		  goto cleanup;
+	  }
+	  if ( st->n.common->hls_scope == HLS_SCOPE_NONE )
+	  {
+		  gfc_error_now ("variable at %C has not been declared HLS");
+		  goto next_item;
+	  }else if ( st->n.common->hls_scope < min_scope ) {
+		  min_scope = st->n.common->hls_scope ;
+		  max_level = st->n.common->hls_level ;
+	  }
+	  else if ( st->n.common->hls_scope == min_scope && st->n.common->hls_level > max_level )
+		  max_level = st->n.common->hls_level ;
+
+next_item:
+	  if (gfc_match_char (')') == MATCH_YES)
+		  break;
+	  if (gfc_match_char (',') != MATCH_YES)
+		  goto syntax;
+  }
+  
+  if (gfc_match_hls_eos () != MATCH_YES)
+	  return MATCH_ERROR;
+  new_st.op = EXEC_HLS_BARRIER;
+  new_st.ext.hls.scope = min_scope ;
+  new_st.ext.hls.level = max_level ;
+  return MATCH_YES;
+
+syntax:
+  gfc_error ("Syntax error in !$HLS BARRIER at %C");
+
+cleanup:
+  gfc_current_locus = old_loc;
+  return MATCH_ERROR;
+}
+
+tree gfc_trans_hls_directive (gfc_code *code)
+{
+  tree arg, call_hls, then_block, cond;
+  bool nowait = true ;
+  stmtblock_t stmt_block;
+  const gfc_hls_scope scope = code->ext.hls.scope ;
+  const unsigned int level = code->ext.hls.level ;
+  unsigned int hls_scope_with_level ;
+ 
+  hls_scope_with_level = scope - HLS_SCOPE_NODE ;
+
+  if ( scope == HLS_SCOPE_NUMA )
+	  hls_scope_with_level += 2 - level ;
+  else if ( scope > HLS_SCOPE_NUMA )
+	  hls_scope_with_level += 1 ;
+
+  if ( scope == HLS_SCOPE_CACHE )
+	  hls_scope_with_level += 3 - level ;
+  else if ( scope > HLS_SCOPE_CACHE )
+	  hls_scope_with_level += 2 ;
+
+  arg = build_int_cst ( integer_type_node, hls_scope_with_level );
+
+  switch (code->op)
+    {
+    case EXEC_HLS_BARRIER:
+		call_hls = builtin_decl_explicit(BUILT_IN_MPC_HLS_BARRIER);
+		call_hls = build_call_expr (call_hls, 1, arg);
+		return call_hls;
+	case EXEC_HLS_SINGLE:
+		nowait = false ;
+	case EXEC_HLS_SINGLE_NOWAIT:
+		pushlevel ();
+		then_block = gfc_trans_code (code->block->next);
+		if ( !nowait ) {
+			call_hls = builtin_decl_explicit(BUILT_IN_MPC_HLS_SINGLE_DONE);
+			call_hls = build_call_expr (call_hls, 1, arg);
+			stmt_block.head = then_block;
+			stmt_block.has_scope = 1;
+			gfc_add_expr_to_block ( &stmt_block, call_hls) ;
+		}
+		if (TREE_CODE (then_block) != BIND_EXPR)
+		{
+			tree block = poplevel (1, 0);
+			then_block = build3_v (BIND_EXPR, NULL, then_block, block);
+		}
+		else
+			poplevel (0, 0);
+		call_hls = builtin_decl_explicit(nowait?BUILT_IN_MPC_HLS_SINGLE_NOWAIT:BUILT_IN_MPC_HLS_SINGLE);
+		call_hls = build_call_expr (call_hls, 1, arg);
+		cond = build3 (COND_EXPR, void_type_node, call_hls, then_block, NULL);
+		return cond ;
+    default:
+      gcc_unreachable ();
+    }
+}
diff --git a/gcc/fortran/lang.opt b/gcc/fortran/lang.opt
index bdf5fa5fb..bd55b88b6 100644
--- a/gcc/fortran/lang.opt
+++ b/gcc/fortran/lang.opt
@@ -241,6 +241,12 @@ Wfunction-elimination
 Fortran Warning Var(warn_function_elimination)
 Warn about function call elimination.
 
+; MPC GLOBAL BEGIN
+;Wmpc
+;Fortran Warning
+;Warn about MPC and thread-safety issues
+; MPC GLOBAL END
+
 Wimplicit-interface
 Fortran Warning Var(warn_implicit_interface)
 Warn about calls with implicit interface.
@@ -381,6 +387,16 @@ fblas-matmul-limit=
 Fortran RejectNegative Joined UInteger Var(flag_blas_matmul_limit) Init(30)
 -fblas-matmul-limit=<n>	Size of the smallest matrix for which matmul will use BLAS.
 
+; MPC TLS BEGIN 
+fhls
+Fortran
+Enable Hierarchical Local Storage (HLS) directives
+
+fhls-verbose
+Fortran
+Enable verbose output for Hierarchical Local Storage (HLS) directives
+; MPC TLS END 
+
 fcheck-array-temporaries
 Fortran
 Produce a warning at runtime if a array temporary has been created for a procedure argument.
@@ -582,6 +598,12 @@ fmodule-private
 Fortran Var(flag_module_private)
 Set default accessibility of module entities to PRIVATE.
 
+; MPC TLS BEGIN 
+fmpc-privatize
+Fortran
+Privatize every global variable to make MPI codes MPC compliant.
+; MPC TLS END 
+
 fopenacc
 Fortran LTO
 ; Documented in C
diff --git a/gcc/fortran/match.h b/gcc/fortran/match.h
index 348ca701c..379d4dcb0 100644
--- a/gcc/fortran/match.h
+++ b/gcc/fortran/match.h
@@ -243,6 +243,17 @@ match gfc_match_target (void);
 match gfc_match_value (void);
 match gfc_match_volatile (void);
 
+/* MPC HLS BEGIN */
+match gfc_match_hls_node (void);
+match gfc_match_hls_numa (void);
+match gfc_match_hls_socket (void);
+match gfc_match_hls_core (void);
+match gfc_match_hls_cache (void);
+match gfc_match_hls_single (void);
+match gfc_match_hls_end_single (void);
+match gfc_match_hls_barrier (void);
+/* MPC HLS END */
+
 /* decl.c.  */
 
 /* Fortran 2003 c interop.
diff --git a/gcc/fortran/options.c b/gcc/fortran/options.c
index 5a91ec1b2..fcf28efd1 100644
--- a/gcc/fortran/options.c
+++ b/gcc/fortran/options.c
@@ -103,6 +103,17 @@ gfc_init_options (unsigned int decoded_options_count,
   gfc_option.fpe_summary = GFC_FPE_INVALID | GFC_FPE_DENORMAL
 			   | GFC_FPE_ZERO | GFC_FPE_OVERFLOW
 			   | GFC_FPE_UNDERFLOW;
+  
+  /* MPC GLOBAL BEGIN */
+  //~ gfc_option.warn_mpc = 0 ;
+  //~ gfc_option.flag_mpc_privatize = 0 ;
+  /* MPC GLOBAL END */
+
+  /* MPC HLS BEGIN */
+  gfc_option.flag_hls = 0 ;
+  gfc_option.flag_hls_verbose = 0 ;
+  /* MPC HLS END */
+  
   gfc_option.rtcheck = 0;
 
   /* ??? Wmissing-include-dirs is disabled by default in C/C++ but
@@ -404,8 +415,16 @@ gfc_post_options (const char **pfilename)
     lang_hooks.name = "GNU Fortran2008";
   else if (gfc_option.allow_std & GFC_STD_F2003)
     lang_hooks.name = "GNU Fortran2003";
+  /* MPC TLS BEGIN */
+  /* Uncomment the following assignment to enable -Wmpc w/ -Wall */
+  #if 0
+    gfc_option.warn_mpc = setting;
+  #endif
+  /* MPC TLS END */
 
   return gfc_cpp_preprocess_only ();
+
+  
 }
 
 
@@ -562,6 +581,13 @@ gfc_handle_option (size_t scode, const char *arg, int value,
       if (cl_options[code].flags & gfc_option_lang_mask ())
 	break;
       result = false;
+    
+    /* MPC GLOBAL BEGIN */
+    case OPT_Wmpc:
+      //~ gfc_option.warn_mpc = value ;
+      break ;
+    /* MPC GLOBAL END */
+    
       break;
 
     case OPT_fcheck_array_temporaries:
@@ -583,7 +609,22 @@ gfc_handle_option (size_t scode, const char *arg, int value,
     case OPT_ffree_form:
       gfc_option.source_form = FORM_FREE;
       break;
-
+	
+	/* MPC TLS BEGIN */
+    case OPT_fmpc_privatize:
+      //~ gfc_option.flag_mpc_privatize = value ;
+      break ;
+      /* MPC TLS END */
+
+    /* MPC HLS BEGIN */
+    case OPT_fhls:
+      gfc_option.flag_hls = value;
+      break;
+    case OPT_fhls_verbose:
+      gfc_option.flag_hls_verbose = value;
+      break;
+    /* MPC HLS END */
+    
     case OPT_static_libgfortran:
 #ifndef HAVE_LD_STATIC_DYNAMIC
       gfc_fatal_error ("%<-static-libgfortran%> is not supported in this "
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index 0aa736c70..288588ad4 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -969,6 +969,69 @@ decode_omp_directive (void)
   return ST_GET_FCN_CHARACTERISTICS;
 }
 
+/* MPC BEGIN */
+static gfc_statement
+decode_hls_directive (void)
+{
+  locus old_locus;
+  char c;
+
+#ifdef GFC_DEBUG
+  gfc_symbol_state ();
+#endif
+
+  gfc_clear_error ();	/* Clear any pending errors.  */
+  gfc_clear_warning ();	/* Clear any pending warnings.  */
+
+  if (gfc_pure (NULL))
+    {
+      gfc_error_now ("HLS directives at %C may not appear in PURE "
+		     "or ELEMENTAL procedures");
+      gfc_error_recovery ();
+      return ST_NONE;
+    }
+
+  old_locus = gfc_current_locus;
+
+  /* return statement not used here */
+  c = gfc_peek_ascii_char ();
+
+  switch (c)
+    {
+	case 'b':
+		match ( "barrier", gfc_match_hls_barrier, ST_HLS_BARRIER);
+		break;
+	case 'c':
+		match ( "cache", gfc_match_hls_cache, ST_HLS_SCOPE);
+		match ( "core", gfc_match_hls_core, ST_HLS_SCOPE);
+		break;
+	case 'e':
+		match ( "end single", gfc_match_hls_end_single, ST_HLS_END_SINGLE);
+		break;
+    case 'n':
+		match ( "node", gfc_match_hls_node, ST_HLS_SCOPE);
+		match ( "numa", gfc_match_hls_numa, ST_HLS_SCOPE);
+		break;
+	case 's':
+		match ( "socket", gfc_match_hls_socket, ST_HLS_SCOPE);
+		match ( "single", gfc_match_hls_single, ST_HLS_SINGLE);
+		break;
+	}
+
+  /* All else has failed, so give up.  See if any of the matchers has
+     stored an error message of some sort.  */
+
+  if (gfc_error_check () == 0)
+    gfc_error_now ("Unclassifiable HLS directive at %C");
+
+  reject_statement ();
+
+  gfc_error_recovery ();
+
+  return ST_NONE;
+}
+/* MPC END */
+
 static gfc_statement
 decode_gcc_attribute (void)
 {
@@ -1100,15 +1163,40 @@ next_free (void)
 	  return decode_gcc_attribute ();
 
 	}
-      else if (c == '$')
+
+	 #if 0
+      		else if (c == '$')
+      #endif
+    /* MPC END */
+      else if (c == '$' )
 	{
 	  /* Since both OpenMP and OpenACC directives starts with
 	     !$ character sequence, we must check all flags combinations */
 	  if ((flag_openmp || flag_openmp_simd)
 	      && !flag_openacc)
 	    {
-	      verify_token_free ("$omp", 4, last_was_use_stmt);
-	      return decode_omp_directive ();
+		/* MPC OMP BEGIN */
+	  #if 0
+	      	verify_token_free ("$omp", 4, last_was_use_stmt);
+		return decode_omp_directive ();
+	  #else
+		gfc_next_ascii_char ();
+		c = gfc_peek_ascii_char ();
+		
+		if (c == 'o')
+		{
+		  verify_token_free ("omp", 3, last_was_use_stmt);
+	      	  return decode_omp_directive ();
+		}
+	      else if (c == 'h')
+		{
+		  verify_token_free ("hls", 3, last_was_use_stmt);
+		 return decode_hls_directive() ;
+		}
+
+	  #endif
+	  
+	  /* MPC OMP END */
 	    }
 	  else if ((flag_openmp || flag_openmp_simd)
 		   && flag_openacc)
@@ -1229,7 +1317,8 @@ next_fixed (void)
 
 	      return decode_gcc_attribute ();
 	    }
-	  else if (c == '$')
+	  
+      else if (c == '$' )
 	    {
 	      if ((flag_openmp || flag_openmp_simd)
 		  && !flag_openacc)
@@ -1248,6 +1337,16 @@ next_fixed (void)
 			return ST_NONE;
 		      return decode_omp_directive ();
 		    }
+	       
+                  #if 1/* MPC BEGIN */
+		  if (c == 'h' || c == 'H')
+                    {
+	              if ( verify_token_fixed ("hls", 3, last_was_use_stmt) )
+			return decode_hls_directive() ;
+		    }
+		  /* MPC END */
+                  #endif
+
 		  else if (c == 'a' || c == 'A')
 		    {
 		      if (!verify_token_fixed ("cc", 2, last_was_use_stmt))
@@ -1426,7 +1525,8 @@ next_statement (void)
   case ST_OMP_TARGET_UPDATE: case ST_ERROR_STOP: case ST_SYNC_ALL: \
   case ST_SYNC_IMAGES: case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK: \
   case ST_EVENT_POST: case ST_EVENT_WAIT: \
-  case ST_OACC_UPDATE: case ST_OACC_WAIT: case ST_OACC_CACHE: \
+  case ST_HLS_BARRIER: \
+  case ST_OACC_UPDATE: case ST_OACC_WAIT: case ST_OACC_CACHE:\
   case ST_OACC_ENTER_DATA: case ST_OACC_EXIT_DATA
 
 /* Statements that mark other executable statements.  */
@@ -1440,6 +1540,7 @@ next_statement (void)
   case ST_OMP_DO: case ST_OMP_PARALLEL_DO: case ST_OMP_ATOMIC: \
   case ST_OMP_WORKSHARE: case ST_OMP_PARALLEL_WORKSHARE: \
   case ST_OMP_TASK: case ST_OMP_TASKGROUP: case ST_OMP_SIMD: \
+  case ST_HLS_SINGLE:\
   case ST_OMP_DO_SIMD: case ST_OMP_PARALLEL_DO_SIMD: case ST_OMP_TARGET: \
   case ST_OMP_TARGET_DATA: case ST_OMP_TARGET_TEAMS: \
   case ST_OMP_TARGET_TEAMS_DISTRIBUTE: \
@@ -1462,6 +1563,7 @@ next_statement (void)
 #define case_decl case ST_ATTR_DECL: case ST_COMMON: case ST_DATA_DECL: \
   case ST_EQUIVALENCE: case ST_NAMELIST: case ST_STATEMENT_FUNCTION: \
   case ST_TYPE: case ST_INTERFACE: case ST_PROCEDURE: case ST_OACC_ROUTINE: \
+  case ST_HLS_SCOPE: \
   case ST_OACC_DECLARE
 
 /* OpenMP declaration statements.  */
@@ -2287,6 +2389,22 @@ gfc_ascii_statement (gfc_statement st)
     case ST_OMP_WORKSHARE:
       p = "!$OMP WORKSHARE";
       break;
+      
+    /* MPC HLS BEGIN */
+    case ST_HLS_SCOPE:
+      p = "!$HLS";
+      break;
+    case ST_HLS_SINGLE:
+      p = "!$HLS SINGLE";
+      break;
+    case ST_HLS_END_SINGLE:
+      p = "!$HLS END SINGLE";
+      break;
+    case ST_HLS_BARRIER:
+      p = "!$HLS BARRIER";
+      break;
+    /* MPC HLS END */
+    
     default:
       gfc_internal_error ("gfc_ascii_statement(): Bad statement code");
     }
@@ -5079,6 +5197,34 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)
   pop_state ();
 }
 
+/* MPC HLS BEGIN */
+static void
+parse_hls_structured_block (gfc_statement hls_st)
+{
+  gfc_statement st;
+  gfc_code *cp, *np;
+  gfc_state_data s;
+
+  accept_statement (hls_st);
+
+  cp = gfc_state_stack->tail;
+  push_state (&s, COMP_HLS_STRUCTURED_BLOCK, NULL);
+  np = new_level (cp);
+  np->op = cp->op;
+  np->block = NULL;
+
+  st = parse_executable (ST_NONE);
+  if (st == ST_NONE)
+	  unexpected_eof ();
+  else if (st != ST_HLS_END_SINGLE)
+	unexpected_statement (st);
+
+  gfc_clear_new_st ();
+  gfc_commit_symbols ();
+  gfc_warning_check ();
+  pop_state ();
+}
+/* MPC HLS END */
 
 /* Accept a series of executable statements.  We return the first
    statement that doesn't fit to the caller.  Any block statements are
@@ -5243,7 +5389,13 @@ parse_executable (gfc_statement st)
 	case ST_OMP_ATOMIC:
 	  st = parse_omp_oacc_atomic (true);
 	  continue;
-
+	  
+    /* MPC HLS BEGIN */
+	case ST_HLS_SINGLE:
+	  parse_hls_structured_block (st);
+	  break;
+	/* MPC HLS END */
+	
 	default:
 	  return st;
 	}
diff --git a/gcc/fortran/parse.h b/gcc/fortran/parse.h
index e8f71cf30..42381990c 100644
--- a/gcc/fortran/parse.h
+++ b/gcc/fortran/parse.h
@@ -30,7 +30,8 @@ enum gfc_compile_state
   COMP_DERIVED_CONTAINS, COMP_BLOCK, COMP_ASSOCIATE, COMP_IF,
   COMP_STRUCTURE, COMP_UNION, COMP_MAP,
   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,
-  COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT
+  COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL, COMP_DO_CONCURRENT,
+  COMP_HLS_STRUCTURED_BLOCK /* MPC HLS */
 };
 
 /* Stack element for the current compilation state.  These structures
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index 77f8c10bf..673be9d07 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -9482,7 +9482,13 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)
 	case EXEC_OMP_TEAMS_DISTRIBUTE_SIMD:
 	case EXEC_OMP_WORKSHARE:
 	  break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  break;
+	/* MPC HLS END */
+	
 	default:
 	  gfc_internal_error ("gfc_resolve_blocks(): Bad block type");
 	}
@@ -10821,7 +10827,14 @@ start:
 	  gfc_resolve_omp_directive (code, ns);
 	  omp_workshare_flag = omp_workshare_save;
 	  break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_BARRIER:
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  break;
+	/* MPC HLS END */
+	
 	default:
 	  gfc_internal_error ("gfc_resolve_code(): Bad statement code");
 	}
@@ -14407,6 +14420,17 @@ resolve_symbol (gfc_symbol *sym)
     gfc_error ("!$OMP DECLARE TARGET variable %qs at %L isn't SAVEd",
 	       sym->name, &sym->declared_at);
 
+	      
+	/* MPC HLS BEGIN */
+  if (sym->attr.hls_scope && !sym->attr.save && !sym->ns->save_all
+      && (!sym->attr.in_common
+	  && sym->module == NULL
+	  && (sym->ns->proc_name == NULL
+	      || sym->ns->proc_name->attr.flavor != FL_MODULE)))
+    gfc_error ("HLS at %L isn't SAVEd", &sym->declared_at);
+  /* MPC HLS END */
+
+
   /* If we have come this far we can apply default-initializers, as
      described in 14.7.5, to those variables that have not already
      been assigned one.  */
diff --git a/gcc/fortran/scanner.c b/gcc/fortran/scanner.c
index 6a7a5b68b..52c679f95 100644
--- a/gcc/fortran/scanner.c
+++ b/gcc/fortran/scanner.c
@@ -54,10 +54,14 @@ along with GCC; see the file COPYING3.  If not see
 gfc_directorylist *include_dirs, *intrinsic_modules_dirs;
 
 static gfc_file *file_head, *current_file;
-
 static int continue_flag, end_flag, gcc_attribute_flag;
 /* If !$omp/!$acc occurred in current comment line.  */
 static int openmp_flag, openacc_flag;
+
+/* MPC HLS BEGIN */
+static int hls_flag;
+static locus hls_locus;
+/* MPC HLS END */
 static int continue_count, continue_line;
 static locus openmp_locus;
 static locus openacc_locus;
@@ -905,6 +909,36 @@ skip_free_comments (void)
 			  next_char();
 			  c = next_char();
 			}
+		    /* MPC HLS BEGIN */
+		  else if (c == 'h' || c == 'H')
+		    {
+		      if (((c = next_char ()) == 'l' || c == 'L')
+			  && ((c = next_char ()) == 's' || c == 'S'))
+			{
+			  if ((c = next_char ()) == ' ' || c == '\t'
+			      || continue_flag)
+			    {
+			      while (gfc_is_whitespace (c))
+				c = next_char ();
+			      if (c != '\n' && c != '!')
+				{
+				  hls_flag = 1;
+				  hls_locus = old_loc;
+				  gfc_current_locus = start;
+				  return false;
+				}
+			    }
+			  else
+			    gfc_warning_now (0, "!$HLS at %C starts a commented "
+					     "line as it neither is followed "
+					     "by a space nor is a "
+					     "continuation line");
+			}
+		      gfc_current_locus = old_loc;
+		      next_char ();
+		      c = next_char ();
+		    }
+                    /* MPC HLS END */
 		      if (continue_flag || c == ' ' || c == '\t')
 			{
 			  gfc_current_locus = old_loc;
@@ -925,7 +959,10 @@ skip_free_comments (void)
 
   if (openmp_flag && at_bol)
     openmp_flag = 0;
-
+  /* MPC HLS BEGIN */
+  if (hls_flag && at_bol)
+    hls_flag = 0;
+/* MPC HLS END */
   if (openacc_flag && at_bol)
     openacc_flag = 0;
 
@@ -1074,6 +1111,32 @@ skip_fixed_comments (void)
 		}
 	      gfc_current_locus = start;
 	    }
+		     /* MPC HLS BEGIN */
+		  else if (c == 'h' || c == 'H')
+		    {
+		      if (((c = next_char ()) == 'l' || c == 'L')
+			  && ((c = next_char ()) == 's' || c == 'S'))
+			{
+			  c = next_char ();
+			  if (c != '\n'
+			      && ((hls_flag && continue_flag)
+				  || c == ' ' || c == '\t' || c == '0'))
+			    {
+			      do
+				c = next_char ();
+			      while (gfc_is_whitespace (c));
+			      if (c != '\n' && c != '!')
+				{
+				  /* Canonicalize to *$hls.  */
+				  *start.nextc = '*';
+				  hls_flag = 1;
+				  gfc_current_locus = start;
+				  return;
+				}
+			    }
+			}
+		    }
+		   /* MPC HLS END */
 
 	  if (flag_openacc && !(flag_openmp || flag_openmp_simd))
 	    {
@@ -1186,6 +1249,9 @@ check_for_digits:
 
   openmp_flag = 0;
   openacc_flag = 0;
+  /* MPC HLS BEGIN */
+  hls_flag = 0;
+  /* MPC HLS END */
   gcc_attribute_flag = 0;
   gfc_current_locus = start;
 }
@@ -1215,6 +1281,9 @@ gfc_next_char_literal (gfc_instring in_string)
 {
   locus old_loc;
   int i, prev_openmp_flag, prev_openacc_flag;
+  /* MPC HLS BEGIN */
+  int prev_hls_flag;
+  /* MPC HLS END */
   gfc_char_t c;
 
   continue_flag = 0;
@@ -1231,6 +1300,9 @@ restart:
   if (gfc_current_form == FORM_FREE)
     {
       bool openmp_cond_flag;
+       /* MPC HLS BEGIN */
+      bool hls_cond_flag;
+      /* MPC HLS END */
 
       if (!in_string && c == '!')
 	{
@@ -1238,7 +1310,14 @@ restart:
 	      && memcmp (&gfc_current_locus, &gcc_attribute_locus,
 		 sizeof (gfc_current_locus)) == 0)
 	    goto done;
-
+	  
+	  /* MPC HLS BEGIN */
+	  if (hls_flag
+	      && memcmp (&gfc_current_locus, &hls_locus,
+		 sizeof (gfc_current_locus)) == 0)
+	    goto done;
+          /* MPC HLS END */
+          
 	  if (openmp_flag
 	      && memcmp (&gfc_current_locus, &openmp_locus,
 		 sizeof (gfc_current_locus)) == 0)
@@ -1311,6 +1390,9 @@ restart:
       if (flag_openacc)
 	prev_openacc_flag = openacc_flag;
 
+      /* MPC HLS BEGIN */
+      prev_hls_flag = hls_flag;
+      /* MPC HLS END */
       continue_flag = 1;
       if (c == '!')
 	skip_comment_line ();
@@ -1335,6 +1417,9 @@ restart:
 
       /* Now find where it continues. First eat any comment lines.  */
       openmp_cond_flag = skip_free_comments ();
+       /* MPC HLS BEGIN */
+      hls_cond_flag = openmp_cond_flag;
+      /* MPC HLS END */
 
       if (gfc_current_locus.lb != NULL
 	  && continue_line < gfc_linebuf_linenum (gfc_current_locus.lb))
@@ -1348,7 +1433,7 @@ restart:
 	    c = '&';
 	    goto done;
 	  }
-
+	
       if (flag_openacc)
 	if (prev_openacc_flag != openacc_flag && !openmp_flag)
 	  {
@@ -1358,6 +1443,16 @@ restart:
 	    goto done;
 	  }
 
+	   /* MPC HLS BEGIN */
+      if (prev_hls_flag != hls_flag)
+	{
+	  gfc_current_locus = old_loc;
+	  hls_flag = prev_hls_flag;
+	  c = '&';
+	  goto done;
+	}
+	/* MPC HLS END */
+	
       /* Now that we have a non-comment line, probe ahead for the
 	 first non-whitespace character.  If it is another '&', then
 	 reading starts at the next character, otherwise we must back
@@ -1391,7 +1486,7 @@ restart:
 	  while (gfc_is_whitespace (c))
 	    c = next_char ();
 	}
-
+	  
       /* In case we have an OpenMP directive continued by OpenACC
 	 sentinel, or vice versa, we get both openmp_flag and
 	 openacc_flag on.  */
@@ -1406,6 +1501,20 @@ restart:
 	      if (i == 4)
 		old_loc = gfc_current_locus;
 	    }
+	  /* MPC HLS BEGIN */
+      if (hls_flag)
+	{
+	  for (i = 0; i < 5; i++, c = next_char ())
+	    {
+	      gcc_assert (gfc_wide_tolower (c) == (unsigned char) "!$hls"[i]);
+	      if (i == 4)
+		old_loc = gfc_current_locus;
+	    }
+	  while (gfc_is_whitespace (c))
+	    c = next_char ();
+	}
+      /* MPC HLS END */
+      
 	  gfc_error (is_openmp ? "Wrong OpenACC continuation at %C: "
 		     "expected !$ACC, got !$OMP"
 		     : "Wrong OpenMP continuation at %C: "
@@ -1428,6 +1537,10 @@ restart:
 	     continuation line only optionally.  */
 	  else if (openmp_flag || openacc_flag || openmp_cond_flag)
 	    gfc_current_locus.nextc--;
+	   /* MPC HLS BEGIN */
+	  else if (hls_flag || hls_cond_flag)
+	    gfc_current_locus.nextc--;
+	  /* MPC HLS END */
 	  else
 	    {
 	      c = ' ';
@@ -1469,6 +1582,9 @@ restart:
       if (flag_openacc)
 	prev_openacc_flag = openacc_flag;
 
+      /* MPC HLS BEGIN */
+      prev_hls_flag = hls_flag;
+      /* MPC HLS END */
       continue_flag = 1;
       old_loc = gfc_current_locus;
 
@@ -1487,6 +1603,15 @@ restart:
 	  goto not_continuation;
 	}
 
+#if 1 /* MPC HLS BEGIN */
+    
+    if (hls_flag != prev_hls_flag)
+	{
+	  hls_flag = prev_hls_flag;
+	  goto not_continuation;
+	}
+#endif /* MPC HLS END */
+
       /* In case we have an OpenMP directive continued by OpenACC
 	 sentinel, or vice versa, we get both openmp_flag and
 	 openacc_flag on.  */
@@ -1504,15 +1629,19 @@ restart:
 		     : "Wrong OpenMP continuation at %C: "
 		     "expected !$OMP, got !$ACC");
 	}
+      #if 0 /* MPC HLS BEGIN */
       else if (!openmp_flag && !openacc_flag)
-	for (i = 0; i < 5; i++)
+      #else
+      else if (!openmp_flag && !openacc_flag && !hls_flag)
+      #endif /* MPC HLS END */
+	  for (i = 0; i < 5; i++)
 	  {
 	    c = next_char ();
 	    if (c != ' ')
 	      goto not_continuation;
 	  }
       else if (openmp_flag)
-	for (i = 0; i < 5; i++)
+	  for (i = 0; i < 5; i++)
 	  {
 	    c = next_char ();
 	    if (gfc_wide_tolower (c) != (unsigned char) "*$omp"[i])
@@ -1525,7 +1654,16 @@ restart:
 	    if (gfc_wide_tolower (c) != (unsigned char) "*$acc"[i])
 	      goto not_continuation;
 	  }
-
+      #if 1 /* MPC HLS BEGIN */
+      else if (hls_flag)
+	for (i = 0; i < 5; i++)
+	  {
+	    c = next_char ();
+	    if (gfc_wide_tolower (c) != (unsigned char) "*$hls"[i])
+	      goto not_continuation;
+	  }
+      #endif/* MPC HLS END */
+      
       c = next_char ();
       if (c == '0' || c == ' ' || c == '\n')
 	goto not_continuation;
diff --git a/gcc/fortran/st.c b/gcc/fortran/st.c
index 7395497dc..926fa1284 100644
--- a/gcc/fortran/st.c
+++ b/gcc/fortran/st.c
@@ -258,7 +258,14 @@ gfc_free_statement (gfc_code *p)
     case EXEC_OMP_TASKWAIT:
     case EXEC_OMP_TASKYIELD:
       break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_BARRIER:
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  break;
+	/* MPC HLS END */
+	
     default:
       gfc_internal_error ("gfc_free_statement(): Bad statement");
     }
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index 0ee7decff..7bdea8e84 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -379,8 +379,11 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
   static const char *oacc_declare_copyin = "OACC DECLARE COPYIN";
   static const char *oacc_declare_create = "OACC DECLARE CREATE";
   static const char *oacc_declare_deviceptr = "OACC DECLARE DEVICEPTR";
-  static const char *oacc_declare_device_resident =
-						"OACC DECLARE DEVICE_RESIDENT";
+  static const char *oacc_declare_device_resident = "OACC DECLARE DEVICE_RESIDENT";
+/* MPC HLS BEGIN */
+  static const char *hls_scope = "HLS SCOPE";
+  static const char *hls_level = "HLS LEVEL";
+  /* MPC HLS END */
 
   const char *a1, *a2;
   int standard;
@@ -473,6 +476,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
   conf (dummy, intrinsic);
   conf (dummy, threadprivate);
   conf (dummy, omp_declare_target);
+  /* MPC HLS BEGIN */
+  conf (dummy, hls_scope);
+  conf (dummy, hls_level);
+  /* MPC HLS END */
   conf (pointer, target);
   conf (pointer, intrinsic);
   conf (pointer, elemental);
@@ -521,6 +528,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
   conf (in_equivalence, oacc_declare_copyin);
   conf (in_equivalence, oacc_declare_deviceptr);
   conf (in_equivalence, oacc_declare_device_resident);
+  /* MPC HLS BEGIN */
+  conf (in_equivalence, hls_scope);
+  conf (in_equivalence, hls_level);
+  /* MPC HLS END */
 
   conf (dummy, result);
   conf (entry, result);
@@ -574,6 +585,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
   conf (cray_pointee, oacc_declare_copyin);
   conf (cray_pointee, oacc_declare_deviceptr);
   conf (cray_pointee, oacc_declare_device_resident);
+  /* MPC HLS BEGIN */
+  conf (cray_pointee, hls_scope);
+  conf (cray_pointee, hls_level);
+  /* MPC HLS END */
 
   conf (data, dummy);
   conf (data, function);
@@ -673,6 +688,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
       conf2 (oacc_declare_copyin);
       conf2 (oacc_declare_deviceptr);
       conf2 (oacc_declare_device_resident);
+      /* MPC HLS BEGIN */
+      conf2 (hls_scope);
+      conf2 (hls_level);
+      /* MPC HLS END */
 
       if (attr->access == ACCESS_PUBLIC || attr->access == ACCESS_PRIVATE)
 	{
@@ -714,6 +733,12 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
 	  conf2 (function);
 	  if (!attr->proc_pointer)
 	    conf2 (threadprivate);
+	  
+	  /* MPC HLS BEGIN */
+	  conf2 (hls_scope);
+	  conf2 (hls_level);
+	  /* MPC HLS END */
+	  
 	}
 
       if (!attr->proc_pointer)
@@ -733,6 +758,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
 	case PROC_DUMMY:
 	  conf2 (result);
 	  conf2 (threadprivate);
+	  /* MPC HLS BEGIN */
+	  conf2 (hls_scope);
+	  conf2 (hls_level);
+	  /* MPC HLS END */
 	  break;
 
 	default:
@@ -753,6 +782,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
       conf2 (function);
       conf2 (subroutine);
       conf2 (threadprivate);
+      /* MPC HLS BEGIN */
+      conf2 (hls_scope);
+      conf2 (hls_level);
+      /* MPC HLS END */
       conf2 (result);
       conf2 (omp_declare_target);
       conf2 (oacc_declare_create);
@@ -785,6 +818,10 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)
       conf2 (volatile_);
       conf2 (asynchronous);
       conf2 (threadprivate);
+      /* MPC HLS BEGIN */
+      conf2 (hls_scope);
+      conf2 (hls_level);
+      /* MPC HLS END */
       conf2 (value);
       conf2 (codimension);
       conf2 (result);
@@ -957,6 +994,32 @@ gfc_add_codimension (symbol_attribute *attr, const char *name, locus *where)
   return check_conflict (attr, name, where);
 }
 
+/* MPC HLS BEGIN */
+bool
+gfc_add_hls_scope (symbol_attribute *attr, const char *name, locus *where, gfc_hls_scope scope, unsigned int level)
+{
+  if (check_used (attr, name, where))
+    return false;
+
+  if (attr->hls_scope == scope) 
+    {
+      duplicate_attr ("HLS_SCOPE", where);
+      return false;
+    }
+  
+  if ( attr->hls_scope != HLS_SCOPE_NONE )
+    {
+      if (where == NULL)
+        where = &gfc_current_locus;
+      gfc_error ("Variable %s at %L already specified HLS", name, where);
+      return false;
+    }
+
+  attr->hls_scope = scope;
+  attr->hls_level = level;
+  return check_conflict (attr, name, where);
+}
+/* MPC HLS END */
 
 bool
 gfc_add_dimension (symbol_attribute *attr, const char *name, locus *where)
@@ -1920,8 +1983,15 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)
     goto fail;
   if (src->target && !gfc_add_target (dest, where))
     goto fail;
-  if (src->dummy && !gfc_add_dummy (dest, NULL, where))
+   if (src->dummy && !gfc_add_dummy (dest, NULL, where))
     goto fail;
+  
+  /* MPC HLS BEGIN */
+  if (src->hls_scope != HLS_SCOPE_NONE
+      && gfc_add_hls_scope (dest, NULL, where, src->hls_scope, src->hls_level) == false)
+  	goto fail;
+  /* MPC HLS END */
+
   if (src->result && !gfc_add_result (dest, NULL, where))
     goto fail;
   if (src->entry)
diff --git a/gcc/fortran/trans-common.c b/gcc/fortran/trans-common.c
index 9467eac0c..e8ed9ca62 100644
--- a/gcc/fortran/trans-common.c
+++ b/gcc/fortran/trans-common.c
@@ -126,6 +126,9 @@ static segment_info * current_segment;
    tree is the identifier.  */
 static std::map<tree, tree> gfc_map_of_all_commons;
 
+/* MPC BEGIN */
+extern bool mpc_decl_match_invalid_header(tree decl);
+/* MPC END */
 
 /* Make a segment_info based on a symbol.  */
 
@@ -454,8 +457,86 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)
 
       gfc_set_decl_location (decl, &com->where);
 
-      if (com->threadprivate)
+      if(com->threadprivate)
+#if 1 /* MPC OMP FORTRAN THREADPRIVATE */
+      {
+      set_decl_tls_model (decl, TLS_MODEL_MPC_OPENMP);
+       	/* Verbose mode */
+       	if ( flag_openmp_verbose && DECL_NAME(decl) ) 
+       	{
+        	fprintf( stderr, "MPC-OPENMP: Found threadprivate variable %s (file %s line %d)\n"
+             	, IDENTIFIER_POINTER( DECL_NAME(decl) )
+             	, DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+       	}
+      }
+#else /* MPC OMP FORTRAN THREADPRIVATE */
 	set_decl_tls_model (decl, decl_default_tls_model (decl));
+#endif /* MPC OMP FORTRAN THREADPRIVATE */
+/* MPC HLS BEGIN */
+      switch(com->hls_scope)
+      {
+        case HLS_SCOPE_NODE:
+          set_decl_tls_model (decl, TLS_MODEL_HLS_NODE);
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope node of variable %s (file %s line %d)\n",
+              IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_NUMA:
+		  if ( com->hls_level == 1 )
+              set_decl_tls_model (decl, TLS_MODEL_HLS_NUMA_LEVEL_1);
+		  else if ( com->hls_level == 2 )
+              set_decl_tls_model (decl, TLS_MODEL_HLS_NUMA_LEVEL_2);
+		  else
+			gfc_internal_error ("HLS level for NUMA scope is invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope numa level %d of variable %s (file %s line %d)\n",
+              com->hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_SOCKET:
+          set_decl_tls_model (decl, TLS_MODEL_HLS_SOCKET);
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope socket of variable %s (file %s line %d)\n",
+              IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_CACHE:
+		  if ( com->hls_level == 1 )
+              set_decl_tls_model (decl, TLS_MODEL_HLS_CACHE_LEVEL_1);
+		  else if ( com->hls_level == 2 )
+              set_decl_tls_model (decl, TLS_MODEL_HLS_CACHE_LEVEL_2);
+		  else if ( com->hls_level == 3 )
+      		  set_decl_tls_model (decl, TLS_MODEL_HLS_CACHE_LEVEL_3);
+		  else
+			gfc_internal_error ("HLS level for CACHE scope invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope cache level %d of variable %s (file %s line %d)\n",
+              com->hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_CORE:
+          set_decl_tls_model (decl, TLS_MODEL_HLS_CORE);
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope core of variable %s (file %s line %d)\n",
+              IDENTIFIER_POINTER( DECL_NAME(decl) ),
+              DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+            break;
+        case HLS_SCOPE_NONE:
+          /* do not privatize variables modified by hls or omp threadprivate pragmas */ 
+          if ( flag_mpc_privatize  && ! com->threadprivate && !mpc_decl_match_invalid_header(decl)) {
+	fprintf( stderr, 
+	    "(Front-end Fortran) "
+	    "Automatic privatization to MPC task (variable %s in file %s line %d)\n",
+	    IDENTIFIER_POINTER( DECL_NAME(decl) ), 
+	    DECL_SOURCE_FILE(decl),
+	    DECL_SOURCE_LINE(decl) ) ;
+        set_decl_tls_model (decl, TLS_MODEL_MPC_TASK);
+      }
+        default:
+          break;
+      }
+	/* MPC HLS END */
 
       if (com->omp_declare_target)
 	DECL_ATTRIBUTES (decl)
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 01756ed32..673ab5850 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "trans.h"
 #include "stringpool.h"
 #include "cgraph.h"
+#include "diagnostic-core.h"
 #include "fold-const.h"
 #include "stor-layout.h"
 #include "varasm.h"
@@ -213,6 +214,9 @@ tree gfor_fndecl_dgemm;
 tree gfor_fndecl_cgemm;
 tree gfor_fndecl_zgemm;
 
+/* MPC BEGIN */
+extern bool mpc_decl_match_invalid_header(tree decl);
+/* MPC END */
 
 static void
 gfc_add_decl_to_parent_function (tree decl)
@@ -659,10 +663,95 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)
     TREE_STATIC (decl) = 1;
 
   /* Handle threadprivate variables.  */
+
+
+
   if (sym->attr.threadprivate
       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))
+  {
+    #if 1 /* MPC OMP FORTRAN THREADPRIVATE */
+    set_decl_tls_model (decl, TLS_MODEL_MPC_OPENMP);
+
+    /* Verbose mode */
+    if ( flag_openmp_verbose && DECL_NAME(decl) ) 
+    {
+      fprintf( stderr, "MPC-OPENMP: Found threadprivate variable %s (file %s line %d)\n"
+	  , IDENTIFIER_POINTER( DECL_NAME(decl) )
+	 , DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+    }
+    #else /* MPC OMP FORTRAN THREADPRIVATE */ 
     set_decl_tls_model (decl, decl_default_tls_model (decl));
+    #endif /* MPC OMP FORTRAN THREADPRIVATE */
+  }
+  /* MPC HLS BEGIN */
+  if ( TREE_STATIC (decl) || DECL_EXTERNAL (decl) )
+    {
+      switch(sym->attr.hls_scope)
+      {
+        case HLS_SCOPE_NODE:
+      	  set_decl_tls_model (decl, TLS_MODEL_HLS_NODE);
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope node of variable %s (file %s line %d)\n",
+            IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_NUMA:
+		  if ( sym->attr.hls_level == 1 )
+      		  set_decl_tls_model (decl, TLS_MODEL_HLS_NUMA_LEVEL_1);
+		  else if ( sym->attr.hls_level == 2 )
+              set_decl_tls_model (decl, TLS_MODEL_HLS_NUMA_LEVEL_2);
+		  else
+			internal_error ("HLS level for NUMA scope is invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope numa level %d of variable %s (file %s line %d)\n",
+			sym->attr.hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_SOCKET:
+          set_decl_tls_model (decl, TLS_MODEL_HLS_SOCKET);
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope socket of variable %s (file %s line %d)\n",
+            IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_CACHE:
+		  if ( sym->attr.hls_level == 1 )
+              set_decl_tls_model (decl, TLS_MODEL_HLS_CACHE_LEVEL_1);
+		  else if ( sym->attr.hls_level == 2 )
+              set_decl_tls_model (decl, TLS_MODEL_HLS_CACHE_LEVEL_2);
+		  else if ( sym->attr.hls_level == 3 )
+              set_decl_tls_model (decl, TLS_MODEL_HLS_CACHE_LEVEL_3);
+		  else
+			internal_error ("HLS level for CACHE scope invalid");
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope cache level %d of variable %s (file %s line %d)\n",
+			sym->attr.hls_level, IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_CORE:
+          set_decl_tls_model (decl, TLS_MODEL_HLS_CORE);
+          if ( gfc_option.flag_hls_verbose && DECL_NAME(decl) )
+            fprintf( stderr, "HLS: Privatization to scope core of variable %s (file %s line %d)\n",
+            IDENTIFIER_POINTER( DECL_NAME(decl) ),
+            DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+          break;
+        case HLS_SCOPE_NONE:
+        default:
+	  break;
+      }
 
+      if ( flag_mpc_privatize && !sym->attr.threadprivate && !sym->attr.hls_scope && !mpc_decl_match_invalid_header(decl)){
+        fprintf( stderr, 
+          "(Front-end Fortran) "
+          "Automatic privatization to MPC task (variable %s in file %s line %d)\n",
+          IDENTIFIER_POINTER( DECL_NAME(decl) ), 
+          DECL_SOURCE_FILE(decl),
+          DECL_SOURCE_LINE(decl) ) ;
+          set_decl_tls_model (decl, TLS_MODEL_MPC_TASK);
+      }
+    }
+  /* MPC HLS END */
+  
   gfc_finish_decl_attrs (decl, &sym->attr);
 }
 
@@ -1821,7 +1910,21 @@ get_proc_pointer_decl (gfc_symbol *sym)
   /* Handle threadprivate procedure pointers.  */
   if (sym->attr.threadprivate
       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))
+    
+    #if 1 /* MPC OMP FORTRAN THREADPRIVATE */
+    {
+      set_decl_tls_model (decl, TLS_MODEL_MPC_OPENMP);
+      /* Verbose mode */
+      if ( flag_openmp_verbose && DECL_NAME(decl) ) 
+      {
+        fprintf( stderr, "MPC-OPENMP: Found threadprivate variable %s (file %s line %d)\n"
+       , IDENTIFIER_POINTER( DECL_NAME(decl) )
+      , DECL_SOURCE_FILE(decl), DECL_SOURCE_LINE(decl) ) ;
+      }
+    }
+#else /* MPC OMP FORTRAN THREADPRIVATE */
     set_decl_tls_model (decl, decl_default_tls_model (decl));
+#endif /* MPC OMP FORTRAN THREADPRIVATE */
 
   attributes = add_attributes_to_decl (sym->attr, NULL_TREE);
   decl_attributes (&decl, attributes, 0);
@@ -6341,7 +6444,11 @@ gfc_generate_function_code (gfc_namespace * ns)
   gfc_traverse_ns (ns, gfc_emit_parameter_debug_info);
 
   if (sym->attr.is_main_program)
+  {
+    /* force the main program to be noinline */
+    DECL_UNINLINABLE(fndecl) = 1;
     create_main_function (fndecl);
+  }
 
   current_procedure_symbol = previous_procedure_symbol;
 }
diff --git a/gcc/fortran/trans-stmt.h b/gcc/fortran/trans-stmt.h
index f9c8e74e1..448160fcd 100644
--- a/gcc/fortran/trans-stmt.h
+++ b/gcc/fortran/trans-stmt.h
@@ -70,6 +70,11 @@ void gfc_trans_omp_declare_simd (gfc_namespace *);
 tree gfc_trans_oacc_directive (gfc_code *);
 tree gfc_trans_oacc_declare (gfc_namespace *);
 
+/* MPC HLS BEGIN */
+/* hls.c */
+tree gfc_trans_hls_directive (gfc_code *);
+/* MPC HLS END */
+
 /* trans-io.c */
 tree gfc_trans_open (gfc_code *);
 tree gfc_trans_close (gfc_code *);
diff --git a/gcc/fortran/trans.c b/gcc/fortran/trans.c
index c6688d351..da8eb93d0 100644
--- a/gcc/fortran/trans.c
+++ b/gcc/fortran/trans.c
@@ -1934,7 +1934,15 @@ trans_code (gfc_code * code, tree cond)
 	case EXEC_OMP_WORKSHARE:
 	  res = gfc_trans_omp_directive (code);
 	  break;
-
+	
+	/* MPC HLS BEGIN */
+	case EXEC_HLS_BARRIER:
+	case EXEC_HLS_SINGLE:
+	case EXEC_HLS_SINGLE_NOWAIT:
+	  res = gfc_trans_hls_directive (code);
+	  break;
+	/* MPC HLS END */
+	
 	case EXEC_OACC_CACHE:
 	case EXEC_OACC_WAIT:
 	case EXEC_OACC_UPDATE:
diff --git a/gcc/fortran/types.def b/gcc/fortran/types.def
index 8780b761d..ff0e56497 100644
--- a/gcc/fortran/types.def
+++ b/gcc/fortran/types.def
@@ -89,6 +89,7 @@ DEF_FUNCTION_TYPE_1 (BT_FN_VOID_INT, BT_VOID, BT_INT)
 DEF_FUNCTION_TYPE_1 (BT_FN_BOOL_INT, BT_BOOL, BT_INT)
 
 DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)
+DEF_POINTER_TYPE (BT_PTR_FN_PTR_PTR, BT_FN_PTR_PTR)
 
 DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_LONGPTR_LONGPTR,
                      BT_BOOL, BT_PTR_LONG, BT_PTR_LONG)
@@ -202,7 +203,6 @@ DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_VPTR_PTR_I16_BOOL_INT_INT,
 		     BT_INT)
 DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_SIZE_VPTR_PTR_PTR_INT_INT, BT_BOOL, BT_SIZE,
 		     BT_VOLATILE_PTR, BT_PTR, BT_PTR, BT_INT, BT_INT)
-
 DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_UINT,
                      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,
 		     BT_LONG, BT_LONG, BT_LONG, BT_UINT)
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 0f042b0f1..5e6406e8f 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -1007,6 +1007,9 @@ proper position among the other output files.  */
 /* We pass any -flto flags on to the linker, which is expected
    to understand them.  In practice, this means it had better be collect2.  */
 /* %{e*} includes -export-dynamic; see comment in common.opt.  */
+
+/* MPC OMP begin */
+#if 0
 #ifndef LINK_COMMAND_SPEC
 #define LINK_COMMAND_SPEC "\
 %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
@@ -1028,6 +1031,26 @@ proper position among the other output files.  */
     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
     %{!nostdlib:%{!nostartfiles:%E}} %{T*}  \n%(post_link) }}}}}}"
 #endif
+#endif
+#ifndef LINK_COMMAND_SPEC
+#define LINK_COMMAND_SPEC "\
+%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
+    %(linker) " \
+    LINK_PLUGIN_SPEC \
+    "%{flto|flto=*:%<fcompare-debug*} \
+    %{flto} %{flto=*} %l " LINK_PIE_SPEC \
+   "%X %{o*} %{e*} %{N} %{n} %{r}\
+    %{s} %{t} %{u*} %{z} %{Z} %{!nostdlib:%{!nostartfiles:%S}}\
+    %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\
+    %{fgnu-tm:%:include(libitm.spec)%(link_itm)}\
+    %(mflib) " STACK_SPLIT_SPEC "\
+    %{fprofile-arcs|fprofile-generate*|coverage:-lgcov}\
+    %{fsanitize=address:" LIBASAN_SPEC "%{static:%ecannot specify -static with -fsanitize=address}}\
+    %{fsanitize=thread:" LIBTSAN_SPEC "}\
+    %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
+    %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}"
+#endif
+/* MPC OMP END */
 
 #ifndef LINK_LIBGCC_SPEC
 /* Generate -L options for startfile prefix list.  */
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index 7857a5edc..d84654e18 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -6175,14 +6175,24 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)
   if (is_global_var (decl))
     {
       /* Threadprivate variables are predetermined.  */
+      /* MPC OMP BEGIN / MPC TLS BEGIN */
+#if 0
       if (DECL_THREAD_LOCAL_P (decl))
+#endif
+      if (DECL_MPC_THREAD_LOCAL_P (decl))
+      /* MPC OMP END / MPC TLS END */
 	return omp_notice_threadprivate_variable (ctx, decl, NULL_TREE);
 
       if (DECL_HAS_VALUE_EXPR_P (decl))
 	{
 	  tree value = get_base_address (DECL_VALUE_EXPR (decl));
 
+	  /* MPC OMP BEGIN / MPC TLS BEGIN */
+#if 0
 	  if (value && DECL_P (value) && DECL_THREAD_LOCAL_P (value))
+#endif
+	  if (value && DECL_P (value) && DECL_MPC_THREAD_LOCAL_P (value))
+	  /* MPC OMP END / MPC TLS END */
 	    return omp_notice_threadprivate_variable (ctx, decl, value);
 	}
 
diff --git a/gcc/hls-builtins.def b/gcc/hls-builtins.def
new file mode 100644
index 000000000..ab8a85eb9
--- /dev/null
+++ b/gcc/hls-builtins.def
@@ -0,0 +1,8 @@
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_BARRIER, "__extls_hls_barrier",
+		  BT_FN_VOID_INT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_SINGLE, "__extls_hls_single",
+		  BT_FN_BOOL_INT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_SINGLE_DONE, "__extls_hls_single_done",
+		  BT_FN_VOID_INT, ATTR_NOTHROW_LIST)
+DEF_MPC_BUILTIN (BUILT_IN_MPC_HLS_SINGLE_NOWAIT, "__extls_hls_single_nowait",
+		  BT_FN_BOOL_INT, ATTR_NOTHROW_LIST)
diff --git a/gcc/mpc-pass.c b/gcc/mpc-pass.c
new file mode 100644
index 000000000..e48c7c3e0
--- /dev/null
+++ b/gcc/mpc-pass.c
@@ -0,0 +1,420 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "hash-set.h"
+#include "machmode.h"
+#include "vec.h"
+#include "double-int.h"
+#include "input.h"
+#include "alias.h"
+#include "symtab.h"
+#include "options.h"
+#include "wide-int.h"
+#include "inchash.h"
+#include "tree.h"
+#include "fold-const.h"
+#include "predict.h"
+#include "hard-reg-set.h"
+#include "input.h"
+#include "function.h"
+#include "dominance.h"
+#include "cfg.h"
+#include "basic-block.h"
+#include "tree-ssa-alias.h"
+#include "internal-fn.h"
+#include "gimple-expr.h"
+#include "is-a.h"
+#include "gimple.h"
+#include "tree-inline.h"
+#include "dumpfile.h"
+#include "langhooks.h"
+#include "splay-tree.h"
+#include "hash-map.h"
+#include "plugin-api.h"
+#include "ipa-ref.h"
+#include "cgraph.h"
+#include "ipa-utils.h"
+#include "bitmap.h"
+#include "ipa-reference.h"
+#include "flags.h"
+#include "diagnostic.h"
+#include "langhooks.h"
+#include "lto-streamer.h"
+#include "alloc-pool.h"
+#include "symbol-summary.h"
+#include "ipa-prop.h"
+#include "ipa-inline.h"
+#include "tree-pass.h"
+
+extern struct varpool_node *varpool_nodes ;
+
+/* This pass is called only once: IPA pass */
+static unsigned int execute_mpc_warning_global_vars(void)
+{
+
+
+  return 0 ;
+}
+
+static bool gate_mpc_warning_global_vars (void)
+{
+  return warn_mpc != 0;
+}
+
+
+/* Entry point for warning global var pass.  */
+
+static unsigned int pass_mpc_warning_global_vars_clone (void)
+{
+  execute_mpc_warning_global_vars();
+  return 0;
+}
+
+namespace {
+
+const pass_data pass_data_mpc_warning_global_vars =
+{
+  SIMPLE_IPA_PASS,              /* type */
+  "warning_global_vars",                  /* name */
+  OPTGROUP_NONE,                /* optinfo_flags */
+  TV_EARLY_INLINING,                      /* tv_id */
+  0,      /* properties_required */
+  0,                            /* properties_provided */
+  0,                            /* properties_destroyed */
+  0,                            /* todo_flags_start */
+  TODO_dump_symtab,                            /* todo_flags_finish */
+};
+
+class pass_mpc_warning_global_vars : public simple_ipa_opt_pass
+{
+public:
+  pass_mpc_warning_global_vars(gcc::context *ctxt)
+    : simple_ipa_opt_pass(pass_data_mpc_warning_global_vars, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  bool gate () { return gate_mpc_warning_global_vars(); }
+  unsigned int execute () { return pass_mpc_warning_global_vars_clone(); }
+};
+
+} // anon namespace
+
+simple_ipa_opt_pass * make_pass_mpc_warning_global_vars (gcc::context *ctxt)
+{
+  return new pass_mpc_warning_global_vars (ctxt);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+static int is_mpi = 0 ;
+static int is_mpc = 0 ;
+static int is_pthread = 0 ;
+static int is_mpc_thread = 0 ;
+static int is_sctk_thread = 0 ;
+
+
+static tree mpc_thread_mixing_1( tree * t_ptr, int * walk_subtrees ATTRIBUTE_UNUSED, void * s ATTRIBUTE_UNUSED) 
+{
+	tree t = *t_ptr ;
+	//return *t_ptr;
+
+  if ( TREE_CODE(t) == CALL_EXPR ) 
+  {
+    tree callee = get_callee_fndecl( t ) ;
+
+    if ( dump_file ) {
+      fprintf( dump_file, "\tCALL EXPR found\n" ) ;
+      if ( callee == NULL_TREE ) {
+	fprintf( dump_file, "\t -> Don't know the callee\n" ) ;
+      }
+    }
+
+    if ( callee != NULL_TREE && DECL_NAME( callee ) ) {
+      const char * name_callee = IDENTIFIER_POINTER( DECL_NAME( callee ) ) ;
+      if ( dump_file ) {
+	fprintf( dump_file, "\t -> name of the callee <%s>\n",
+	    name_callee ) ;
+      }
+
+      /* Check if this name is instance of MPC, MPI, pthread or mpc_thread */
+      if ( strncmp( name_callee, "MPI", 3 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of MPI\n" ) ;
+	}
+	is_mpi = 1 ;
+      }
+      if ( strncmp( name_callee, "MPC", 3 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of MPC\n" ) ;
+	}
+	is_mpc = 1 ;
+      }
+      if ( strncmp( name_callee, "pthread", 7 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of pthread\n" ) ;
+	}
+	is_pthread = 1 ;
+      }
+      if ( strncmp( name_callee, "mpc_thread", 10 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of MPC Thread\n" ) ;
+	}
+	is_mpc_thread = 1 ;
+      }
+      if ( strncmp( name_callee, "sctk_thread", 11 ) == 0 ) {
+	if ( dump_file ) {
+	  fprintf( dump_file, "\t -> Instance of SCTK Thread\n" ) ;
+	}
+	is_sctk_thread = 1 ;
+      }
+
+    }
+  }
+	return NULL_TREE ;
+}
+
+static unsigned int execute_mpc_warning_thread_mixing(void)
+{
+
+	struct cgraph_node *node; 
+	//~ basic_block bb;
+	struct function *fun ;
+	//~ gimple_stmt_iterator gsi;
+
+	/* TODO the call graph contains only functions which are called within this
+	* file (or those which has a body and might be called from outside)
+     -> It seems to be enough to traverse the call graph,
+     check the function with no body
+     check the source file location (e.g., mpc.h)
+	*/
+
+	FOR_EACH_DEFINED_FUNCTION (node) 
+	{
+		tree t ;
+		if ( dump_file ) 
+		{
+			fprintf( dump_file, "===== Checking <%s>\n",
+			node->name() ) ;
+		}
+
+		t = node->decl ;
+
+		if ( TREE_CODE( t ) == FUNCTION_DECL ) 
+		{
+			fun = DECL_STRUCT_FUNCTION (t) ;
+			if ( fun != NULL && DECL_SAVED_TREE( t ) != NULL ) 
+			{
+				//~ FOR_EACH_BB_FN (bb, fun)
+					//~ for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+					//~ {
+						//~ walk_tree_without_duplicates_1( gsi_stmt (gsi), mpc_thread_mixing_1, NULL, NULL) ;
+					//~ }
+			} 
+			else 
+			{
+				if ( dump_file ) 
+				{
+					fprintf( dump_file, "-> Skip because the body is not available\n" ) ;
+				}
+			}
+		}
+	}
+
+	if ( dump_file ) 
+	{
+		fprintf( dump_file, "MPI content? %d\n", is_mpi ) ;
+		fprintf( dump_file, "MPC content? %d\n", is_mpc ) ;
+		fprintf( dump_file, "Pthread content? %d\n", is_pthread ) ;
+		fprintf( dump_file, "MPC thread content? %d\n", is_mpc_thread ) ;
+		fprintf( dump_file, "SCTK thread content? %d\n", is_sctk_thread ) ;
+	}
+
+
+	if ( is_mpi && is_mpc ) 
+	{
+		warning( 0, "Mixing calls to MPI and MPC is tedious") ;
+	}
+	if ( is_mpc_thread && (is_pthread || is_sctk_thread) ) 
+	{
+		warning( 0, "Mixing calls to pthread and MPC is tedious") ;
+	}
+	(void) mpc_thread_mixing_1;
+	return 0 ;
+}
+
+static bool gate_mpc_warning_thread_mixing(void)
+{
+  return warn_mpc != 0;
+}
+
+/* Entry point for MPC Warn pass.  */
+
+static unsigned int pass_mpc_warning_thread_mixing_clone (void)
+{
+  execute_mpc_warning_thread_mixing();
+  return 0;
+}
+
+namespace {
+
+const pass_data pass_data_mpc_warning_thread_mixing =
+{
+  SIMPLE_IPA_PASS,              /* type */
+  "pass_mpc_warning_thread_mixing",                  /* name */
+  OPTGROUP_NONE,                /* optinfo_flags */
+  TV_EARLY_INLINING,                      /* tv_id */
+  0,      /* properties_required */
+  0,                            /* properties_provided */
+  0,                            /* properties_destroyed */
+  0,                            /* todo_flags_start */
+  TODO_dump_symtab,                            /* todo_flags_finish */
+};
+
+class pass_mpc_warning_thread_mixing : public simple_ipa_opt_pass
+{
+public:
+  pass_mpc_warning_thread_mixing(gcc::context *ctxt)
+    : simple_ipa_opt_pass(pass_data_mpc_warning_thread_mixing, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  bool gate () { return gate_mpc_warning_thread_mixing(); }
+  unsigned int execute () { return pass_mpc_warning_thread_mixing_clone(); }
+};
+
+} // anon namespace
+
+simple_ipa_opt_pass * make_pass_mpc_warning_thread_mixing (gcc::context *ctxt)
+{
+  return new pass_mpc_warning_thread_mixing (ctxt);
+}
+
+
+
+
+
+
+
+
+static unsigned int execute_mpc_remove_hls_node(void)
+{
+#if 0
+  struct varpool_node *curr_node = NULL ;
+
+  curr_node = varpool_nodes ; 
+
+  while ( curr_node != NULL ) {
+    tree t ;
+
+    t = curr_node->decl ;
+
+	if ( TREE_CODE(t) == VAR_DECL &&
+			is_global_var( t ) &&
+			!DECL_ARTIFICIAL( t ) &&
+			!TREE_READONLY( t ) && 
+			!DECL_IN_SYSTEM_HEADER( t ) ) {
+		if ( DECL_TLS_MODEL(t) == TLS_MODEL_HLS_NODE ) {
+			DECL_TLS_MODEL(t) = TLS_MODEL_NONE ;
+			if (DECL_RTL_SET_P (t))
+				make_decl_rtl (t);
+			fprintf( stderr, "(MPC optimization pass) Optimized HLS node variable %s in fine %s line %d base_var %p\n",
+					lang_hooks.decl_printable_name (t,2),
+					DECL_SOURCE_FILE(t),
+					DECL_SOURCE_LINE(t), t) ;
+
+		}
+	}
+    curr_node = curr_node->next ;
+  }
+
+  struct cgraph_node *node;
+  for (node = cgraph_nodes; node; node = node->next)
+  {
+	  tree decl = node->decl;
+	  struct function *this_cfun = DECL_STRUCT_FUNCTION (decl);
+	  basic_block this_block;
+	  FOR_EACH_BB_FN (this_block, this_cfun)
+	  {
+		  gimple_stmt_iterator gsi;
+		  for (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi)) {
+			  gimple stmt = gsi_stmt (gsi);
+			  if (gimple_code (stmt) == )
+		  }
+	  }
+  }
+
+				if (TREE_CODE (op) == ADDR_EXPR) {
+					fprintf(stderr, "recompute for base_var %p\n", get_base_var(op) );
+					recompute_tree_invariant_for_addr_expr (op);
+				}
+#endif
+
+  return 0 ;
+}
+
+static bool gate_mpc_remove_hls_node (void)
+{
+/*  return flag_mpc_hls != 0; */
+	return 0;
+}
+
+/* Entry point for HLS pass.  */
+
+static unsigned int pass_mpc_remove_hls_node_clone (void)
+{
+  execute_mpc_remove_hls_node();
+  return 0;
+}
+
+namespace {
+
+const pass_data pass_data_mpc_remove_hls_node =
+{
+  GIMPLE_PASS,              /* type */
+  "mpcremovehlsnode",                  /* name */
+  OPTGROUP_NONE,                /* optinfo_flags */
+  TV_NONE,                      /* tv_id */
+  0,      /* properties_required */
+  0,                            /* properties_provided */
+  0,                            /* properties_destroyed */
+  0,                            /* todo_flags_start */
+  0,                            /* todo_flags_finish */
+};
+
+
+class pass_mpc_remove_hls_node : public simple_ipa_opt_pass
+{
+public:
+  pass_mpc_remove_hls_node(gcc::context *ctxt)
+    : simple_ipa_opt_pass(pass_data_mpc_remove_hls_node, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  bool gate () { return gate_mpc_remove_hls_node(); }
+  unsigned int execute () { return pass_mpc_remove_hls_node_clone(); }
+};
+
+} // anon namespace
+
+simple_ipa_opt_pass * make_pass_mpc_remove_hls_node (gcc::context *ctxt)
+{
+  return new pass_mpc_remove_hls_node (ctxt);
+}
+
+
+
+
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
index ec2a64e1a..c741e8d73 100644
--- a/gcc/omp-low.c
+++ b/gcc/omp-low.c
@@ -14851,7 +14851,11 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)
 	  DECL_COMMON (decl) = 1;
 	  DECL_ARTIFICIAL (decl) = 1;
 	  DECL_IGNORED_P (decl) = 1;
-
+	  /* MPC OMP BEGIN */
+	  /* Put this variable TASK scope to get one copy per MPI task */
+	  set_decl_tls_model (decl, TLS_MODEL_MPC_TASK);
+	  /* MPC OMP END */
+	  
 	  varpool_node::finalize_decl (decl);
 
 	  critical_name_mutexes->put (name, decl);
diff --git a/gcc/print-tree.c b/gcc/print-tree.c
index aa6593f28..e8cafca07 100644
--- a/gcc/print-tree.c
+++ b/gcc/print-tree.c
@@ -414,9 +414,48 @@ print_node (FILE *file, const char *prefix, tree node, int indent)
       if (code == VAR_DECL && DECL_COMMON (node))
 	fputs (" common", file);
       if (code == VAR_DECL && DECL_THREAD_LOCAL_P (node))
-	{
+	  switch( DECL_TLS_MODEL(node ) )
+	  {
 	  fputs (" ", file);
 	  fputs (tls_model_names[DECL_TLS_MODEL (node)], file);
+		/* BEGIN MPC */
+	      case TLS_MODEL_MPC_OPENMP:
+		fputs (" MPC tls-mpc-openmp", file);
+		break;
+	      case TLS_MODEL_MPC_TASK:
+		fputs (" MPC tls-mpc-task", file);
+		break;
+	      case TLS_MODEL_MPC_THREAD:
+		fputs (" MPC tls-mpc-thread", file);
+		break;
+	      case TLS_MODEL_MPC_PROCESS:
+		fputs (" MPC tls-mpc-process", file);
+		break;
+	      case TLS_MODEL_HLS_NODE:
+		fputs (" MPC tls-mpc-hls-node", file);
+		break;
+	      case TLS_MODEL_HLS_NUMA_LEVEL_2:
+		fputs (" MPC tls-mpc-hls-numa-level2", file);
+		break;
+	      case TLS_MODEL_HLS_NUMA_LEVEL_1:
+		fputs (" MPC tls-mpc-hls-numa-level1", file);
+		break;
+	      case TLS_MODEL_HLS_SOCKET:
+		fputs (" MPC tls-mpc-hls-socket", file);
+		break;
+	      case TLS_MODEL_HLS_CACHE_LEVEL_3:
+		fputs (" MPC tls-mpc-hls-cache-level3", file);
+		break;
+	      case TLS_MODEL_HLS_CACHE_LEVEL_2:
+		fputs (" MPC tls-mpc-hls-cache-level2", file);
+		break;
+	      case TLS_MODEL_HLS_CACHE_LEVEL_1:
+		fputs (" MPC tls-mpc-hls-cache-level1", file);
+		break;
+	      case TLS_MODEL_HLS_CORE:
+		fputs (" MPC tls-mpc-hls-core", file);
+		break;
+		/* MPC END */
 	}
 
       if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))
diff --git a/gcc/rtl.h b/gcc/rtl.h
index 8267252b1..d5d90a67c 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -2477,28 +2477,55 @@ do {								        \
 #define SYMBOL_FLAG_SMALL	(1 << 2)
 #define SYMBOL_REF_SMALL_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_SMALL) != 0)
-/* The three-bit field at [5:3] is true for TLS variables; use
+/* MPC HLS BEGIN */
+#if 0
+	/* The three-bit field at [5:3] is true for TLS variables; use
+	   SYMBOL_REF_TLS_MODEL to extract the field as an enum tls_model.  */
+	#define SYMBOL_FLAG_TLS_SHIFT	3
+	#define SYMBOL_REF_TLS_MODEL(RTX) \
+	  ((enum tls_model) ((SYMBOL_REF_FLAGS (RTX) >> SYMBOL_FLAG_TLS_SHIFT) & 7))
+	/* Set if this symbol is not defined in this translation unit.  */
+	#define SYMBOL_FLAG_EXTERNAL	(1 << 6)
+	#define SYMBOL_REF_EXTERNAL_P(RTX) \
+	  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_EXTERNAL) != 0)
+	/* Set if this symbol has a block_symbol structure associated with it.  */
+	#define SYMBOL_FLAG_HAS_BLOCK_INFO (1 << 7)
+	#define SYMBOL_REF_HAS_BLOCK_INFO_P(RTX) \
+	  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_HAS_BLOCK_INFO) != 0)
+	/* Set if this symbol is a section anchor.  SYMBOL_REF_ANCHOR_P implies
+	   SYMBOL_REF_HAS_BLOCK_INFO_P.  */
+	#define SYMBOL_FLAG_ANCHOR	(1 << 8)
+	#define SYMBOL_REF_ANCHOR_P(RTX) \
+	  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_ANCHOR) != 0)
+
+	/* Subsequent bits are available for the target to use.  */
+	#define SYMBOL_FLAG_MACH_DEP_SHIFT	9
+	#define SYMBOL_FLAG_MACH_DEP		(1 << SYMBOL_FLAG_MACH_DEP_SHIFT)
+
+#endif
+/* The three-bit field at [6:3] is true for TLS variables; use
    SYMBOL_REF_TLS_MODEL to extract the field as an enum tls_model.  */
 #define SYMBOL_FLAG_TLS_SHIFT	3
 #define SYMBOL_REF_TLS_MODEL(RTX) \
-  ((enum tls_model) ((SYMBOL_REF_FLAGS (RTX) >> SYMBOL_FLAG_TLS_SHIFT) & 7))
+  ((enum tls_model) ((SYMBOL_REF_FLAGS (RTX) >> SYMBOL_FLAG_TLS_SHIFT) & 31))
 /* Set if this symbol is not defined in this translation unit.  */
-#define SYMBOL_FLAG_EXTERNAL	(1 << 6)
+#define SYMBOL_FLAG_EXTERNAL	(1 << 8)
 #define SYMBOL_REF_EXTERNAL_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_EXTERNAL) != 0)
 /* Set if this symbol has a block_symbol structure associated with it.  */
-#define SYMBOL_FLAG_HAS_BLOCK_INFO (1 << 7)
+#define SYMBOL_FLAG_HAS_BLOCK_INFO (1 << 9)
 #define SYMBOL_REF_HAS_BLOCK_INFO_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_HAS_BLOCK_INFO) != 0)
 /* Set if this symbol is a section anchor.  SYMBOL_REF_ANCHOR_P implies
    SYMBOL_REF_HAS_BLOCK_INFO_P.  */
-#define SYMBOL_FLAG_ANCHOR	(1 << 8)
+#define SYMBOL_FLAG_ANCHOR	(1 << 10)
 #define SYMBOL_REF_ANCHOR_P(RTX) \
   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_ANCHOR) != 0)
 
 /* Subsequent bits are available for the target to use.  */
-#define SYMBOL_FLAG_MACH_DEP_SHIFT	9
+#define SYMBOL_FLAG_MACH_DEP_SHIFT	11
 #define SYMBOL_FLAG_MACH_DEP		(1 << SYMBOL_FLAG_MACH_DEP_SHIFT)
+/* MPC HLS END */
 
 /* If SYMBOL_REF_HAS_BLOCK_INFO_P (RTX), this is the object_block
    structure to which the symbol belongs, or NULL if it has not been
diff --git a/gcc/stor-layout.c b/gcc/stor-layout.c
index dd40ca00a..a7f913be1 100644
--- a/gcc/stor-layout.c
+++ b/gcc/stor-layout.c
@@ -733,6 +733,7 @@ layout_decl (tree decl, unsigned int known_align)
   /* Evaluate nonconstant size only once, either now or as soon as safe.  */
   if (DECL_SIZE (decl) != 0 && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)
     DECL_SIZE (decl) = variable_size (DECL_SIZE (decl));
+  
   if (DECL_SIZE_UNIT (decl) != 0
       && TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST)
     DECL_SIZE_UNIT (decl) = variable_size (DECL_SIZE_UNIT (decl));
diff --git a/gcc/tree-core.h b/gcc/tree-core.h
index 41c1a9bd3..a64e338cb 100644
--- a/gcc/tree-core.h
+++ b/gcc/tree-core.h
@@ -1615,7 +1615,9 @@ struct GTY(()) tree_decl_with_vis {
  /* Used for FUNCTION_DECL, VAR_DECL and in C++ for TYPE_DECL.  */
  ENUM_BITFIELD(symbol_visibility) visibility : 2;
  unsigned visibility_specified : 1;
-
+/* MPC HLS BEGIN */
+ ENUM_BITFIELD(tls_model) tls_model : 5;
+/* MPC HLS END */
  /* Belong to FUNCTION_DECL exclusively.  */
  unsigned init_priority_p : 1;
  /* Used by C++ only.  Might become a generic decl flag.  */
diff --git a/gcc/tree-ssa-operands.c b/gcc/tree-ssa-operands.c
index 7d59bfda2..bb3439c54 100644
--- a/gcc/tree-ssa-operands.c
+++ b/gcc/tree-ssa-operands.c
@@ -364,12 +364,10 @@ finalize_ssa_uses (struct function *fn, gimple *stmt)
   if (build_vuse != NULL_TREE)
     {
       tree oldvuse = gimple_vuse (stmt);
-      if (oldvuse
-	  && TREE_CODE (oldvuse) == SSA_NAME)
-	oldvuse = SSA_NAME_VAR (oldvuse);
-      if (oldvuse != (build_vuse != NULL_TREE
-		      ? build_vuse : build_vdef))
-	gimple_set_vuse (stmt, NULL_TREE);
+      if (oldvuse && TREE_CODE (oldvuse) == SSA_NAME)
+		oldvuse = SSA_NAME_VAR (oldvuse);
+      if (oldvuse != (build_vuse != NULL_TREE ? build_vuse : build_vdef))
+		gimple_set_vuse (stmt, NULL_TREE);
       build_uses.safe_insert (0, gimple_vuse_ptr (stmt));
     }
 
diff --git a/gcc/tree.c b/gcc/tree.c
index 1b472cc05..fe4a94e17 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -3133,23 +3133,38 @@ staticp (tree arg)
       return arg;
 
     case VAR_DECL:
-      return ((TREE_STATIC (arg) || DECL_EXTERNAL (arg))
+    {
+		if( getenv("MPC_DYN_PRIV_ENABLED") )
+		{
+			if( (TREE_STATIC (arg) || DECL_EXTERNAL (arg))
+			  && DECL_THREAD_LOCAL_P (arg) )
+			{
+					return NULL;
+			}
+		}
+     tree predicate = ((TREE_STATIC (arg) || DECL_EXTERNAL (arg))
 	      && ! DECL_THREAD_LOCAL_P (arg)
 	      && ! DECL_DLLIMPORT_P (arg)
 	      ? arg : NULL);
-
+    
+      return predicate;
+	}
     case CONST_DECL:
+
       return ((TREE_STATIC (arg) || DECL_EXTERNAL (arg))
 	      ? arg : NULL);
 
     case CONSTRUCTOR:
+
       return TREE_STATIC (arg) ? arg : NULL;
 
     case LABEL_DECL:
     case STRING_CST:
+
       return arg;
 
     case COMPONENT_REF:
+
       /* If the thing being referenced is not a field, then it is
 	 something language specific.  */
       gcc_assert (TREE_CODE (TREE_OPERAND (arg, 1)) == FIELD_DECL);
@@ -14061,3 +14076,103 @@ combined_fn_name (combined_fn fn)
 }
 
 #include "gt-tree.h"
+
+/* MPC BEGIN */
+#define DEFAULT_NB_CELLS 512
+static inline char **
+mpc_decl_load_invalid_from_getenv(char * envar)
+{
+	char * init_str = getenv(envar);
+	char * cur, ** array = NULL;
+	unsigned int cpt = 0;
+
+	if(init_str == NULL)
+		goto returning;
+
+	cur = init_str;
+	array = (char**)xcalloc(DEFAULT_NB_CELLS, sizeof(char*));
+
+	while(*cur != '\0')
+	{
+		if(*cur != ':') /* looking for the end of string */
+		{
+			cur++;
+			continue;
+		}
+
+		if(cur == init_str) /* skipping empty chains */
+		{
+			cur++;
+			init_str = cur;
+			continue;
+		}
+
+		*cur = '\0'; /* Replace ':' by '\0' */
+		cur++; /* increment to start a new chain */
+		array[cpt++] = init_str; /* register the old chain */
+		
+		if(cpt >= DEFAULT_NB_CELLS - 1 ) /* -1 because of the final reading after the loop (no ':' to end the string) */
+		{
+			fprintf(stderr, "Loading the last headers (max: %u)\n", DEFAULT_NB_CELLS);
+		}
+		init_str = cur;
+	}
+
+	if(cur != init_str) /* last word to read */
+	{
+		array[cpt++] = init_str;
+	}
+returning:
+	return array;
+}
+
+static char ** invalid_headers = NULL;
+static char ** invalid_vars = NULL;
+
+bool
+mpc_decl_match_invalid_header(tree decl)
+{
+	bool invalid = 0;
+	
+	if(DECL_IN_SYSTEM_HEADER(decl))
+		return 1;
+	
+	const char * name = lang_hooks.decl_printable_name (decl,0);
+
+
+	if(invalid_headers == NULL)
+	{
+		invalid_headers = mpc_decl_load_invalid_from_getenv("MPC_UNPRIVATIZED_FILES");
+	}
+	
+	if(invalid_vars == NULL)
+	{
+		invalid_vars = mpc_decl_load_invalid_from_getenv("MPC_UNPRIVATIZED_VARS");
+	}
+
+	int i = 0;
+	for (i=0; i < DEFAULT_NB_CELLS; i++)
+	{
+		if(invalid_headers &&  *(invalid_headers + i) != NULL)
+		{
+			if(strcmp(basename(DECL_SOURCE_FILE(decl)), invalid_headers[i]) == 0)
+			{
+				invalid = 1;
+				break;
+			}
+		}
+		
+		if(invalid_vars && *(invalid_vars + i) != NULL)
+		{
+			if(strcmp(name, invalid_vars[i]) == 0)
+			{
+				/*fprintf(stderr, "Matching %s w/ %s\n", name, invalid_vars[i]);*/
+				invalid = 1;
+				break;
+			}
+		}
+	}
+
+	return invalid;
+}
+/* MPC END */
diff --git a/gcc/tree.h b/gcc/tree.h
index c39b58e1a..7c38a808e 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -2688,6 +2688,13 @@ extern void decl_value_expr_insert (tree, tree);
    thread-local storage.  */
 #define DECL_THREAD_LOCAL_P(NODE) \
   ((TREE_STATIC (NODE) || DECL_EXTERNAL (NODE)) && decl_tls_model (NODE) >= TLS_MODEL_REAL)
+  
+/* MPC BEGIN */
+#define DECL_MPC_THREAD_LOCAL_P(NODE) \
+  ((TREE_STATIC (NODE) || DECL_EXTERNAL (NODE)) && \
+   decl_tls_model (NODE) >= TLS_MODEL_REAL && \
+   decl_tls_model (NODE) != TLS_MODEL_MPC_TASK)
+/* MPC END */
 
 /* In a non-local VAR_DECL with static storage duration, true if the
    variable has an initialization priority.  If false, the variable
diff --git a/gcc/varasm.c b/gcc/varasm.c
index b0f2af03d..a86ad686b 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -2055,11 +2055,37 @@ assemble_variable_contents (tree decl, const char *name,
       if (DECL_INITIAL (decl)
 	  && DECL_INITIAL (decl) != error_mark_node
 	  && !initializer_zerop (DECL_INITIAL (decl)))
-	/* Output the actual data.  */
-	output_constant (DECL_INITIAL (decl),
+	  {
+		  if( !getenv("MPC_DYN_PRIV_ENABLED") )
+		  {
+			/* Output the actual data.  */
+			output_constant (DECL_INITIAL (decl),
+			   tree_to_uhwi (DECL_SIZE_UNIT (decl)),
+			                 get_variable_align (decl),
+			                  false);
+		  }
+		  else
+		  {
+			  if( initializer_constant_valid_p (DECL_INITIAL (decl), TREE_TYPE (DECL_INITIAL (decl))) ) 
+			  {
+				/* Output the actual data.  */
+				output_constant (DECL_INITIAL (decl),
 			 tree_to_uhwi (DECL_SIZE_UNIT (decl)),
 			 get_variable_align (decl),
 			 false);
+			  }
+			  else
+			  {
+				  /* MPC DYN */
+				  printf("MPC : Non constant initializer detected in variable %s.\n", name );
+					/* Output the actual data.  */
+						output_constant (null_pointer_node,
+			 			tree_to_uhwi (DECL_SIZE_UNIT(decl)),
+			 			get_variable_align (decl),
+			 false);
+			  }
+		  }
+	  }
       else
 	/* Leave space for it.  */
 	assemble_zeros (tree_to_uhwi (DECL_SIZE_UNIT (decl)));
@@ -6128,6 +6154,13 @@ decl_default_tls_model (const_tree decl)
   if (kind < flag_tls_default)
     kind = flag_tls_default;
 
+#if 1 /* MPC TLS BEGIN */
+/* need to force TLS support to GD, to avoid compiler pre-optimization not supported by linker */
+  if(flag_mpc_privatize)
+  {
+	  kind = TLS_MODEL_MPC_TASK;
+  }
+#endif
   return kind;
 }
 
diff --git a/libgfortran/Makefile.am b/libgfortran/Makefile.am
index 39d3e11d2..034d266a8 100644
--- a/libgfortran/Makefile.am
+++ b/libgfortran/Makefile.am
@@ -79,6 +79,13 @@ if LIBGFOR_MINIMAL
 AM_CFLAGS += -DLIBGFOR_MINIMAL
 endif
 
+# Create a temporary lib for build with auto privatization
+gfor_unit_src = \
+io/open.c \
+io/unix.c \
+io/transfer.c \
+io/unit.c 
+
 gfor_io_src= \
 io/size_from_kind.c
 
@@ -92,12 +99,8 @@ io/inquire.c \
 io/intrinsics.c \
 io/list_read.c \
 io/lock.c \
-io/open.c \
 io/read.c \
-io/transfer.c \
 io/transfer128.c \
-io/unit.c \
-io/unix.c \
 io/write.c \
 io/fbuf.c
 
@@ -880,6 +883,21 @@ BUILT_SOURCES=$(gfor_built_src) $(gfor_built_specific_src) \
 prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \
     $(gfor_helper_src) $(gfor_ieee_src) $(gfor_io_headers) $(gfor_specific_src)
 
+libgfortranunit_a_SOURCES = $(gfor_unit_src)
+
+# Add libgfortran dirs to system includes in order to avoid auto privatization during build...
+libgfortranunit_a_CFLAGS = \
+-fPIC \
+-fmpc-privatize \
+-isystem $(srcdir) \
+-isystem $(srcdir)/io/ \
+-isystem $(srcdir)/runtime/ \
+-isystem $(srcdir)/config/ \
+-isystem $(srcdir)/caf/ \
+$(AM_CFLAGS)
+
+noinst_LIBRARIES = libgfortranunit.a
+
 if onestep
 # dummy sources for libtool
 BUILT_SOURCES+=libgfortran_c.c libgfortran_f.f90
@@ -905,10 +923,10 @@ libgfortran_c.lo: $(filter %.c,$(prereq_SRC))
 #	$(LTPPFCCOMPILE) -c -o $@ $^ -combine
 
 libgfortran_la_SOURCES = libgfortran_c.c $(filter-out %.c,$(prereq_SRC))
-
+libgfortran_la_LIBADD = libgfortranunit.a
 else
 libgfortran_la_SOURCES = $(prereq_SRC)
-
+libgfortran_la_LIBADD = libgfortranunit.a
 endif
 
 I_M4_DEPS=m4/iparm.m4
diff --git a/libgfortran/Makefile.in b/libgfortran/Makefile.in
index 7ed080cf7..f5f3e577c 100644
--- a/libgfortran/Makefile.in
+++ b/libgfortran/Makefile.in
@@ -17,6 +17,7 @@
 
 
 
+
 VPATH = @srcdir@
 am__make_dryrun = \
   { \
@@ -63,12 +64,8 @@ target_triplet = @target@
 @LIBGFOR_MINIMAL_FALSE@io/intrinsics.c \
 @LIBGFOR_MINIMAL_FALSE@io/list_read.c \
 @LIBGFOR_MINIMAL_FALSE@io/lock.c \
-@LIBGFOR_MINIMAL_FALSE@io/open.c \
 @LIBGFOR_MINIMAL_FALSE@io/read.c \
-@LIBGFOR_MINIMAL_FALSE@io/transfer.c \
 @LIBGFOR_MINIMAL_FALSE@io/transfer128.c \
-@LIBGFOR_MINIMAL_FALSE@io/unit.c \
-@LIBGFOR_MINIMAL_FALSE@io/unix.c \
 @LIBGFOR_MINIMAL_FALSE@io/write.c \
 @LIBGFOR_MINIMAL_FALSE@io/fbuf.c
 
@@ -146,6 +143,16 @@ mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs
 CONFIG_HEADER = config.h
 CONFIG_CLEAN_FILES = libgfortran.spec
 CONFIG_CLEAN_VPATH_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+ARFLAGS = cru
+libgfortranunit_a_AR = $(AR) $(ARFLAGS)
+libgfortranunit_a_LIBADD =
+am__objects_1 = libgfortranunit_a-open.$(OBJEXT) \
+	libgfortranunit_a-unix.$(OBJEXT) \
+	libgfortranunit_a-transfer.$(OBJEXT) \
+	libgfortranunit_a-unit.$(OBJEXT)
+am_libgfortranunit_a_OBJECTS = $(am__objects_1)
+libgfortranunit_a_OBJECTS = $(am_libgfortranunit_a_OBJECTS)
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
 am__vpath_adj = case $$p in \
     $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
@@ -180,18 +187,17 @@ LTLIBRARIES = $(cafexeclib_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)
 libcaf_single_la_LIBADD =
 am_libcaf_single_la_OBJECTS = single.lo
 libcaf_single_la_OBJECTS = $(am_libcaf_single_la_OBJECTS)
-libgfortran_la_LIBADD =
-@LIBGFOR_MINIMAL_TRUE@am__objects_1 = minimal.lo
-@LIBGFOR_MINIMAL_FALSE@am__objects_2 = backtrace.lo convert_char.lo \
+@LIBGFOR_MINIMAL_TRUE@am__objects_2 = minimal.lo
+@LIBGFOR_MINIMAL_FALSE@am__objects_3 = backtrace.lo convert_char.lo \
 @LIBGFOR_MINIMAL_FALSE@	environ.lo error.lo fpu.lo main.lo \
 @LIBGFOR_MINIMAL_FALSE@	pause.lo stop.lo
-am__objects_3 = bounds.lo compile_options.lo memory.lo string.lo \
-	select.lo $(am__objects_1) $(am__objects_2)
-am__objects_4 = all_l1.lo all_l2.lo all_l4.lo all_l8.lo all_l16.lo
-am__objects_5 = any_l1.lo any_l2.lo any_l4.lo any_l8.lo any_l16.lo
-am__objects_6 = count_1_l.lo count_2_l.lo count_4_l.lo count_8_l.lo \
+am__objects_4 = bounds.lo compile_options.lo memory.lo string.lo \
+	select.lo $(am__objects_2) $(am__objects_3)
+am__objects_5 = all_l1.lo all_l2.lo all_l4.lo all_l8.lo all_l16.lo
+am__objects_6 = any_l1.lo any_l2.lo any_l4.lo any_l8.lo any_l16.lo
+am__objects_7 = count_1_l.lo count_2_l.lo count_4_l.lo count_8_l.lo \
 	count_16_l.lo
-am__objects_7 = maxloc0_4_i1.lo maxloc0_8_i1.lo maxloc0_16_i1.lo \
+am__objects_8 = maxloc0_4_i1.lo maxloc0_8_i1.lo maxloc0_16_i1.lo \
 	maxloc0_4_i2.lo maxloc0_8_i2.lo maxloc0_16_i2.lo \
 	maxloc0_4_i4.lo maxloc0_8_i4.lo maxloc0_16_i4.lo \
 	maxloc0_4_i8.lo maxloc0_8_i8.lo maxloc0_16_i8.lo \
@@ -200,7 +206,7 @@ am__objects_7 = maxloc0_4_i1.lo maxloc0_8_i1.lo maxloc0_16_i1.lo \
 	maxloc0_4_r8.lo maxloc0_8_r8.lo maxloc0_16_r8.lo \
 	maxloc0_4_r10.lo maxloc0_8_r10.lo maxloc0_16_r10.lo \
 	maxloc0_4_r16.lo maxloc0_8_r16.lo maxloc0_16_r16.lo
-am__objects_8 = maxloc1_4_i1.lo maxloc1_8_i1.lo maxloc1_16_i1.lo \
+am__objects_9 = maxloc1_4_i1.lo maxloc1_8_i1.lo maxloc1_16_i1.lo \
 	maxloc1_4_i2.lo maxloc1_8_i2.lo maxloc1_16_i2.lo \
 	maxloc1_4_i4.lo maxloc1_8_i4.lo maxloc1_16_i4.lo \
 	maxloc1_4_i8.lo maxloc1_8_i8.lo maxloc1_16_i8.lo \
@@ -209,10 +215,10 @@ am__objects_8 = maxloc1_4_i1.lo maxloc1_8_i1.lo maxloc1_16_i1.lo \
 	maxloc1_4_r8.lo maxloc1_8_r8.lo maxloc1_16_r8.lo \
 	maxloc1_4_r10.lo maxloc1_8_r10.lo maxloc1_16_r10.lo \
 	maxloc1_4_r16.lo maxloc1_8_r16.lo maxloc1_16_r16.lo
-am__objects_9 = maxval_i1.lo maxval_i2.lo maxval_i4.lo maxval_i8.lo \
+am__objects_10 = maxval_i1.lo maxval_i2.lo maxval_i4.lo maxval_i8.lo \
 	maxval_i16.lo maxval_r4.lo maxval_r8.lo maxval_r10.lo \
 	maxval_r16.lo
-am__objects_10 = minloc0_4_i1.lo minloc0_8_i1.lo minloc0_16_i1.lo \
+am__objects_11 = minloc0_4_i1.lo minloc0_8_i1.lo minloc0_16_i1.lo \
 	minloc0_4_i2.lo minloc0_8_i2.lo minloc0_16_i2.lo \
 	minloc0_4_i4.lo minloc0_8_i4.lo minloc0_16_i4.lo \
 	minloc0_4_i8.lo minloc0_8_i8.lo minloc0_16_i8.lo \
@@ -221,7 +227,7 @@ am__objects_10 = minloc0_4_i1.lo minloc0_8_i1.lo minloc0_16_i1.lo \
 	minloc0_4_r8.lo minloc0_8_r8.lo minloc0_16_r8.lo \
 	minloc0_4_r10.lo minloc0_8_r10.lo minloc0_16_r10.lo \
 	minloc0_4_r16.lo minloc0_8_r16.lo minloc0_16_r16.lo
-am__objects_11 = minloc1_4_i1.lo minloc1_8_i1.lo minloc1_16_i1.lo \
+am__objects_12 = minloc1_4_i1.lo minloc1_8_i1.lo minloc1_16_i1.lo \
 	minloc1_4_i2.lo minloc1_8_i2.lo minloc1_16_i2.lo \
 	minloc1_4_i4.lo minloc1_8_i4.lo minloc1_16_i4.lo \
 	minloc1_4_i8.lo minloc1_8_i8.lo minloc1_16_i8.lo \
@@ -230,61 +236,61 @@ am__objects_11 = minloc1_4_i1.lo minloc1_8_i1.lo minloc1_16_i1.lo \
 	minloc1_4_r8.lo minloc1_8_r8.lo minloc1_16_r8.lo \
 	minloc1_4_r10.lo minloc1_8_r10.lo minloc1_16_r10.lo \
 	minloc1_4_r16.lo minloc1_8_r16.lo minloc1_16_r16.lo
-am__objects_12 = minval_i1.lo minval_i2.lo minval_i4.lo minval_i8.lo \
+am__objects_13 = minval_i1.lo minval_i2.lo minval_i4.lo minval_i8.lo \
 	minval_i16.lo minval_r4.lo minval_r8.lo minval_r10.lo \
 	minval_r16.lo
-am__objects_13 = product_i1.lo product_i2.lo product_i4.lo \
+am__objects_14 = product_i1.lo product_i2.lo product_i4.lo \
 	product_i8.lo product_i16.lo product_r4.lo product_r8.lo \
 	product_r10.lo product_r16.lo product_c4.lo product_c8.lo \
 	product_c10.lo product_c16.lo
-am__objects_14 = sum_i1.lo sum_i2.lo sum_i4.lo sum_i8.lo sum_i16.lo \
+am__objects_15 = sum_i1.lo sum_i2.lo sum_i4.lo sum_i8.lo sum_i16.lo \
 	sum_r4.lo sum_r8.lo sum_r10.lo sum_r16.lo sum_c4.lo sum_c8.lo \
 	sum_c10.lo sum_c16.lo
-am__objects_15 = bessel_r4.lo bessel_r8.lo bessel_r10.lo bessel_r16.lo
-am__objects_16 = iall_i1.lo iall_i2.lo iall_i4.lo iall_i8.lo \
+am__objects_16 = bessel_r4.lo bessel_r8.lo bessel_r10.lo bessel_r16.lo
+am__objects_17 = iall_i1.lo iall_i2.lo iall_i4.lo iall_i8.lo \
 	iall_i16.lo
-am__objects_17 = iany_i1.lo iany_i2.lo iany_i4.lo iany_i8.lo \
+am__objects_18 = iany_i1.lo iany_i2.lo iany_i4.lo iany_i8.lo \
 	iany_i16.lo
-am__objects_18 = iparity_i1.lo iparity_i2.lo iparity_i4.lo \
+am__objects_19 = iparity_i1.lo iparity_i2.lo iparity_i4.lo \
 	iparity_i8.lo iparity_i16.lo
-am__objects_19 = norm2_r4.lo norm2_r8.lo norm2_r10.lo norm2_r16.lo
-am__objects_20 = parity_l1.lo parity_l2.lo parity_l4.lo parity_l8.lo \
+am__objects_20 = norm2_r4.lo norm2_r8.lo norm2_r10.lo norm2_r16.lo
+am__objects_21 = parity_l1.lo parity_l2.lo parity_l4.lo parity_l8.lo \
 	parity_l16.lo
-am__objects_21 = matmul_i1.lo matmul_i2.lo matmul_i4.lo matmul_i8.lo \
+am__objects_22 = matmul_i1.lo matmul_i2.lo matmul_i4.lo matmul_i8.lo \
 	matmul_i16.lo matmul_r4.lo matmul_r8.lo matmul_r10.lo \
 	matmul_r16.lo matmul_c4.lo matmul_c8.lo matmul_c10.lo \
 	matmul_c16.lo
-am__objects_22 = matmul_l4.lo matmul_l8.lo matmul_l16.lo
-am__objects_23 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \
+am__objects_23 = matmul_l4.lo matmul_l8.lo matmul_l16.lo
+am__objects_24 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \
 	transpose_r4.lo transpose_r8.lo transpose_r10.lo \
 	transpose_r16.lo transpose_c4.lo transpose_c8.lo \
 	transpose_c10.lo transpose_c16.lo
-am__objects_24 = shape_i1.lo shape_i2.lo shape_i4.lo shape_i8.lo \
+am__objects_25 = shape_i1.lo shape_i2.lo shape_i4.lo shape_i8.lo \
 	shape_i16.lo
-am__objects_25 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo
-am__objects_26 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo
-am__objects_27 = cshift1_4.lo cshift1_8.lo cshift1_16.lo
-am__objects_28 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \
+am__objects_26 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo
+am__objects_27 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo
+am__objects_28 = cshift1_4.lo cshift1_8.lo cshift1_16.lo
+am__objects_29 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \
 	reshape_r4.lo reshape_r8.lo reshape_r10.lo reshape_r16.lo \
 	reshape_c4.lo reshape_c8.lo reshape_c10.lo reshape_c16.lo
-am__objects_29 = in_pack_i1.lo in_pack_i2.lo in_pack_i4.lo \
+am__objects_30 = in_pack_i1.lo in_pack_i2.lo in_pack_i4.lo \
 	in_pack_i8.lo in_pack_i16.lo in_pack_r4.lo in_pack_r8.lo \
 	in_pack_r10.lo in_pack_r16.lo in_pack_c4.lo in_pack_c8.lo \
 	in_pack_c10.lo in_pack_c16.lo
-am__objects_30 = in_unpack_i1.lo in_unpack_i2.lo in_unpack_i4.lo \
+am__objects_31 = in_unpack_i1.lo in_unpack_i2.lo in_unpack_i4.lo \
 	in_unpack_i8.lo in_unpack_i16.lo in_unpack_r4.lo \
 	in_unpack_r8.lo in_unpack_r10.lo in_unpack_r16.lo \
 	in_unpack_c4.lo in_unpack_c8.lo in_unpack_c10.lo \
 	in_unpack_c16.lo
-am__objects_31 = exponent_r4.lo exponent_r8.lo exponent_r10.lo \
+am__objects_32 = exponent_r4.lo exponent_r8.lo exponent_r10.lo \
 	exponent_r16.lo
-am__objects_32 = fraction_r4.lo fraction_r8.lo fraction_r10.lo \
+am__objects_33 = fraction_r4.lo fraction_r8.lo fraction_r10.lo \
 	fraction_r16.lo
-am__objects_33 = nearest_r4.lo nearest_r8.lo nearest_r10.lo \
+am__objects_34 = nearest_r4.lo nearest_r8.lo nearest_r10.lo \
 	nearest_r16.lo
-am__objects_34 = set_exponent_r4.lo set_exponent_r8.lo \
+am__objects_35 = set_exponent_r4.lo set_exponent_r8.lo \
 	set_exponent_r10.lo set_exponent_r16.lo
-am__objects_35 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_r16_i4.lo \
+am__objects_36 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_r16_i4.lo \
 	pow_c4_i4.lo pow_c8_i4.lo pow_c10_i4.lo pow_c16_i4.lo \
 	pow_i4_i8.lo pow_i8_i8.lo pow_i16_i8.lo pow_r4_i8.lo \
 	pow_r8_i8.lo pow_r10_i8.lo pow_r16_i8.lo pow_c4_i8.lo \
@@ -292,45 +298,44 @@ am__objects_35 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_r16_i4.lo \
 	pow_i8_i16.lo pow_i16_i16.lo pow_r4_i16.lo pow_r8_i16.lo \
 	pow_r10_i16.lo pow_r16_i16.lo pow_c4_i16.lo pow_c8_i16.lo \
 	pow_c10_i16.lo pow_c16_i16.lo
-am__objects_36 = rrspacing_r4.lo rrspacing_r8.lo rrspacing_r10.lo \
+am__objects_37 = rrspacing_r4.lo rrspacing_r8.lo rrspacing_r10.lo \
 	rrspacing_r16.lo
-am__objects_37 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \
+am__objects_38 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \
 	spacing_r16.lo
-am__objects_38 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \
+am__objects_39 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \
 	pack_i16.lo pack_r4.lo pack_r8.lo pack_r10.lo pack_r16.lo \
 	pack_c4.lo pack_c8.lo pack_c10.lo pack_c16.lo
-am__objects_39 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \
+am__objects_40 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \
 	unpack_i16.lo unpack_r4.lo unpack_r8.lo unpack_r10.lo \
 	unpack_r16.lo unpack_c4.lo unpack_c8.lo unpack_c10.lo \
 	unpack_c16.lo
-am__objects_40 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \
+am__objects_41 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \
 	spread_i16.lo spread_r4.lo spread_r8.lo spread_r10.lo \
 	spread_r16.lo spread_c4.lo spread_c8.lo spread_c10.lo \
 	spread_c16.lo
-am__objects_41 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \
+am__objects_42 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \
 	cshift0_i8.lo cshift0_i16.lo cshift0_r4.lo cshift0_r8.lo \
 	cshift0_r10.lo cshift0_r16.lo cshift0_c4.lo cshift0_c8.lo \
 	cshift0_c10.lo cshift0_c16.lo
-am__objects_42 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \
-	$(am__objects_7) $(am__objects_8) $(am__objects_9) \
-	$(am__objects_10) $(am__objects_11) $(am__objects_12) \
-	$(am__objects_13) $(am__objects_14) $(am__objects_15) \
-	$(am__objects_16) $(am__objects_17) $(am__objects_18) \
-	$(am__objects_19) $(am__objects_20) $(am__objects_21) \
-	$(am__objects_22) $(am__objects_23) $(am__objects_24) \
-	$(am__objects_25) $(am__objects_26) $(am__objects_27) \
-	$(am__objects_28) $(am__objects_29) $(am__objects_30) \
-	$(am__objects_31) $(am__objects_32) $(am__objects_33) \
-	$(am__objects_34) $(am__objects_35) $(am__objects_36) \
-	$(am__objects_37) $(am__objects_38) $(am__objects_39) \
-	$(am__objects_40) $(am__objects_41)
-@LIBGFOR_MINIMAL_FALSE@am__objects_43 = close.lo file_pos.lo format.lo \
+am__objects_43 = $(am__objects_5) $(am__objects_6) $(am__objects_7) \
+	$(am__objects_8) $(am__objects_9) $(am__objects_10) \
+	$(am__objects_11) $(am__objects_12) $(am__objects_13) \
+	$(am__objects_14) $(am__objects_15) $(am__objects_16) \
+	$(am__objects_17) $(am__objects_18) $(am__objects_19) \
+	$(am__objects_20) $(am__objects_21) $(am__objects_22) \
+	$(am__objects_23) $(am__objects_24) $(am__objects_25) \
+	$(am__objects_26) $(am__objects_27) $(am__objects_28) \
+	$(am__objects_29) $(am__objects_30) $(am__objects_31) \
+	$(am__objects_32) $(am__objects_33) $(am__objects_34) \
+	$(am__objects_35) $(am__objects_36) $(am__objects_37) \
+	$(am__objects_38) $(am__objects_39) $(am__objects_40) \
+	$(am__objects_41) $(am__objects_42)
+@LIBGFOR_MINIMAL_FALSE@am__objects_44 = close.lo file_pos.lo format.lo \
 @LIBGFOR_MINIMAL_FALSE@	inquire.lo intrinsics.lo list_read.lo \
-@LIBGFOR_MINIMAL_FALSE@	lock.lo open.lo read.lo transfer.lo \
-@LIBGFOR_MINIMAL_FALSE@	transfer128.lo unit.lo unix.lo write.lo \
+@LIBGFOR_MINIMAL_FALSE@	lock.lo read.lo transfer128.lo write.lo \
 @LIBGFOR_MINIMAL_FALSE@	fbuf.lo
-am__objects_44 = size_from_kind.lo $(am__objects_43)
-@LIBGFOR_MINIMAL_FALSE@am__objects_45 = access.lo c99_functions.lo \
+am__objects_45 = size_from_kind.lo $(am__objects_44)
+@LIBGFOR_MINIMAL_FALSE@am__objects_46 = access.lo c99_functions.lo \
 @LIBGFOR_MINIMAL_FALSE@	chdir.lo chmod.lo clock.lo cpu_time.lo \
 @LIBGFOR_MINIMAL_FALSE@	ctime.lo date_and_time.lo dtime.lo \
 @LIBGFOR_MINIMAL_FALSE@	env.lo etime.lo execute_command_line.lo \
@@ -340,8 +345,8 @@ am__objects_44 = size_from_kind.lo $(am__objects_43)
 @LIBGFOR_MINIMAL_FALSE@	rename.lo stat.lo symlnk.lo \
 @LIBGFOR_MINIMAL_FALSE@	system_clock.lo time.lo umask.lo \
 @LIBGFOR_MINIMAL_FALSE@	unlink.lo
-@IEEE_SUPPORT_TRUE@am__objects_46 = ieee_helper.lo
-am__objects_47 = associated.lo abort.lo args.lo bit_intrinsics.lo \
+@IEEE_SUPPORT_TRUE@am__objects_47 = ieee_helper.lo
+am__objects_48 = associated.lo abort.lo args.lo bit_intrinsics.lo \
 	cshift0.lo eoshift0.lo eoshift2.lo erfc_scaled.lo \
 	extends_type_of.lo fnum.lo ierrno.lo ishftc.lo \
 	iso_c_generated_procs.lo iso_c_binding.lo malloc.lo mvbits.lo \
@@ -349,12 +354,12 @@ am__objects_47 = associated.lo abort.lo args.lo bit_intrinsics.lo \
 	spread_generic.lo string_intrinsics.lo rand.lo random.lo \
 	reshape_generic.lo reshape_packed.lo selected_int_kind.lo \
 	selected_real_kind.lo transpose_generic.lo unpack_generic.lo \
-	in_pack_generic.lo in_unpack_generic.lo $(am__objects_45) \
-	$(am__objects_46)
-@IEEE_SUPPORT_TRUE@am__objects_48 = ieee_arithmetic.lo \
+	in_pack_generic.lo in_unpack_generic.lo $(am__objects_46) \
+	$(am__objects_47)
+@IEEE_SUPPORT_TRUE@am__objects_49 = ieee_arithmetic.lo \
 @IEEE_SUPPORT_TRUE@	ieee_exceptions.lo ieee_features.lo
-am__objects_49 =
-am__objects_50 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \
+am__objects_50 =
+am__objects_51 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \
 	_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \
 	_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \
 	_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \
@@ -378,19 +383,19 @@ am__objects_50 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \
 	_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \
 	_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \
 	_anint_r8.lo _anint_r10.lo _anint_r16.lo
-am__objects_51 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \
+am__objects_52 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \
 	_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \
 	_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \
 	_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \
 	_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \
 	_mod_r10.lo _mod_r16.lo
-am__objects_52 = misc_specifics.lo
-am__objects_53 = $(am__objects_50) $(am__objects_51) $(am__objects_52) \
+am__objects_53 = misc_specifics.lo
+am__objects_54 = $(am__objects_51) $(am__objects_52) $(am__objects_53) \
 	dprod_r8.lo f2c_specifics.lo
-am__objects_54 = $(am__objects_3) $(am__objects_42) $(am__objects_44) \
-	$(am__objects_47) $(am__objects_48) $(am__objects_49) \
-	$(am__objects_53)
-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_54)
+am__objects_55 = $(am__objects_4) $(am__objects_43) $(am__objects_45) \
+	$(am__objects_48) $(am__objects_49) $(am__objects_50) \
+	$(am__objects_54)
+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_55)
 @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo
 libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@
@@ -418,7 +423,8 @@ LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 FCCOMPILE = $(FC) $(AM_FCFLAGS) $(FCFLAGS)
 LTFCCOMPILE = $(LIBTOOL) --tag=FC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=compile $(FC) $(AM_FCFLAGS) $(FCFLAGS)
-SOURCES = $(libcaf_single_la_SOURCES) $(libgfortran_la_SOURCES)
+SOURCES = $(libgfortranunit_a_SOURCES) $(libcaf_single_la_SOURCES) \
+	$(libgfortran_la_SOURCES)
 MULTISRCTOP = 
 MULTIBUILDTOP = 
 MULTIDIRS = 
@@ -620,6 +626,14 @@ AM_CPPFLAGS = -iquote$(srcdir)/io -I$(srcdir)/$(MULTISRCTOP)../gcc \
 	      -I$(MULTIBUILDTOP)../libbacktrace \
 	      -I../libbacktrace
 
+
+# Create a temporary lib for build with auto privatization
+gfor_unit_src = \
+io/open.c \
+io/unix.c \
+io/transfer.c \
+io/unit.c 
+
 gfor_io_src = io/size_from_kind.c $(am__append_2)
 gfor_io_headers = \
 io/io.h \
@@ -1288,6 +1302,20 @@ BUILT_SOURCES = $(gfor_built_src) $(gfor_built_specific_src) \
 prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \
     $(gfor_helper_src) $(gfor_ieee_src) $(gfor_io_headers) $(gfor_specific_src)
 
+libgfortranunit_a_SOURCES = $(gfor_unit_src)
+
+# Add libgfortran dirs to system includes in order to avoid auto privatization during build...
+libgfortranunit_a_CFLAGS = \
+-fPIC \
+-fmpc-privatize \
+-isystem $(srcdir) \
+-isystem $(srcdir)/io/ \
+-isystem $(srcdir)/runtime/ \
+-isystem $(srcdir)/config/ \
+-isystem $(srcdir)/caf/ \
+$(AM_CFLAGS)
+
+noinst_LIBRARIES = libgfortranunit.a
 @onestep_FALSE@libgfortran_la_SOURCES = $(prereq_SRC)
 
 #libgfortran_f.o: $(filter %.f %.f90,$(prereq_SRC))
@@ -1302,6 +1330,8 @@ prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \
 #libgfortran_F.lo: 
 #	$(LTPPFCCOMPILE) -c -o $@ $^ -combine
 @onestep_TRUE@libgfortran_la_SOURCES = libgfortran_c.c $(filter-out %.c,$(prereq_SRC))
+@onestep_FALSE@libgfortran_la_LIBADD = libgfortranunit.a
+@onestep_TRUE@libgfortran_la_LIBADD = libgfortranunit.a
 I_M4_DEPS = m4/iparm.m4
 I_M4_DEPS0 = $(I_M4_DEPS) m4/iforeach.m4
 I_M4_DEPS1 = $(I_M4_DEPS) m4/ifunction.m4
@@ -1363,6 +1393,13 @@ distclean-hdr:
 	-rm -f config.h stamp-h1
 libgfortran.spec: $(top_builddir)/config.status $(srcdir)/libgfortran.spec.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libgfortranunit.a: $(libgfortranunit_a_OBJECTS) $(libgfortranunit_a_DEPENDENCIES) $(EXTRA_libgfortranunit_a_DEPENDENCIES) 
+	-rm -f libgfortranunit.a
+	$(libgfortranunit_a_AR) libgfortranunit.a $(libgfortranunit_a_OBJECTS) $(libgfortranunit_a_LIBADD)
+	$(RANLIB) libgfortranunit.a
 install-cafexeclibLTLIBRARIES: $(cafexeclib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
 	@list='$(cafexeclib_LTLIBRARIES)'; test -n "$(cafexeclibdir)" || list=; \
@@ -1578,6 +1615,10 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iso_c_generated_procs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/kill.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortran_c.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortranunit_a-open.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortranunit_a-transfer.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortranunit_a-unit.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgfortranunit_a-unix.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/link.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/list_read.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock.Plo@am__quote@
@@ -1737,7 +1778,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/norm2_r16.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/norm2_r4.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/norm2_r8.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/open.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c10.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c16.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pack_c4.Plo@am__quote@
@@ -1878,7 +1918,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/system.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/system_clock.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/time.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transfer.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transfer128.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transpose_c10.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transpose_c16.Plo@am__quote@
@@ -1893,8 +1932,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transpose_r4.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/transpose_r8.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/umask.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unit.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unix.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unlink.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_c10.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unpack_c16.Plo@am__quote@
@@ -2362,6 +2399,62 @@ f2c_specifics.lo: intrinsics/f2c_specifics.F90
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
 
+libgfortranunit_a-open.o: io/open.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-open.o -MD -MP -MF $(DEPDIR)/libgfortranunit_a-open.Tpo -c -o libgfortranunit_a-open.o `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-open.Tpo $(DEPDIR)/libgfortranunit_a-open.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/open.c' object='libgfortranunit_a-open.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-open.o `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
+
+libgfortranunit_a-open.obj: io/open.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-open.obj -MD -MP -MF $(DEPDIR)/libgfortranunit_a-open.Tpo -c -o libgfortranunit_a-open.obj `if test -f 'io/open.c'; then $(CYGPATH_W) 'io/open.c'; else $(CYGPATH_W) '$(srcdir)/io/open.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-open.Tpo $(DEPDIR)/libgfortranunit_a-open.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/open.c' object='libgfortranunit_a-open.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-open.obj `if test -f 'io/open.c'; then $(CYGPATH_W) 'io/open.c'; else $(CYGPATH_W) '$(srcdir)/io/open.c'; fi`
+
+libgfortranunit_a-unix.o: io/unix.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unix.o -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unix.Tpo -c -o libgfortranunit_a-unix.o `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unix.Tpo $(DEPDIR)/libgfortranunit_a-unix.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unix.c' object='libgfortranunit_a-unix.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unix.o `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
+
+libgfortranunit_a-unix.obj: io/unix.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unix.obj -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unix.Tpo -c -o libgfortranunit_a-unix.obj `if test -f 'io/unix.c'; then $(CYGPATH_W) 'io/unix.c'; else $(CYGPATH_W) '$(srcdir)/io/unix.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unix.Tpo $(DEPDIR)/libgfortranunit_a-unix.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unix.c' object='libgfortranunit_a-unix.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unix.obj `if test -f 'io/unix.c'; then $(CYGPATH_W) 'io/unix.c'; else $(CYGPATH_W) '$(srcdir)/io/unix.c'; fi`
+
+libgfortranunit_a-transfer.o: io/transfer.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-transfer.o -MD -MP -MF $(DEPDIR)/libgfortranunit_a-transfer.Tpo -c -o libgfortranunit_a-transfer.o `test -f 'io/transfer.c' || echo '$(srcdir)/'`io/transfer.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-transfer.Tpo $(DEPDIR)/libgfortranunit_a-transfer.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/transfer.c' object='libgfortranunit_a-transfer.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-transfer.o `test -f 'io/transfer.c' || echo '$(srcdir)/'`io/transfer.c
+
+libgfortranunit_a-transfer.obj: io/transfer.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-transfer.obj -MD -MP -MF $(DEPDIR)/libgfortranunit_a-transfer.Tpo -c -o libgfortranunit_a-transfer.obj `if test -f 'io/transfer.c'; then $(CYGPATH_W) 'io/transfer.c'; else $(CYGPATH_W) '$(srcdir)/io/transfer.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-transfer.Tpo $(DEPDIR)/libgfortranunit_a-transfer.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/transfer.c' object='libgfortranunit_a-transfer.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-transfer.obj `if test -f 'io/transfer.c'; then $(CYGPATH_W) 'io/transfer.c'; else $(CYGPATH_W) '$(srcdir)/io/transfer.c'; fi`
+
+libgfortranunit_a-unit.o: io/unit.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unit.o -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unit.Tpo -c -o libgfortranunit_a-unit.o `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unit.Tpo $(DEPDIR)/libgfortranunit_a-unit.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unit.c' object='libgfortranunit_a-unit.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unit.o `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
+
+libgfortranunit_a-unit.obj: io/unit.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -MT libgfortranunit_a-unit.obj -MD -MP -MF $(DEPDIR)/libgfortranunit_a-unit.Tpo -c -o libgfortranunit_a-unit.obj `if test -f 'io/unit.c'; then $(CYGPATH_W) 'io/unit.c'; else $(CYGPATH_W) '$(srcdir)/io/unit.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libgfortranunit_a-unit.Tpo $(DEPDIR)/libgfortranunit_a-unit.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unit.c' object='libgfortranunit_a-unit.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgfortranunit_a_CFLAGS) $(CFLAGS) -c -o libgfortranunit_a-unit.obj `if test -f 'io/unit.c'; then $(CYGPATH_W) 'io/unit.c'; else $(CYGPATH_W) '$(srcdir)/io/unit.c'; fi`
+
 single.lo: caf/single.c
 @am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT single.lo -MD -MP -MF $(DEPDIR)/single.Tpo -c -o single.lo `test -f 'caf/single.c' || echo '$(srcdir)/'`caf/single.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/single.Tpo $(DEPDIR)/single.Plo
@@ -5176,13 +5269,6 @@ lock.lo: io/lock.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o lock.lo `test -f 'io/lock.c' || echo '$(srcdir)/'`io/lock.c
 
-open.lo: io/open.c
-@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT open.lo -MD -MP -MF $(DEPDIR)/open.Tpo -c -o open.lo `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/open.Tpo $(DEPDIR)/open.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/open.c' object='open.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o open.lo `test -f 'io/open.c' || echo '$(srcdir)/'`io/open.c
-
 read.lo: io/read.c
 @am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT read.lo -MD -MP -MF $(DEPDIR)/read.Tpo -c -o read.lo `test -f 'io/read.c' || echo '$(srcdir)/'`io/read.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/read.Tpo $(DEPDIR)/read.Plo
@@ -5190,13 +5276,6 @@ read.lo: io/read.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o read.lo `test -f 'io/read.c' || echo '$(srcdir)/'`io/read.c
 
-transfer.lo: io/transfer.c
-@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT transfer.lo -MD -MP -MF $(DEPDIR)/transfer.Tpo -c -o transfer.lo `test -f 'io/transfer.c' || echo '$(srcdir)/'`io/transfer.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/transfer.Tpo $(DEPDIR)/transfer.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/transfer.c' object='transfer.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o transfer.lo `test -f 'io/transfer.c' || echo '$(srcdir)/'`io/transfer.c
-
 transfer128.lo: io/transfer128.c
 @am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT transfer128.lo -MD -MP -MF $(DEPDIR)/transfer128.Tpo -c -o transfer128.lo `test -f 'io/transfer128.c' || echo '$(srcdir)/'`io/transfer128.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/transfer128.Tpo $(DEPDIR)/transfer128.Plo
@@ -5204,20 +5283,6 @@ transfer128.lo: io/transfer128.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o transfer128.lo `test -f 'io/transfer128.c' || echo '$(srcdir)/'`io/transfer128.c
 
-unit.lo: io/unit.c
-@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unit.lo -MD -MP -MF $(DEPDIR)/unit.Tpo -c -o unit.lo `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/unit.Tpo $(DEPDIR)/unit.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unit.c' object='unit.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unit.lo `test -f 'io/unit.c' || echo '$(srcdir)/'`io/unit.c
-
-unix.lo: io/unix.c
-@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT unix.lo -MD -MP -MF $(DEPDIR)/unix.Tpo -c -o unix.lo `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/unix.Tpo $(DEPDIR)/unix.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='io/unix.c' object='unix.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unix.lo `test -f 'io/unix.c' || echo '$(srcdir)/'`io/unix.c
-
 write.lo: io/write.c
 @am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT write.lo -MD -MP -MF $(DEPDIR)/write.Tpo -c -o write.lo `test -f 'io/write.c' || echo '$(srcdir)/'`io/write.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/write.Tpo $(DEPDIR)/write.Plo
@@ -5806,7 +5871,8 @@ distclean-tags:
 check-am: all-am
 check: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) check-am
-all-am: Makefile $(LTLIBRARIES) all-multi $(DATA) $(HEADERS) config.h
+all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \
+		$(HEADERS) config.h
 installdirs:
 	for dir in "$(DESTDIR)$(cafexeclibdir)" "$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(fincludedir)"; do \
 	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
@@ -5846,7 +5912,8 @@ maintainer-clean-generic:
 clean: clean-am clean-multi
 
 clean-am: clean-cafexeclibLTLIBRARIES clean-generic clean-libtool \
-	clean-toolexeclibLTLIBRARIES mostlyclean-am
+	clean-noinstLIBRARIES clean-toolexeclibLTLIBRARIES \
+	mostlyclean-am
 
 distclean: distclean-am distclean-multi
 	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
@@ -5926,10 +5993,10 @@ uninstall-am: uninstall-cafexeclibLTLIBRARIES \
 
 .PHONY: CTAGS GTAGS all all-am all-multi am--refresh check check-am \
 	clean clean-cafexeclibLTLIBRARIES clean-generic clean-libtool \
-	clean-multi clean-toolexeclibLTLIBRARIES ctags distclean \
-	distclean-compile distclean-generic distclean-hdr \
-	distclean-libtool distclean-multi distclean-tags dvi dvi-am \
-	html html-am info info-am install install-am \
+	clean-multi clean-noinstLIBRARIES clean-toolexeclibLTLIBRARIES \
+	ctags distclean distclean-compile distclean-generic \
+	distclean-hdr distclean-libtool distclean-multi distclean-tags \
+	dvi dvi-am html html-am info info-am install install-am \
 	install-cafexeclibLTLIBRARIES install-data install-data-am \
 	install-dvi install-dvi-am install-exec install-exec-am \
 	install-html install-html-am install-info install-info-am \
diff --git a/libgfortran/gfortran.map b/libgfortran/gfortran.map
index 5f011de68..e2ea3495f 100644
--- a/libgfortran/gfortran.map
+++ b/libgfortran/gfortran.map
@@ -30,6 +30,7 @@ GFORTRAN_1.0 {
     _gfortran_chmod_func;
     _gfortran_chmod_i4_sub;
     _gfortran_chmod_i8_sub;
+    _gfortran_close_units;
     _gfortran_compare_string;
     _gfortran_concat_string;
     _gfortran_count_1_l;
@@ -165,6 +166,7 @@ GFORTRAN_1.0 {
     _gfortran_idate_i8;
     _gfortran_ierrno_i4;
     _gfortran_ierrno_i8;
+    _gfortran_init_units;
     _gfortran_internal_pack;
     _gfortran_internal_unpack;
     _gfortran_irand;
@@ -1027,6 +1029,7 @@ GFORTRAN_1.0 {
     __iso_c_binding_c_f_pointer_l4;
     __iso_c_binding_c_f_pointer_l8;
     __iso_c_binding_c_f_pointer_u0;
+    __extls_get_addr_task;
   local:
     *;
 };
diff --git a/libgfortran/io/unit.c b/libgfortran/io/unit.c
index e0e7b09f6..94113fd0c 100644
--- a/libgfortran/io/unit.c
+++ b/libgfortran/io/unit.c
@@ -27,6 +27,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include "fbuf.h"
 #include "format.h"
 #include "unix.h"
+#include "libgfortran.h"
 #include <stdlib.h>
 #include <string.h>
 
@@ -688,6 +689,7 @@ init_units (void)
   for (i = 0; i < sizeof (max_offset) * 8 - 1; i++)
     max_offset = max_offset + ((gfc_offset) 1 << i);
 }
+iexport(init_units);
 
 
 static int
@@ -769,6 +771,7 @@ close_units (void)
   freelocale (c_locale);
 #endif
 }
+iexport(close_units);
 
 
 /* High level interface to truncate a file, i.e. flush format buffers,
@@ -884,3 +887,16 @@ get_unique_unit_number (st_parameter_open *opp)
     }
   return num;
 }
+
+/* Just a fake __sctk__tls_get_addr__task_scope to allow MPC to test the compiler during configuration */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+void * __attribute__ ((weak))
+__extls_get_addr_task (tls_index * tmp)
+{
+    return NULL;
+}
diff --git a/libgfortran/libgfortran.h b/libgfortran/libgfortran.h
index 79f0d61c8..78b5ea54d 100644
--- a/libgfortran/libgfortran.h
+++ b/libgfortran/libgfortran.h
@@ -852,10 +852,10 @@ internal_proto(flush_all_units);
 /* io.c */
 
 extern void init_units (void);
-internal_proto(init_units);
+iexport_proto(init_units);
 
 extern void close_units (void);
-internal_proto(close_units);
+iexport_proto(close_units);
 
 extern int unit_to_fd (int);
 internal_proto(unit_to_fd);
diff --git a/libgfortran/runtime/main.c b/libgfortran/runtime/main.c
index 5065d9cf9..501321d74 100644
--- a/libgfortran/runtime/main.c
+++ b/libgfortran/runtime/main.c
@@ -111,8 +111,9 @@ init (void)
 
   /* Must be first */
   init_variables ();
-
-  init_units ();
+  
+  //Deported to mpc with TLS context
+  //init_units ();
 
   /* If (and only if) the user asked for it, set up the FPU state.  */
   if (options.fpe != 0)
@@ -129,5 +130,6 @@ init (void)
 static void __attribute__((destructor))
 cleanup (void)
 {
-  close_units ();
+  //Deported to mpc with TLS context
+  //close_units ();
 }
diff --git a/libstdc++-v3/include/bits/regex_executor.tcc b/libstdc++-v3/include/bits/regex_executor.tcc
index 2abd02099..425b67335 100644
--- a/libstdc++-v3/include/bits/regex_executor.tcc
+++ b/libstdc++-v3/include/bits/regex_executor.tcc
@@ -124,10 +124,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    break;
 	  std::fill_n(_M_states._M_visited_states.get(), _M_nfa.size(), false);
 	  auto __old_queue = std::move(_M_states._M_match_queue);
-	  for (auto& __task : __old_queue)
+	  for (auto& __ytask : __old_queue)
 	    {
-	      _M_cur_results = std::move(__task.second);
-	      _M_dfs(__match_mode, __task.first);
+	      _M_cur_results = std::move(__ytask.second);
+	      _M_dfs(__match_mode, __ytask.first);
 	    }
 	  if (__match_mode == _Match_mode::_Prefix)
 	    __ret |= _M_has_sol;
