diff --git a/gcc/builtin-types.def b/gcc/builtin-types.def
index ac9894467..1efc93561 100644
--- a/gcc/builtin-types.def
+++ b/gcc/builtin-types.def
@@ -791,3 +791,9 @@ DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_LDOUBLE, BT_VOID,
 		     BT_VOLATILE_PTR, BT_LONGDOUBLE)
 DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_SIZE, BT_VOID,
 		     BT_VOLATILE_PTR, BT_SIZE)
+
+DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_LONG_LONG_LONG_INT_INT_INT_INT,
+		     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,
+		     BT_LONG, BT_LONG, BT_LONG, BT_INT, BT_INT, BT_INT,BT_INT)
+
+
diff --git a/gcc/builtins.def b/gcc/builtins.def
index 58d78dbbd..eb4c7a6c5 100644
--- a/gcc/builtins.def
+++ b/gcc/builtins.def
@@ -191,6 +191,16 @@ along with GCC; see the file COPYING3.  If not see
 #define DEF_GOACC_BUILTIN_COMPILER(ENUM, NAME, TYPE, ATTRS) \
   DEF_BUILTIN (ENUM, "__builtin_" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \
 	       flag_openacc, true, true, ATTRS, false, true)
+
+  
+#undef DEF_MPC_WS_BUILTIN
+#define DEF_MPC_WS_BUILTIN(ENUM, NAME, TYPE, ATTRS) \
+  DEF_BUILTIN (ENUM, "__builtin_" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \
+               false, true, true, ATTRS, false, \
+	       (flag_mpc_ws \
+		|| flag_offload_abi != OFFLOAD_ABI_UNSET))
+
+#undef DEF_HSA_BUILTIN
 #undef DEF_GOMP_BUILTIN
 #define DEF_GOMP_BUILTIN(ENUM, NAME, TYPE, ATTRS) \
   DEF_BUILTIN (ENUM, "__builtin_" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \
@@ -201,7 +211,7 @@ along with GCC; see the file COPYING3.  If not see
 		|| flag_cilkplus \
 		|| flag_offload_abi != OFFLOAD_ABI_UNSET))
 
-#undef DEF_HSA_BUILTIN
+
 #ifdef ENABLE_HSA
 #define DEF_HSA_BUILTIN(ENUM, NAME, TYPE, ATTRS)			\
   DEF_BUILTIN (ENUM, "__builtin_" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \
diff --git a/gcc/c-family/c-common.h b/gcc/c-family/c-common.h
index b93334204..b5ff9cbdb 100644
--- a/gcc/c-family/c-common.h
+++ b/gcc/c-family/c-common.h
@@ -1268,7 +1268,8 @@ enum c_omp_clause_split
   C_OMP_CLAUSE_SPLIT_SIMD,
   C_OMP_CLAUSE_SPLIT_COUNT,
   C_OMP_CLAUSE_SPLIT_SECTIONS = C_OMP_CLAUSE_SPLIT_FOR,
-  C_OMP_CLAUSE_SPLIT_TASKLOOP = C_OMP_CLAUSE_SPLIT_FOR
+  C_OMP_CLAUSE_SPLIT_TASKLOOP = C_OMP_CLAUSE_SPLIT_FOR,
+  C_OMP_CLAUSE_SPLIT_WS_FOR = C_OMP_CLAUSE_SPLIT_FOR
 };
 
 enum c_omp_region_type
@@ -1283,6 +1284,9 @@ enum c_omp_region_type
 extern tree c_finish_omp_master (location_t, tree);
 extern tree c_finish_omp_taskgroup (location_t, tree);
 extern tree c_finish_omp_critical (location_t, tree, tree, tree);
+extern tree c_finish_ws_critical (location_t, tree, tree, tree);
+extern void c_finish_ws_stopsteal (location_t);
+extern void c_finish_ws_resteal (location_t);
 extern tree c_finish_omp_ordered (location_t, tree, tree);
 extern void c_finish_omp_barrier (location_t);
 extern tree c_finish_omp_atomic (location_t, enum tree_code, enum tree_code,
diff --git a/gcc/c-family/c-omp.c b/gcc/c-family/c-omp.c
index 977cb0ea1..105d8f166 100644
--- a/gcc/c-family/c-omp.c
+++ b/gcc/c-family/c-omp.c
@@ -107,6 +107,38 @@ c_finish_omp_critical (location_t loc, tree body, tree name, tree clauses)
   return add_stmt (stmt);
 }
 
+tree
+c_finish_ws_critical (location_t loc, tree body, tree name, tree clauses)
+{
+  tree stmt = make_node (WS_CRITICAL);
+  TREE_TYPE (stmt) = void_type_node;
+  OMP_CRITICAL_BODY (stmt) = body;
+  OMP_CRITICAL_NAME (stmt) = name;
+  OMP_CRITICAL_CLAUSES (stmt) = clauses;
+  SET_EXPR_LOCATION (stmt, loc);
+  return add_stmt (stmt);
+}
+
+void
+c_finish_ws_stopsteal (location_t loc)
+{
+  tree x;
+
+  x = builtin_decl_explicit (BUILT_IN_MPC_WS_STOPSTEAL);
+  x = build_call_expr_loc (loc, x, 1,build_int_cst (integer_type_node, 0));
+  add_stmt (x);
+}
+
+void
+c_finish_ws_resteal (location_t loc)
+{
+  tree x;
+
+  x = builtin_decl_explicit (BUILT_IN_MPC_WS_RESTEAL);
+  x = build_call_expr_loc (loc, x, 0);
+  add_stmt (x);
+}
+
 /* Complete a #pragma omp ordered construct.  STMT is the structured-block
    that follows the pragma.  LOC is the location of the #pragma.  */
 
diff --git a/gcc/c-family/c-pragma.c b/gcc/c-family/c-pragma.c
index d8ef48bee..92258d77a 100644
--- a/gcc/c-family/c-pragma.c
+++ b/gcc/c-family/c-pragma.c
@@ -1536,6 +1536,16 @@ init_pragma (void)
     cpp_register_deferred_pragma (parse_in, "cilk", "grainsize",
 				  PRAGMA_CILK_GRAINSIZE, true, false);
 
+  /* MPC WS */
+  if(flag_mpc_ws)
+  {
+    cpp_register_deferred_pragma(parse_in, "ws", "for", PRAGMA_WS_FOR, true,true);
+    cpp_register_deferred_pragma(parse_in, "ws", "atomic", PRAGMA_WS_ATOMIC, true,true);
+    cpp_register_deferred_pragma(parse_in, "ws", "critical", PRAGMA_WS_CRITICAL, true,true);
+    cpp_register_deferred_pragma(parse_in, "ws", "stopsteal", PRAGMA_WS_STOPSTEAL, true,true);
+    cpp_register_deferred_pragma(parse_in, "ws", "resteal", PRAGMA_WS_RESTEAL, true,true);
+  }
+
 #ifdef HANDLE_PRAGMA_PACK_WITH_EXPANSION
   c_register_pragma_with_expansion (0, "pack", handle_pragma_pack);
 #else
diff --git a/gcc/c-family/c-pragma.h b/gcc/c-family/c-pragma.h
index a79036e97..d3d28771d 100644
--- a/gcc/c-family/c-pragma.h
+++ b/gcc/c-family/c-pragma.h
@@ -75,6 +75,12 @@ enum pragma_kind {
 
   PRAGMA_GCC_PCH_PREPROCESS,
   PRAGMA_IVDEP,
+  /* MPC WS */
+  PRAGMA_WS_FOR,
+  PRAGMA_WS_ATOMIC,
+  PRAGMA_WS_CRITICAL,
+  PRAGMA_WS_STOPSTEAL,
+  PRAGMA_WS_RESTEAL,
 
   PRAGMA_FIRST_EXTERNAL
 };
@@ -126,6 +132,7 @@ enum pragma_omp_clause {
   PRAGMA_OMP_CLAUSE_SHARED,
   PRAGMA_OMP_CLAUSE_SIMD,
   PRAGMA_OMP_CLAUSE_SIMDLEN,
+  PRAGMA_OMP_CLAUSE_STEAL_SCHEDULE,
   PRAGMA_OMP_CLAUSE_TASKGROUP,
   PRAGMA_OMP_CLAUSE_THREAD_LIMIT,
   PRAGMA_OMP_CLAUSE_THREADS,
@@ -181,7 +188,21 @@ enum pragma_omp_clause {
   PRAGMA_OACC_CLAUSE_IF = PRAGMA_OMP_CLAUSE_IF,
   PRAGMA_OACC_CLAUSE_PRIVATE = PRAGMA_OMP_CLAUSE_PRIVATE,
   PRAGMA_OACC_CLAUSE_REDUCTION = PRAGMA_OMP_CLAUSE_REDUCTION,
-  PRAGMA_OACC_CLAUSE_LINK = PRAGMA_OMP_CLAUSE_LINK
+  PRAGMA_OACC_CLAUSE_LINK = PRAGMA_OMP_CLAUSE_LINK,
+  
+  /* Clauses for MPC WS. */
+  PRAGMA_WS_CLAUSE_STEAL_SCHEDULE = PRAGMA_OMP_CLAUSE_STEAL_SCHEDULE,
+  PRAGMA_WS_CLAUSE_SCHEDULE = PRAGMA_OMP_CLAUSE_SCHEDULE,
+  PRAGMA_WS_CLAUSE_COLLAPSE = PRAGMA_OMP_CLAUSE_COLLAPSE,
+  PRAGMA_WS_CLAUSE_COPYIN = PRAGMA_OMP_CLAUSE_COPYIN,
+  PRAGMA_WS_CLAUSE_DEFAULT = PRAGMA_OMP_CLAUSE_DEFAULT,
+  PRAGMA_WS_CLAUSE_SHARED = PRAGMA_OMP_CLAUSE_SHARED,
+  PRAGMA_WS_CLAUSE_PRIVATE = PRAGMA_OMP_CLAUSE_PRIVATE,
+  PRAGMA_WS_CLAUSE_FIRSTPRIVATE = PRAGMA_OMP_CLAUSE_FIRSTPRIVATE,
+  PRAGMA_WS_CLAUSE_LASTPRIVATE = PRAGMA_OMP_CLAUSE_LASTPRIVATE,
+  PRAGMA_WS_CLAUSE_REDUCTION = PRAGMA_OMP_CLAUSE_REDUCTION,
+  PRAGMA_WS_CLAUSE_NUM_TASKS = PRAGMA_OMP_CLAUSE_NUM_TASKS,
+  PRAGMA_WS_CLAUSE_NOWAIT = PRAGMA_OMP_CLAUSE_NOWAIT
 };
 
 extern struct cpp_reader* parse_in;
diff --git a/gcc/c-family/c.opt b/gcc/c-family/c.opt
index 13b930d75..19a3c5434 100644
--- a/gcc/c-family/c.opt
+++ b/gcc/c-family/c.opt
@@ -1409,6 +1409,14 @@ C++ ObjC++ Ignore Warn(switch %qs is no longer supported)
 fhandle-exceptions
 C++ ObjC++ Optimization Alias(fexceptions) Warn({-fhandle-exceptions has been renamed -fexceptions (and is now on by default)})
 
+fws
+C C++ Var(flag_mpc_ws)
+Enable MPC Workshare (ws) directives
+
+fws-verbose
+C C++ Var(flag_mpc_ws,2) 
+Enable MPC Workshare (ws) directives with verbose output
+
 fhonor-std
 C++ ObjC++ Ignore Warn(switch %qs is no longer supported)
 
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
index 101afb8e3..306efe5db 100644
--- a/gcc/c/c-parser.c
+++ b/gcc/c/c-parser.c
@@ -1262,6 +1262,8 @@ static void c_parser_oacc_update (c_parser *);
 static void c_parser_omp_construct (c_parser *, bool *);
 static void c_parser_omp_threadprivate (c_parser *);
 static void c_parser_omp_barrier (c_parser *);
+static void c_parser_ws_stopsteal(c_parser *);
+static void c_parser_ws_resteal(c_parser *);
 static void c_parser_omp_flush (c_parser *);
 static tree c_parser_omp_for_loop (location_t, c_parser *, enum tree_code,
 				   tree, tree *, bool *);
@@ -10279,6 +10281,20 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)
     case PRAGMA_OMP_THREADPRIVATE:
       c_parser_omp_threadprivate (parser);
       return false;
+    case PRAGMA_WS_STOPSTEAL:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;33mFound WS STOPSTEAL pragma !\n\033[0;0m");
+      }
+      c_parser_ws_stopsteal(parser);
+      return false;
+    case PRAGMA_WS_RESTEAL:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;33mFound WS RESTEAL pragma !\n\033[0;0m");
+      }
+      c_parser_ws_resteal(parser);
+      return false;
 
     case PRAGMA_OMP_TARGET:
       return c_parser_omp_target (parser, context, if_p);
@@ -10602,6 +10618,8 @@ c_parser_omp_clause_name (c_parser *parser)
 	    result = PRAGMA_OMP_CLAUSE_SIMDLEN;
 	  else if (!strcmp ("self", p))
 	    result = PRAGMA_OACC_CLAUSE_SELF;
+    else if(!strcmp("steal_schedule", p))
+      result = PRAGMA_WS_CLAUSE_STEAL_SCHEDULE;
 	  break;
 	case 't':
 	  if (!strcmp ("taskgroup", p))
@@ -17377,8 +17395,368 @@ c_parser_omp_taskloop (location_t loc, c_parser *parser,
   return ret;
 }
 
+static tree
+c_parser_ws_clause_steal_schedule (c_parser *parser, tree list)
+{
+  tree c, t;
+  location_t loc = c_parser_peek_token (parser)->location;
+  int modifiers = 0, nmodifiers = 0;
+
+  if (!c_parser_require (parser, CPP_OPEN_PAREN, "expected %<(%>"))
+    return list;
+
+  c = build_omp_clause (loc, OMP_CLAUSE_STEAL_SCHEDULE);
+
+  while (c_parser_next_token_is (parser, CPP_NAME))
+    {
+      tree kind = c_parser_peek_token (parser)->value;
+      const char *p = IDENTIFIER_POINTER (kind);
+      if (strcmp ("simd", p) == 0)
+	OMP_CLAUSE_STEAL_SCHEDULE_SIMD (c) = 1;
+      else if (strcmp ("monotonic", p) == 0)
+	modifiers |= OMP_CLAUSE_SCHEDULE_MONOTONIC;
+      else if (strcmp ("nonmonotonic", p) == 0)
+	modifiers |= OMP_CLAUSE_SCHEDULE_NONMONOTONIC;
+      else
+	break;
+      c_parser_consume_token (parser);
+      if (nmodifiers++ == 0
+	  && c_parser_next_token_is (parser, CPP_COMMA))
+	c_parser_consume_token (parser);
+      else
+	{
+	  c_parser_require (parser, CPP_COLON, "expected %<:%>");
+	  break;
+	}
+    }
+
+  if ((modifiers & (OMP_CLAUSE_SCHEDULE_MONOTONIC
+		    | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))
+      == (OMP_CLAUSE_SCHEDULE_MONOTONIC
+	  | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))
+    {
+      error_at (loc, "both %<monotonic%> and %<nonmonotonic%> modifiers "
+		     "specified");
+      modifiers = 0;
+    }
+
+  if (c_parser_next_token_is (parser, CPP_NAME))
+    {
+      tree kind = c_parser_peek_token (parser)->value;
+      const char *p = IDENTIFIER_POINTER (kind);
+
+      switch (p[0])
+	{
+	case 'd':
+	  if (strcmp ("dynamic", p) != 0)
+	    goto invalid_kind;
+	  OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_DYNAMIC;
+	  break;
+
+        case 'g':
+	  if (strcmp ("guided", p) != 0)
+	    goto invalid_kind;
+	  OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_GUIDED;
+	  break;
+
+	case 'r':
+	  if (strcmp ("runtime", p) != 0)
+	    goto invalid_kind;
+	  OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_RUNTIME;
+	  break;
+
+	default:
+	  goto invalid_kind;
+	}
+    }
+  else if (c_parser_next_token_is_keyword (parser, RID_STATIC))
+    OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_STATIC;
+  else if (c_parser_next_token_is_keyword (parser, RID_AUTO))
+    OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_AUTO;
+  else
+    goto invalid_kind;
+
+  c_parser_consume_token (parser);
+  if (c_parser_next_token_is (parser, CPP_COMMA))
+    {
+      location_t here;
+      c_parser_consume_token (parser);
+
+      here = c_parser_peek_token (parser)->location;
+      c_expr expr = c_parser_expr_no_commas (parser, NULL);
+      expr = convert_lvalue_to_rvalue (here, expr, false, true);
+      t = expr.value;
+      t = c_fully_fold (t, false, NULL);
+
+      if (OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)
+	error_at (here, "steal schedule %<runtime%> does not take "
+		  "a %<chunk_size%> parameter");
+      else if (OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_AUTO)
+	error_at (here,
+		  "steal schedule %<auto%> does not take "
+		  "a %<chunk_size%> parameter");
+      else if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE)
+	{
+	  /* Attempt to statically determine when the number isn't
+	     positive.  */
+	  tree s = fold_build2_loc (loc, LE_EXPR, boolean_type_node, t,
+				    build_int_cst (TREE_TYPE (t), 0));
+	  protected_set_expr_location (s, loc);
+	  if (s == boolean_true_node)
+	    {
+	      warning_at (loc, 0,
+			  "chunk size value must be positive");
+	      t = integer_one_node;
+	    }
+	  OMP_CLAUSE_STEAL_SCHEDULE_CHUNK_EXPR (c) = t;
+	}
+      else
+	c_parser_error (parser, "expected integer expression");
+
+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, "expected %<)%>");
+    }
+  else
+    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
+			       "expected %<,%> or %<)%>");
+
+  OMP_CLAUSE_STEAL_SCHEDULE_KIND (c)
+    = (enum omp_clause_schedule_kind)
+      (OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) | modifiers);
+
+  check_no_duplicate_clause (list, OMP_CLAUSE_STEAL_SCHEDULE, "steal_schedule");
+  OMP_CLAUSE_CHAIN (c) = list;
+  return c;
+
+ invalid_kind:
+  c_parser_error (parser, "invalid schedule kind");
+  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, 0);
+  return list;
+}
+
+static tree
+c_parser_ws_all_clauses (c_parser *parser, omp_clause_mask mask,
+			  const char *where, bool finish_p = true)
+{
+  tree clauses = NULL;
+  bool first = true;
+
+  while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))
+    {
+      location_t here;
+      pragma_omp_clause c_kind;
+      const char *c_name;
+      tree prev = clauses;
+
+      if (!first && c_parser_next_token_is (parser, CPP_COMMA))
+	c_parser_consume_token (parser);
+
+      here = c_parser_peek_token (parser)->location;
+      c_kind = c_parser_omp_clause_name (parser);
+
+      switch (c_kind)
+	{
+	case PRAGMA_WS_CLAUSE_COLLAPSE:
+	  clauses = c_parser_omp_clause_collapse (parser, clauses);
+	  c_name = "collapse";
+	  break;
+	case PRAGMA_WS_CLAUSE_COPYIN:
+	  clauses = c_parser_omp_clause_copyin (parser, clauses);
+	  c_name = "copyin";
+	  break;
+	case PRAGMA_WS_CLAUSE_DEFAULT:
+	  clauses = c_parser_omp_clause_default (parser, clauses, false);
+	  c_name = "default";
+	  break;
+	case PRAGMA_WS_CLAUSE_FIRSTPRIVATE:
+	  clauses = c_parser_omp_clause_firstprivate (parser, clauses);
+	  c_name = "firstprivate";
+	  break;
+	case PRAGMA_WS_CLAUSE_LASTPRIVATE:
+	  clauses = c_parser_omp_clause_lastprivate (parser, clauses);
+	  c_name = "lastprivate";
+	  break;
+	case PRAGMA_WS_CLAUSE_NOWAIT:
+	  clauses = c_parser_omp_clause_nowait (parser, clauses);
+	  c_name = "nowait";
+	  break;
+	case PRAGMA_WS_CLAUSE_NUM_TASKS:
+	  clauses = c_parser_omp_clause_num_tasks (parser, clauses);
+	  c_name = "num_tasks";
+	  break;
+	case PRAGMA_WS_CLAUSE_PRIVATE:
+	  clauses = c_parser_omp_clause_private (parser, clauses);
+	  c_name = "private";
+	  break;
+	case PRAGMA_WS_CLAUSE_REDUCTION:
+	  clauses = c_parser_omp_clause_reduction (parser, clauses);
+	  c_name = "reduction";
+	  break;
+	case PRAGMA_WS_CLAUSE_SCHEDULE:
+	  clauses = c_parser_omp_clause_schedule (parser, clauses);
+	  c_name = "schedule";
+	  break;
+	case PRAGMA_WS_CLAUSE_STEAL_SCHEDULE:
+	  clauses = c_parser_ws_clause_steal_schedule (parser, clauses);
+	  c_name = "steal_schedule";
+	  break;
+	case PRAGMA_WS_CLAUSE_SHARED:
+	  clauses = c_parser_omp_clause_shared (parser, clauses);
+	  c_name = "shared";
+	  break;
+	default:
+	  c_parser_error (parser, "expected %<#pragma omp%> clause");
+	  goto saw_error;
+	}
+
+      first = false;
+
+      if (((mask >> c_kind) & 1) == 0)
+	{
+	  /* Remove the invalid clause(s) from the list to avoid
+	     confusing the rest of the compiler.  */
+	  clauses = prev;
+	  error_at (here, "%qs is not valid for %qs", c_name, where);
+	}
+    }
+
+ saw_error:
+  c_parser_skip_to_pragma_eol (parser);
+
+  if (finish_p)
+    {
+      return c_finish_omp_clauses (clauses, C_ORT_OMP);
+    }
+
+  return clauses;
+}
+
+#define WS_FOR_CLAUSE_MASK				\
+	( (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_SHARED)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_PRIVATE)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_FIRSTPRIVATE)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_LASTPRIVATE)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_DEFAULT)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_COLLAPSE)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_REDUCTION) \
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_SCHEDULE) \
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_STEAL_SCHEDULE) \
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_SIMD) \
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_NOWAIT))
+
+static tree c_parser_ws_for(location_t loc, c_parser *parser,                                  
+    char *p_name, omp_clause_mask mask, tree *cclauses,                                        
+    bool *if_p)                                                                               
+{                                                                                             
+  tree clauses, block, ret;
+
+  strcat (p_name, " for");
+  mask |= WS_FOR_CLAUSE_MASK;
+
+  if (c_parser_next_token_is (parser, CPP_NAME))
+    {
+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);
+
+      if (strcmp (p, "simd") == 0)
+	{
+	  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
+	  if (cclauses == NULL)
+	    cclauses = cclauses_buf;
+	  mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION);
+	  c_parser_consume_token (parser);
+	  if (!flag_mpc_ws)  /* flag_openmp_simd  */
+	    return c_parser_omp_simd (loc, parser, p_name, mask, cclauses,
+				      if_p);
+	  block = c_begin_compound_stmt (true);
+	  ret = c_parser_omp_simd (loc, parser, p_name, mask, cclauses, if_p);
+	  block = c_end_compound_stmt (loc, block, true);
+	  if (ret == NULL)
+	    return ret;
+	  //ret = make_node (OMP_TASKLOOP);
+	  ret = make_node (WS_FOR);
+	  TREE_TYPE (ret) = void_type_node;
+	  OMP_FOR_BODY (ret) = block;
+    OMP_FOR_CLAUSES (ret) = cclauses[C_OMP_CLAUSE_SPLIT_WS_FOR];
+    SET_EXPR_LOCATION (ret, loc);
+	  add_stmt (ret);
+	  return ret;
+	}
+    }
+
+  if (!flag_mpc_ws)  /* flag_openmp_simd  */
+  {
+    c_parser_skip_to_pragma_eol (parser, false);
+    return NULL_TREE;
+  }
+  clauses = c_parser_ws_all_clauses (parser, mask, p_name, cclauses == NULL);
+  if (cclauses)
+    {
+      omp_split_clauses (loc, WS_FOR, mask, clauses, cclauses);
+      clauses = cclauses[C_OMP_CLAUSE_SPLIT_WS_FOR];
+    }
+
+  block = c_begin_compound_stmt (true);
+  ret = c_parser_omp_for_loop (loc, parser, WS_FOR, clauses, NULL, if_p);
+  block = c_end_compound_stmt (loc, block, true);
+  add_stmt (block);
+
+  return ret;
+                                                                              
+}        
+
+static tree
+c_parser_ws_critical (location_t loc, c_parser *parser, bool *if_p)
+{
+  tree stmt, name = NULL_TREE, clauses = NULL_TREE;
+
+  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))
+    {
+      c_parser_consume_token (parser);
+      if (c_parser_next_token_is (parser, CPP_NAME))
+	{
+	  name = c_parser_peek_token (parser)->value;
+	  c_parser_consume_token (parser);
+	  c_parser_require (parser, CPP_CLOSE_PAREN, "expected %<)%>");
+	}
+      else
+	c_parser_error (parser, "expected identifier");
+
+      clauses = c_parser_omp_all_clauses (parser,
+					  OMP_CRITICAL_CLAUSE_MASK,
+					  "#pragma omp critical");
+    }
+  else
+    {
+      if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))
+	c_parser_error (parser, "expected %<(%> or end of line");
+      c_parser_skip_to_pragma_eol (parser);
+    }
+
+  stmt = c_parser_omp_structured_block (parser, if_p);
+  return c_finish_ws_critical (loc, stmt, name, clauses);
+}
 /* Main entry point to parsing most OpenMP pragmas.  */
 
+static void
+c_parser_ws_stopsteal (c_parser *parser)
+{
+  location_t loc = c_parser_peek_token (parser)->location;
+  c_parser_consume_pragma (parser);
+  c_parser_skip_to_pragma_eol (parser);
+
+  c_finish_ws_stopsteal (loc);
+}
+
+
+static void
+c_parser_ws_resteal (c_parser *parser)
+{
+  location_t loc = c_parser_peek_token (parser)->location;
+  c_parser_consume_pragma (parser);
+  c_parser_skip_to_pragma_eol (parser);
+
+  c_finish_ws_resteal (loc);
+}
+
 static void
 c_parser_omp_construct (c_parser *parser, bool *if_p)
 {
@@ -17467,6 +17845,44 @@ c_parser_omp_construct (c_parser *parser, bool *if_p)
       strcpy (p_name, "#pragma omp");
       stmt = c_parser_omp_teams (loc, parser, p_name, mask, NULL, if_p);
       break;
+    case PRAGMA_WS_FOR:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;33mFound WS FOR pragma !\n\033[0;0m");
+      }
+      strcpy (p_name, "#pragma ws");
+      stmt = c_parser_ws_for (loc, parser, p_name, mask, NULL, if_p);
+      break;
+    case PRAGMA_WS_ATOMIC:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;33mFound WS ATOMIC pragma !\n\033[0;0m");
+      }
+      c_parser_omp_atomic (loc, parser);
+      stmt = NULL_TREE;
+      break;
+    case PRAGMA_WS_CRITICAL:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;33mFound WS CRITICAL pragma !\n\033[0;0m");
+      }
+      stmt = c_parser_ws_critical (loc, parser, if_p);
+      break;
+    case PRAGMA_WS_STOPSTEAL:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;33mFound WS STOPSTEAL pragma !\n\033[0;0m");
+      }
+      c_parser_ws_stopsteal(parser);
+      break;
+    case PRAGMA_WS_RESTEAL:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;33mFound WS RESTEAL pragma !\n\033[0;0m");
+      }
+      c_parser_ws_resteal(parser);
+      break;
+     
     default:
       gcc_unreachable ();
     }
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
index ee365313c..ef24baba3 100644
--- a/gcc/c/c-typeck.c
+++ b/gcc/c/c-typeck.c
@@ -13664,6 +13664,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)
 	case OMP_CLAUSE_WORKER:
 	case OMP_CLAUSE_VECTOR:
 	case OMP_CLAUSE_TILE:
+	case OMP_CLAUSE_STEAL_SCHEDULE:
 	  pc = &OMP_CLAUSE_CHAIN (c);
 	  continue;
 
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
index 9082230b9..b156ed1ab 100644
--- a/gcc/cp/constexpr.c
+++ b/gcc/cp/constexpr.c
@@ -5490,6 +5490,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,
     case TRANSACTION_EXPR:
     case ASM_EXPR:
     case AT_ENCODE_EXPR:
+    case WS_FOR:
+    case WS_CRITICAL:
     fail:
       if (flags & tf_error)
 	error_at (loc, "expression %qE is not a constant expression", t);
diff --git a/gcc/cp/cp-gimplify.c b/gcc/cp/cp-gimplify.c
index b0e010e18..9d5767a2e 100644
--- a/gcc/cp/cp-gimplify.c
+++ b/gcc/cp/cp-gimplify.c
@@ -387,7 +387,7 @@ genericize_omp_for_stmt (tree *stmt_p, int *walk_subtrees, void *data)
   tree clab = begin_bc_block (bc_continue, locus);
 
   cp_walk_tree (&OMP_FOR_BODY (stmt), cp_genericize_r, data, NULL);
-  if (TREE_CODE (stmt) != OMP_TASKLOOP)
+  if (TREE_CODE (stmt) != OMP_TASKLOOP && TREE_CODE (stmt) != WS_FOR)
     cp_walk_tree (&OMP_FOR_CLAUSES (stmt), cp_genericize_r, data, NULL);
   cp_walk_tree (&OMP_FOR_INIT (stmt), cp_genericize_r, data, NULL);
   cp_walk_tree (&OMP_FOR_COND (stmt), cp_genericize_r, data, NULL);
@@ -764,6 +764,7 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
     case OMP_SIMD:
     case OMP_DISTRIBUTE:
     case OMP_TASKLOOP:
+    case WS_FOR:
       ret = cp_gimplify_omp_for (expr_p, pre_p);
       break;
 
@@ -1031,7 +1032,7 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)
   code = TREE_CODE (stmt);
   if (code == OMP_FOR || code == OMP_SIMD || code == OMP_DISTRIBUTE
       || code == OMP_TASKLOOP || code == CILK_FOR || code == CILK_SIMD
-      || code == OACC_LOOP)
+      || code == OACC_LOOP || code == WS_FOR)
     {
       tree x;
       int i, n;
@@ -1366,7 +1367,8 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)
     }
   else if (TREE_CODE (stmt) == OMP_PARALLEL
 	   || TREE_CODE (stmt) == OMP_TASK
-	   || TREE_CODE (stmt) == OMP_TASKLOOP)
+	   || TREE_CODE (stmt) == OMP_TASKLOOP
+	   || TREE_CODE (stmt) == WS_FOR)
     {
       struct cp_genericize_omp_taskreg omp_ctx;
       tree c, decl;
@@ -1406,7 +1408,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)
 	  default:
 	    break;
 	  }
-      if (TREE_CODE (stmt) == OMP_TASKLOOP)
+      if (TREE_CODE (stmt) == OMP_TASKLOOP || TREE_CODE (stmt) == WS_FOR)
 	genericize_omp_for_stmt (stmt_p, walk_subtrees, data);
       else
 	cp_walk_tree (&OMP_BODY (stmt), cp_genericize_r, data, NULL);
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index fadf6ecb1..e2fad6c05 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -6514,6 +6514,7 @@ extern void add_typedef_to_current_template_for_access_check (tree, tree,
 extern void check_accessibility_of_qualified_id (tree, tree, tree);
 extern tree finish_qualified_id_expr		(tree, tree, bool, bool,
 						 bool, bool, tsubst_flags_t);
+extern void finish_ws_stopsteal();
 extern void simplify_aggr_init_expr		(tree *);
 extern void finalize_nrv			(tree *, tree, tree);
 extern tree omp_reduction_id			(enum tree_code, tree, tree);
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 29aa76b5d..89586c10a 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -30772,6 +30772,8 @@ cp_parser_omp_clause_name (cp_parser *parser)
 	    result = PRAGMA_OMP_CLAUSE_SIMD;
 	  else if (!strcmp ("simdlen", p))
 	    result = PRAGMA_OMP_CLAUSE_SIMDLEN;
+	  else if (!strcmp ("steal_schedule", p))
+	    result = PRAGMA_WS_CLAUSE_STEAL_SCHEDULE;
 	  break;
 	case 't':
 	  if (!strcmp ("taskgroup", p))
@@ -37629,8 +37631,354 @@ cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn)
     }
 }
 
+static tree
+cp_parser_ws_clause_steal_schedule (cp_parser *parser, tree list, location_t location)
+{
+  tree c, t;
+  int modifiers = 0, nmodifiers = 0;
+
+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
+    return list;
+
+  c = build_omp_clause (location, OMP_CLAUSE_STEAL_SCHEDULE);
+
+  while (cp_lexer_next_token_is (parser->lexer, CPP_NAME))
+    {
+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;
+      const char *p = IDENTIFIER_POINTER (id);
+      if (strcmp ("simd", p) == 0)
+	OMP_CLAUSE_SCHEDULE_SIMD (c) = 1;
+      else if (strcmp ("monotonic", p) == 0)
+	modifiers |= OMP_CLAUSE_SCHEDULE_MONOTONIC;
+      else if (strcmp ("nonmonotonic", p) == 0)
+	modifiers |= OMP_CLAUSE_SCHEDULE_NONMONOTONIC;
+      else
+	break;
+      cp_lexer_consume_token (parser->lexer);
+      if (nmodifiers++ == 0
+	  && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))
+	cp_lexer_consume_token (parser->lexer);
+      else
+	{
+	  cp_parser_require (parser, CPP_COLON, RT_COLON);
+	  break;
+	}
+    }
+
+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))
+    {
+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;
+      const char *p = IDENTIFIER_POINTER (id);
+
+      switch (p[0])
+	{
+	case 'd':
+	  if (strcmp ("dynamic", p) != 0)
+	    goto invalid_kind;
+	  OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_DYNAMIC;
+	  break;
+
+	case 'g':
+	  if (strcmp ("guided", p) != 0)
+	    goto invalid_kind;
+	  OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_GUIDED;
+	  break;
+
+	case 'r':
+	  if (strcmp ("runtime", p) != 0)
+	    goto invalid_kind;
+	  OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_RUNTIME;
+	  break;
+
+	default:
+	  goto invalid_kind;
+	}
+    }
+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_STATIC))
+    OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_STATIC;
+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AUTO))
+    OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_AUTO;
+  else
+    goto invalid_kind;
+  cp_lexer_consume_token (parser->lexer);
+
+  if ((modifiers & (OMP_CLAUSE_SCHEDULE_MONOTONIC
+		    | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))
+      == (OMP_CLAUSE_SCHEDULE_MONOTONIC
+	  | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))
+    {
+      error_at (location, "both %<monotonic%> and %<nonmonotonic%> modifiers "
+			  "specified");
+      modifiers = 0;
+    }
+
+  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))
+    {
+      cp_token *token;
+      cp_lexer_consume_token (parser->lexer);
+
+      token = cp_lexer_peek_token (parser->lexer);
+      t = cp_parser_assignment_expression (parser);
+
+      if (t == error_mark_node)
+	goto resync_fail;
+      else if (OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)
+	error_at (token->location, "steal schedule %<runtime%> does not take "
+		  "a %<chunk_size%> parameter");
+      else if (OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_AUTO)
+	error_at (token->location, "steal schedule %<auto%> does not take "
+		  "a %<chunk_size%> parameter");
+      else
+	OMP_CLAUSE_STEAL_SCHEDULE_CHUNK_EXPR (c) = t;
+
+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))
+	goto resync_fail;
+    }
+  else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_COMMA_CLOSE_PAREN))
+    goto resync_fail;
+
+  OMP_CLAUSE_STEAL_SCHEDULE_KIND (c)
+    = (enum omp_clause_schedule_kind)
+      (OMP_CLAUSE_STEAL_SCHEDULE_KIND (c) | modifiers);
+
+  check_no_duplicate_clause (list, OMP_CLAUSE_STEAL_SCHEDULE, "steal_schedule", location);
+  OMP_CLAUSE_CHAIN (c) = list;
+  return c;
+
+ invalid_kind:
+  cp_parser_error (parser, "invalid steal schedule kind");
+ resync_fail:
+  cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
+					 /*or_comma=*/false,
+					 /*consume_paren=*/true);
+  return list;
+}
+
+static tree
+cp_parser_ws_all_clauses (cp_parser *parser, omp_clause_mask mask,
+			   const char *where, cp_token *pragma_tok,
+			   bool finish_p = true)
+{
+  tree clauses = NULL;
+  bool first = true;
+  cp_token *token = NULL;
+
+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))
+    {
+      pragma_omp_clause c_kind;
+      const char *c_name;
+      tree prev = clauses;
+
+      if (!first && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))
+	cp_lexer_consume_token (parser->lexer);
+
+      token = cp_lexer_peek_token (parser->lexer);
+      c_kind = cp_parser_omp_clause_name (parser);
+
+      switch (c_kind)
+	{
+	case PRAGMA_WS_CLAUSE_COLLAPSE:
+	  clauses = cp_parser_omp_clause_collapse (parser, clauses,token->location);
+	  c_name = "collapse";
+	  break;
+	case PRAGMA_WS_CLAUSE_COPYIN:
+	  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_COPYIN, clauses);
+	  c_name = "copyin";
+	  break;
+	case PRAGMA_WS_CLAUSE_DEFAULT:
+	  clauses = cp_parser_omp_clause_default (parser, clauses,
+						  token->location, false);
+	  c_name = "default";
+	  break;
+	case PRAGMA_WS_CLAUSE_FIRSTPRIVATE:
+	  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FIRSTPRIVATE,
+					    clauses);
+	  c_name = "firstprivate";
+	  break;
+	case PRAGMA_WS_CLAUSE_LASTPRIVATE:
+	  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_LASTPRIVATE,
+					    clauses);
+	  c_name = "lastprivate";
+	  break;
+	case PRAGMA_WS_CLAUSE_NOWAIT:
+	  clauses = cp_parser_omp_clause_nowait (parser, clauses, token->location);
+	  c_name = "nowait";
+	  break;
+	case PRAGMA_WS_CLAUSE_NUM_TASKS:
+	  clauses = cp_parser_omp_clause_num_tasks (parser, clauses,
+						    token->location);
+	  c_name = "num_tasks";
+	  break;
+	case PRAGMA_WS_CLAUSE_PRIVATE:
+	  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_PRIVATE,
+					    clauses);
+	  c_name = "private";
+	  break;
+	case PRAGMA_WS_CLAUSE_REDUCTION:
+	  clauses = cp_parser_omp_clause_reduction (parser, clauses);
+	  c_name = "reduction";
+	  break;
+	case PRAGMA_WS_CLAUSE_SCHEDULE:
+	  clauses = cp_parser_omp_clause_schedule (parser, clauses,
+						   token->location);
+	  c_name = "schedule";
+	  break;
+	case PRAGMA_WS_CLAUSE_STEAL_SCHEDULE:
+	  clauses = cp_parser_ws_clause_steal_schedule (parser, clauses,token->location);
+	  c_name = "steal_schedule";
+	  break;
+	case PRAGMA_WS_CLAUSE_SHARED:
+	  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_SHARED,
+					    clauses);
+	  c_name = "shared";
+	  break;
+	default:
+	  cp_parser_error (parser, "expected %<#pragma ws%> clause");
+	  goto saw_error;
+	}
+
+      first = false;
+
+      if (((mask >> c_kind) & 1) == 0)
+	{
+	  /* Remove the invalid clause(s) from the list to avoid
+	     confusing the rest of the compiler.  */
+	  clauses = prev;
+	  error_at (token->location, "%qs is not valid for %qs", c_name, where);
+	}
+    }
+
+ saw_error:
+    cp_parser_skip_to_pragma_eol (parser, pragma_tok);
+
+  if (finish_p)
+    {
+    	return finish_omp_clauses (clauses, C_ORT_OMP);
+    }
+
+  return clauses;
+}
+
 /* Main entry point to OpenMP statement pragmas.  */
 
+#define WS_FOR_CLAUSE_MASK				\
+	( (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_SHARED)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_PRIVATE)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_FIRSTPRIVATE)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_LASTPRIVATE)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_DEFAULT)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_NUM_TASKS)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_COLLAPSE)	\
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_REDUCTION) \
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_SCHEDULE) \
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_STEAL_SCHEDULE) \
+	| (OMP_CLAUSE_MASK_1 << PRAGMA_WS_CLAUSE_NOWAIT))
+
+static tree cp_parser_ws_for(cp_parser *parser, cp_token *pragma_tok,
+			char *p_name, omp_clause_mask mask, tree *cclauses,
+			bool *if_p)                                                                            
+{                                                                                             
+  tree clauses, sb, ret;
+  unsigned int save;
+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;
+
+  strcat (p_name, " for");
+  mask |= WS_FOR_CLAUSE_MASK;
+
+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))
+    {
+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;
+      const char *p = IDENTIFIER_POINTER (id);
+
+      if (strcmp (p, "simd") == 0)
+	{
+	  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];
+	  if (cclauses == NULL)
+	    cclauses = cclauses_buf;
+	  mask &= ~(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_REDUCTION);
+	  cp_lexer_consume_token (parser->lexer);
+    sb = begin_omp_structured_block ();
+	  save = cp_parser_begin_omp_structured_block (parser);
+	  ret = cp_parser_omp_simd (parser, pragma_tok, p_name, mask,
+				    cclauses, if_p);
+	  cp_parser_end_omp_structured_block (parser, save);
+	  tree body = finish_omp_structured_block (sb);
+	  if (ret == NULL)
+	    return ret;
+	  ret = make_node (WS_FOR);
+	  TREE_TYPE (ret) = void_type_node;
+	  OMP_FOR_BODY (ret) = body;
+    OMP_FOR_CLAUSES (ret) = cclauses[C_OMP_CLAUSE_SPLIT_WS_FOR];
+    SET_EXPR_LOCATION (ret, loc);
+	  add_stmt (ret);
+	  return ret;
+	}
+    }
+  clauses = cp_parser_ws_all_clauses (parser, mask, p_name, pragma_tok,
+				       cclauses == NULL);
+  if (cclauses)
+    {
+      cp_omp_split_clauses (loc, WS_FOR, mask, clauses, cclauses);
+      clauses = cclauses[C_OMP_CLAUSE_SPLIT_WS_FOR];
+    }
+
+  sb = begin_omp_structured_block ();
+  save = cp_parser_begin_omp_structured_block (parser);
+
+  ret = cp_parser_omp_for_loop (parser, WS_FOR, clauses, cclauses,
+				if_p);
+
+  cp_parser_end_omp_structured_block (parser, save);
+  add_stmt (finish_omp_structured_block (sb));
+
+  return ret;
+                                                                              
+}     
+
+static tree
+cp_parser_ws_critical (cp_parser *parser, cp_token *pragma_tok, bool *if_p)
+{
+  tree stmt, name = NULL_TREE, clauses = NULL_TREE;
+
+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))
+    {
+      cp_lexer_consume_token (parser->lexer);
+
+      name = cp_parser_identifier (parser);
+
+      if (name == error_mark_node
+	  || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))
+	cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,
+					       /*or_comma=*/false,
+					       /*consume_paren=*/true);
+      if (name == error_mark_node)
+	name = NULL;
+
+      clauses = cp_parser_omp_all_clauses (parser,
+					   OMP_CRITICAL_CLAUSE_MASK,
+					   "#pragma omp critical", pragma_tok);
+    }
+  else
+    cp_parser_require_pragma_eol (parser, pragma_tok);
+
+  stmt = cp_parser_omp_structured_block (parser, if_p);
+  return c_finish_ws_critical (input_location, stmt, name, clauses);
+}
+
+static void
+cp_parser_ws_stopsteal (cp_parser *parser, cp_token* pragma_tok)
+{
+  cp_parser_require_pragma_eol (parser, pragma_tok);
+  c_finish_ws_stopsteal(input_location);
+}
+
+static void
+cp_parser_ws_resteal (cp_parser *parser, cp_token* pragma_tok)
+{
+  cp_parser_require_pragma_eol (parser, pragma_tok);
+  c_finish_ws_resteal(input_location);
+}
+
 static void
 cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok, bool *if_p)
 {
@@ -37664,6 +38012,29 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok, bool *if_p)
       stmt = cp_parser_oacc_kernels_parallel (parser, pragma_tok, p_name,
 					      if_p);
       break;
+    case PRAGMA_WS_FOR:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;33mFound WS FOR pragma !\n\033[0;0m");
+      }
+      strcpy (p_name, "#pragma ws");
+      stmt = cp_parser_ws_for (parser, pragma_tok, p_name, mask, NULL, if_p);
+      break;
+    case PRAGMA_WS_ATOMIC:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;32mFound WS ATOMIC pragma !\n\033[0;0m");
+      }
+      cp_parser_omp_atomic (parser, pragma_tok);
+      stmt = NULL_TREE;
+      break;
+    case PRAGMA_WS_CRITICAL:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;33mFound WS CRITICAL pragma !\n\033[0;0m");
+      }
+      stmt = cp_parser_ws_critical (parser, pragma_tok, if_p);
+      break;
     case PRAGMA_OACC_LOOP:
       strcpy (p_name, "#pragma acc");
       stmt = cp_parser_oacc_loop (parser, pragma_tok, p_name, mask, NULL,
@@ -38125,6 +38496,23 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)
     cp_ensure_no_omp_declare_simd (parser);
   switch (id)
     {
+    case PRAGMA_WS_STOPSTEAL:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;33mFound WS STOPSTEAL pragma !\n\033[0;0m");
+      }
+      //cp_parser_omp_barrier(parser,pragma_tok);
+      cp_parser_ws_stopsteal(parser,pragma_tok);
+      return false;
+      break;
+    case PRAGMA_WS_RESTEAL:
+      if(flag_mpc_ws == 2)
+      {
+         fprintf(stderr,"\033[1;33mFound WS RESTEAL pragma !\n\033[0;0m");
+      }
+      cp_parser_ws_resteal(parser,pragma_tok);
+      return false;
+      break;
     case PRAGMA_GCC_PCH_PREPROCESS:
       error_at (pragma_tok->location,
 		"%<#pragma GCC pch_preprocess%> must be first");
@@ -38305,6 +38693,9 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)
     case PRAGMA_OMP_TASKGROUP:
     case PRAGMA_OMP_TASKLOOP:
     case PRAGMA_OMP_TEAMS:
+    case PRAGMA_WS_FOR:
+    case PRAGMA_WS_ATOMIC:
+    case PRAGMA_WS_CRITICAL:
       if (context != pragma_stmt && context != pragma_compound)
 	goto bad_stmt;
       stmt = push_omp_privatization_clauses (false);
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 5687bb212..68bbc32fe 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -15261,6 +15261,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,
 	case OMP_CLAUSE_IF:
 	case OMP_CLAUSE_NUM_THREADS:
 	case OMP_CLAUSE_SCHEDULE:
+	case OMP_CLAUSE_STEAL_SCHEDULE:
 	case OMP_CLAUSE_COLLAPSE:
 	case OMP_CLAUSE_FINAL:
 	case OMP_CLAUSE_DEVICE:
@@ -16265,6 +16266,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,
     case OMP_DISTRIBUTE:
     case OMP_TASKLOOP:
     case OACC_LOOP:
+    case WS_FOR:
       {
 	tree clauses, body, pre_body;
 	tree declv = NULL_TREE, initv = NULL_TREE, condv = NULL_TREE;
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index e06637646..825f6abe6 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -6417,6 +6426,37 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)
 	    }
 	  break;
 
+ case OMP_CLAUSE_STEAL_SCHEDULE:
+   t = OMP_CLAUSE_STEAL_SCHEDULE_CHUNK_EXPR (c);
+   if (t == NULL)
+     ;
+   else if (t == error_mark_node)
+     remove = true;
+   else if (!type_dependent_expression_p (t)
+      && !INTEGRAL_TYPE_P (TREE_TYPE (t)))
+     {
+       error ("schedule chunk size expression must be integral");
+       remove = true;
+     }
+   else
+     {
+       t = mark_rvalue_use (t);
+       if (!processing_template_decl)
+   {
+         t = maybe_constant_value (t);
+         if (TREE_CODE (t) == INTEGER_CST
+       && tree_int_cst_sgn (t) != 1)
+     {
+       warning_at (OMP_CLAUSE_LOCATION (c), 0,
+             "chunk size value must be positive");
+       t = integer_one_node;
+     }
+     t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);
+   }
+       OMP_CLAUSE_STEAL_SCHEDULE_CHUNK_EXPR (c) = t;
+     }
+   break;
+
 	case OMP_CLAUSE_SIMDLEN:
 	case OMP_CLAUSE_SAFELEN:
 	  t = OMP_CLAUSE_OPERAND (c, 0);
diff --git a/gcc/gimple-low.c b/gcc/gimple-low.c
index 619b9d7bf..2c3ffb0e6 100644
--- a/gcc/gimple-low.c
+++ b/gcc/gimple-low.c
@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "calls.h"
 #include "gimple-iterator.h"
 #include "gimple-low.h"
+#include "gimple-pretty-print.h"
 
 /* The differences between High GIMPLE and Low GIMPLE are the
    following:
diff --git a/gcc/gimple-pretty-print.c b/gcc/gimple-pretty-print.c
index 49cc80c57..c224579cf 100644
--- a/gcc/gimple-pretty-print.c
+++ b/gcc/gimple-pretty-print.c
@@ -1354,6 +1354,9 @@ dump_gimple_omp_for (pretty_printer *buffer, gomp_for *gs, int spc, int flags)
 	case GF_OMP_FOR_KIND_CILKSIMD:
 	  kind = " cilksimd";
 	  break;
+	case GF_OMP_FOR_KIND_WS_FOR:
+	  kind = " ws_for";
+	  break;
 	default:
 	  gcc_unreachable ();
 	}
@@ -1399,6 +1402,10 @@ dump_gimple_omp_for (pretty_printer *buffer, gomp_for *gs, int spc, int flags)
 	case GF_OMP_FOR_KIND_GRID_LOOP:
 	  pp_string (buffer, "#pragma omp for grid_loop");
 	  break;
+	case GF_OMP_FOR_KIND_WS_FOR:
+	  pp_string (buffer, "#pragma ws for");
+	  break;
+
 	default:
 	  gcc_unreachable ();
 	}
diff --git a/gcc/gimple.h b/gcc/gimple.h
index 460011c87..20342f394 100644
--- a/gcc/gimple.h
+++ b/gcc/gimple.h
@@ -150,6 +150,7 @@ enum gf_mask {
     GF_OMP_PARALLEL_COMBINED	= 1 << 0,
     GF_OMP_PARALLEL_GRID_PHONY = 1 << 1,
     GF_OMP_TASK_TASKLOOP	= 1 << 0,
+    GF_OMP_TASK_WS_FOR	= 1 << 1,
     GF_OMP_FOR_KIND_MASK	= (1 << 4) - 1,
     GF_OMP_FOR_KIND_FOR		= 0,
     GF_OMP_FOR_KIND_DISTRIBUTE	= 1,
@@ -157,6 +158,7 @@ enum gf_mask {
     GF_OMP_FOR_KIND_CILKFOR     = 3,
     GF_OMP_FOR_KIND_OACC_LOOP	= 4,
     GF_OMP_FOR_KIND_GRID_LOOP = 5,
+    GF_OMP_FOR_KIND_WS_FOR = 6,
     /* Flag for SIMD variants of OMP_FOR kinds.  */
     GF_OMP_FOR_SIMD		= 1 << 3,
     GF_OMP_FOR_KIND_SIMD	= GF_OMP_FOR_SIMD | 0,
@@ -185,6 +187,10 @@ enum gf_mask {
     GF_OMP_TARGET_KIND_OACC_HOST_DATA = 11,
     GF_OMP_TEAMS_GRID_PHONY	= 1 << 0,
 
+    
+    GF_OMP_WS_CRITICAL = 1 << 0,
+
+
     /* True on an GIMPLE_OMP_RETURN statement if the return does not require
        a thread synchronization via some sort of barrier.  The exact barrier
        that would otherwise be emitted is dependent on the OMP statement with
@@ -4818,6 +4824,19 @@ gimple_omp_critical_set_clauses (gomp_critical *crit_stmt, tree clauses)
   crit_stmt->clauses = clauses;
 }
 
+static inline void
+gimple_omp_critical_set_ws_p (gimple* g)
+{
+  GIMPLE_CHECK (g, GIMPLE_OMP_CRITICAL);
+  g->subcode |= GF_OMP_WS_CRITICAL;
+}
+
+static inline bool 
+gimple_omp_critical_ws_p (const gimple* g)
+{
+  GIMPLE_CHECK (g, GIMPLE_OMP_CRITICAL);
+  return (gimple_omp_subcode (g) & GF_OMP_WS_CRITICAL) != 0;
+}
 
 /* Return the clauses associated with OMP_ORDERED statement ORD_STMT.  */
 
@@ -5373,6 +5392,22 @@ gimple_omp_task_set_taskloop_p (gimple *g, bool taskloop_p)
     g->subcode &= ~GF_OMP_TASK_TASKLOOP;
 }
 
+static inline bool
+gimple_omp_task_ws_for_p (const gimple *g)
+{
+  GIMPLE_CHECK (g, GIMPLE_OMP_TASK);
+  return (gimple_omp_subcode (g) & GF_OMP_TASK_WS_FOR) != 0;
+}
+
+static inline void
+gimple_omp_task_set_ws_for_p (gimple *g, bool ws_for_p)
+{
+  GIMPLE_CHECK (g, GIMPLE_OMP_TASK);
+  if (ws_for_p)
+    g->subcode |= GF_OMP_TASK_WS_FOR;
+  else
+    g->subcode &= ~GF_OMP_TASK_WS_FOR;
+}
 
 /* Return the child function used to hold the body of OMP_TASK GS.  */
 
diff --git a/gcc/fortran/f95-lang.c b/gcc/fortran/f95-lang.c
index 44bd8dcc2..7cb0f3dbe 100644
--- a/gcc/fortran/f95-lang.c
+++ b/gcc/fortran/f95-lang.c
@@ -1193,8 +1193,30 @@ gfc_init_builtin_functions (void)
 #include "../sync-builtins.def"
 #undef DEF_SYNC_BUILTIN
 
+  if (flag_mpc_ws)
+  {
+#undef DEF_MPC_WS_BUILTIN
+#define DEF_MPC_WS_BUILTIN(code, name, type, attr) \
+   gfc_define_builtin ("__builtin_" name, builtin_types[type], \
+       code, name, attr);
+#undef DEF_GOMP_BUILTIN
+#define DEF_GOMP_BUILTIN(code, name, type, attr) /* ignore */
+#undef DEF_GOACC_BUILTIN
+#define DEF_GOACC_BUILTIN(code, name, type, attr) /* ignore */
+#undef DEF_GOACC_BUILTIN_COMPILER
+#define DEF_GOACC_BUILTIN_COMPILER(code, name, type, attr)  /* ignore */
+
+#include "../omp-builtins.def"
+#undef DEF_GOACC_BUILTIN
+#undef DEF_GOACC_BUILTIN_COMPILER
+#undef DEF_GOMP_BUILTIN
+#undef DEF_MPC_WS_BUILTIN
+  }
+
   if (flag_openacc)
     {
+#undef DEF_MPC_WS_BUILTIN
+#define DEF_MPC_WS_BUILTIN(code, name, type, attr) /* ignore */
 #undef DEF_GOACC_BUILTIN
 #define DEF_GOACC_BUILTIN(code, name, type, attr) \
       gfc_define_builtin ("__builtin_" name, builtin_types[type], \
@@ -1241,6 +1265,7 @@ gfc_init_builtin_functions (void)
 #undef DEF_GOMP_BUILTIN
 #define DEF_GOMP_BUILTIN(code, name, type, attr) /* ignore */
 #include "../omp-builtins.def"
+#undef DEF_MPC_WS_BUILTIN
 #undef DEF_GOACC_BUILTIN
 #undef DEF_GOACC_BUILTIN_COMPILER
 #undef DEF_GOMP_BUILTIN
@@ -1244,6 +1265,8 @@ gfc_init_builtin_functions (void)
 #define DEF_GOACC_BUILTIN(code, name, type, attr) /* ignore */
 #undef DEF_GOACC_BUILTIN_COMPILER
 #define DEF_GOACC_BUILTIN_COMPILER(code, name, type, attr)  /* ignore */
+#undef DEF_MPC_WS_BUILTIN
+#define DEF_MPC_WS_BUILTIN(code, name, type, attr) /* ignore */
 #undef DEF_GOMP_BUILTIN
 #define DEF_GOMP_BUILTIN(code, name, type, attr) \
       gfc_define_builtin ("__builtin_" name, builtin_types[type], \
@@ -1249,6 +1269,7 @@ gfc_init_builtin_functions (void)
 #undef DEF_GOACC_BUILTIN
 #undef DEF_GOACC_BUILTIN_COMPILER
 #undef DEF_GOMP_BUILTIN
+#undef DEF_MPC_WS_BUILTIN
     }

 #ifdef ENABLE_HSA
diff --git a/gcc/fortran/types.def b/gcc/fortran/types.def
index 1f8a5a127..9445c30b9 100644
--- a/gcc/fortran/types.def
+++ b/gcc/fortran/types.def
@@ -252,3 +252,7 @@ DEF_FUNCTION_TYPE_VAR_7 (BT_FN_VOID_INT_SIZE_PTR_PTR_PTR_INT_INT_VAR,
 DEF_FUNCTION_TYPE_VAR_6 (BT_FN_VOID_INT_OMPFN_SIZE_PTR_PTR_PTR_VAR,
 			  BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_SIZE,
 			  BT_PTR, BT_PTR, BT_PTR)
+
+DEF_FUNCTION_TYPE_9 (BT_FN_VOID_OMPFN_PTR_LONG_LONG_LONG_INT_INT_INT_INT,
+		     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,
+		     BT_LONG, BT_LONG, BT_LONG, BT_INT, BT_INT, BT_INT, BT_INT)
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index 5264a4f3d..e3a28e52e 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -62,7 +62,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "builtins.h"
 #include "asan.h"
 #include "dbgcnt.h"
-
+#include "gimple-pretty-print.h"
 /* Hash set of poisoned variables in a bind expr.  */
 static hash_set<tree> *asan_poisoned_variables = NULL;
 
@@ -115,6 +115,7 @@ enum omp_region_type
 
   ORT_TASK	= 0x04,
   ORT_UNTIED_TASK = 0x05,
+  ORT_WS_FOR = 0x06,
 
   ORT_TEAMS	= 0x08,
   ORT_COMBINED_TEAMS = 0x09,
@@ -403,7 +404,7 @@ new_omp_context (enum omp_region_type region_type)
   c->privatized_types = new hash_set<tree>;
   c->location = input_location;
   c->region_type = region_type;
-  if ((region_type & ORT_TASK) == 0)
+  if ((region_type & ORT_TASK) == 0 || region_type == ORT_WS_FOR)
     c->default_kind = OMP_CLAUSE_DEFAULT_SHARED;
   else
     c->default_kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;
@@ -5315,6 +5316,8 @@ is_gimple_stmt (tree t)
     case OMP_TARGET_EXIT_DATA:
     case OMP_TASKLOOP:
     case OMP_TEAMS:
+    case WS_FOR:
+    case WS_CRITICAL:
       /* These are always void.  */
       return true;
 
@@ -6711,8 +6714,15 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)
   if (n != NULL)
     n->value |= flags;
   else
+  {
+  if(flag_mpc_ws == 2)
+  {
+    fprintf(stderr,"Inserting variable "); 
+    print_generic_expr (stderr, decl, TDF_SLIM);
+    fprintf(stderr," with flags %d\n",flags);
+  }
     splay_tree_insert (ctx->variables, (splay_tree_key)decl, flags);
-
+  }
   /* For reductions clauses in OpenACC loop directives, by default create a
      copy clause on the enclosing parallel construct for carrying back the
      results.  */
@@ -6899,13 +6909,24 @@ omp_default_clause (struct gimplify_omp_ctx *ctx, tree decl,
 		}
 	    }
 	}
-      
-      if (TREE_CODE (decl) == PARM_DECL
-	  || (!is_global_var (decl)
-	      && DECL_CONTEXT (decl) == current_function_decl))
-	flags |= GOVD_FIRSTPRIVATE;
+
+      if (TREE_CODE (decl) == PARM_DECL || ( DECL_CONTEXT (decl) == current_function_decl))
+      {
+        if(flag_mpc_ws == 2)
+        {
+          fprintf(stderr,"var ");print_generic_expr (stderr, decl, TDF_SLIM);fprintf(stderr," changing clause to firstprivate\n");
+        }
+        flags |= GOVD_FIRSTPRIVATE;
+      }
       else
-	flags |= GOVD_SHARED;
+      {
+        flags |= GOVD_SHARED;
+        if(flag_mpc_ws == 2)
+        {
+          fprintf(stderr,"var ");print_generic_expr (stderr, decl, TDF_SLIM);fprintf(stderr," changing clause to shared\n");
+        }
+      }
+
     found_outer:
       break;
 
@@ -8349,6 +8370,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,
 	  /* Fall through.  */
 
 	case OMP_CLAUSE_SCHEDULE:
+	case OMP_CLAUSE_STEAL_SCHEDULE:
 	case OMP_CLAUSE_NUM_THREADS:
 	case OMP_CLAUSE_NUM_TEAMS:
 	case OMP_CLAUSE_THREAD_LIMIT:
@@ -8609,9 +8631,10 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)
     }
   else if (flags & GOVD_SHARED)
     {
-      if (is_global_var (decl))
+      if (is_global_var (decl) && (gimplify_omp_ctxp->region_type != ORT_WS_FOR || DECL_IN_SYSTEM_HEADER(decl)))
 	{
 	  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp->outer_context;
+
 	  while (ctx != NULL)
 	    {
 	      splay_tree_node on
@@ -8820,7 +8843,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,
 	case OMP_CLAUSE_LINEAR:
 	  decl = OMP_CLAUSE_DECL (c);
 	  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);
-	  remove = !(n->value & GOVD_SEEN);
+	  remove = !(n->value & GOVD_SEEN) && !(is_global_var(decl) && gimplify_omp_ctxp->region_type == ORT_WS_FOR);
 	  if (! remove)
 	    {
 	      bool shared = OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED;
@@ -9121,6 +9144,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,
 	case OMP_CLAUSE_DIST_SCHEDULE:
 	case OMP_CLAUSE_DEVICE:
 	case OMP_CLAUSE_SCHEDULE:
+	case OMP_CLAUSE_STEAL_SCHEDULE:
 	case OMP_CLAUSE_NOWAIT:
 	case OMP_CLAUSE_ORDERED:
 	case OMP_CLAUSE_DEFAULT:
@@ -9449,6 +9473,9 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
       else
 	ort = ORT_TASK;
       break;
+    case WS_FOR:
+      ort = ORT_WS_FOR;
+      break;
     case OMP_SIMD:
     case CILK_SIMD:
       ort = ORT_SIMD;
@@ -9486,7 +9513,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
 	}
     }
 
-  if (TREE_CODE (for_stmt) != OMP_TASKLOOP)
+  if (TREE_CODE (for_stmt) != OMP_TASKLOOP && TREE_CODE (for_stmt) != WS_FOR)
     gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p, ort,
 			       TREE_CODE (for_stmt));
 
@@ -9520,7 +9547,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
     }
   if (OMP_FOR_PRE_BODY (for_stmt))
     {
-      if (TREE_CODE (for_stmt) != OMP_TASKLOOP || gimplify_omp_ctxp)
+      if ((TREE_CODE (for_stmt) != OMP_TASKLOOP && TREE_CODE (for_stmt) != WS_FOR) || gimplify_omp_ctxp)
 	gimplify_and_add (OMP_FOR_PRE_BODY (for_stmt), &for_pre_body);
       else
 	{
@@ -9539,7 +9566,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
 
   /* For taskloop, need to gimplify the start, end and step before the
      taskloop, outside of the taskloop omp context.  */
-  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)
+  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP || TREE_CODE (orig_for_stmt) == WS_FOR)
     {
       for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)
 	{
@@ -9596,8 +9623,14 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
 	    }
 	}
 
+    if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)
       gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (orig_for_stmt), pre_p, ort,
 				 OMP_TASKLOOP);
+    else
+      gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (orig_for_stmt), pre_p, ort,
+				 WS_FOR);
+
+
     }
 
   if (orig_for_stmt != for_stmt)
@@ -10076,7 +10109,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
 
   BITMAP_FREE (has_decl_expr);
 
-  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)
+  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP || TREE_CODE (orig_for_stmt) == WS_FOR)
     {
       push_gimplify_context ();
       if (TREE_CODE (OMP_FOR_BODY (orig_for_stmt)) != BIND_EXPR)
@@ -10090,8 +10123,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
 
   gimple *g = gimplify_and_return_first (OMP_FOR_BODY (orig_for_stmt),
 					 &for_body);
-
-  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)
+  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP || TREE_CODE (orig_for_stmt) == WS_FOR)
     {
       if (gimple_code (g) == GIMPLE_BIND)
 	pop_gimplify_context (g);
@@ -10105,7 +10137,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
 	t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);
 	decl = TREE_OPERAND (t, 0);
 	struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;
-	if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)
+  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP || TREE_CODE (orig_for_stmt) == WS_FOR)
 	  gimplify_omp_ctxp = ctx->outer_context;
 	var = create_tmp_var (TREE_TYPE (decl), get_name (decl));
 	gimplify_omp_ctxp = ctx;
@@ -10130,6 +10162,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
     case OMP_DISTRIBUTE: kind = GF_OMP_FOR_KIND_DISTRIBUTE; break;
     case OMP_TASKLOOP: kind = GF_OMP_FOR_KIND_TASKLOOP; break;
     case OACC_LOOP: kind = GF_OMP_FOR_KIND_OACC_LOOP; break;
+    case WS_FOR: kind = GF_OMP_FOR_KIND_WS_FOR; break;                
     default:
       gcc_unreachable ();
     }
@@ -10170,7 +10203,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
      The task construct stands for the effect of data sharing on the
      explicit task it creates and the inner taskloop stands for expansion
      of the static loop inside of the explicit task construct.  */
-  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)
+  if (TREE_CODE (orig_for_stmt) == OMP_TASKLOOP || TREE_CODE (orig_for_stmt) == WS_FOR)
     {
       tree *gfor_clauses_ptr = gimple_omp_for_clauses_ptr (gfor);
       tree task_clauses = NULL_TREE;
@@ -10179,7 +10212,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
       tree outer_for_clauses = NULL_TREE;
       tree *gforo_clauses_ptr = &outer_for_clauses;
       for (; c; c = OMP_CLAUSE_CHAIN (c))
-	switch (OMP_CLAUSE_CODE (c))
+      if(TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)
+	      switch (OMP_CLAUSE_CODE (c))
 	  {
 	  /* These clauses are allowed on task, move them there.  */
 	  case OMP_CLAUSE_SHARED:
@@ -10261,21 +10295,157 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
 	    gtask_clauses_ptr
 	      = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);
 	    break;
+    default:
+      gcc_unreachable();
+    }
+      else /* WS FOR */
+      {
+	switch (OMP_CLAUSE_CODE (c))
+	  {
+	  /* These clauses are allowed on task, move them there.  */
+	  case OMP_CLAUSE_SHARED:
+	  case OMP_CLAUSE_DEFAULT:
+    case OMP_CLAUSE_SCHEDULE:
+    case OMP_CLAUSE_STEAL_SCHEDULE:
+    case OMP_CLAUSE_NOWAIT:
+
+	    *gtask_clauses_ptr = c;
+	    gtask_clauses_ptr = &OMP_CLAUSE_CHAIN (c);
+	    break;
+	  case OMP_CLAUSE_PRIVATE:
+	    if (OMP_CLAUSE_PRIVATE_TASKLOOP_IV (c))
+	      {
+		/* We want private on outer for and firstprivate
+		   on task.  */
+		*gtask_clauses_ptr
+		  = build_omp_clause (OMP_CLAUSE_LOCATION (c),
+				      OMP_CLAUSE_FIRSTPRIVATE);
+		OMP_CLAUSE_DECL (*gtask_clauses_ptr) = OMP_CLAUSE_DECL (c);
+		lang_hooks.decls.omp_finish_clause (*gtask_clauses_ptr, NULL);
+		gtask_clauses_ptr = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);
+		*gforo_clauses_ptr = c;
+		gforo_clauses_ptr = &OMP_CLAUSE_CHAIN (c);
+	      }
+	    else
+	      {
+		*gtask_clauses_ptr = c;
+		gtask_clauses_ptr = &OMP_CLAUSE_CHAIN (c);
+	      }
+	    break;
+	  /* These clauses go into outer taskloop clauses.  */
+	  case OMP_CLAUSE_NUM_TASKS:
+	    *gforo_clauses_ptr = c;
+	    gforo_clauses_ptr = &OMP_CLAUSE_CHAIN (c);
+	    break;
+	  /* Taskloop clause we duplicate on both taskloops.  */
+	  case OMP_CLAUSE_COLLAPSE:
+	    *gfor_clauses_ptr = c;
+	    gfor_clauses_ptr = &OMP_CLAUSE_CHAIN (c);
+	    *gforo_clauses_ptr = copy_node (c);
+	    gforo_clauses_ptr = &OMP_CLAUSE_CHAIN (*gforo_clauses_ptr);
+	    break;
+	  /* For lastprivate, keep the clause on inner taskloop, and add
+	     a shared clause on task.  If the same decl is also firstprivate,
+	     add also firstprivate clause on the inner taskloop.  */
+	  case OMP_CLAUSE_LASTPRIVATE:
+	    if (OMP_CLAUSE_LASTPRIVATE_TASKLOOP_IV (c))
+	      {
+		/* For taskloop C++ lastprivate IVs, we want:
+		   1) private on outer taskloop
+		   2) firstprivate and shared on task
+		   3) lastprivate on inner taskloop  */
+		*gtask_clauses_ptr
+		  = build_omp_clause (OMP_CLAUSE_LOCATION (c),
+				      OMP_CLAUSE_FIRSTPRIVATE);
+		OMP_CLAUSE_DECL (*gtask_clauses_ptr) = OMP_CLAUSE_DECL (c);
+		lang_hooks.decls.omp_finish_clause (*gtask_clauses_ptr, NULL);
+		gtask_clauses_ptr = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);
+		OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c) = 1;
+		*gforo_clauses_ptr = build_omp_clause (OMP_CLAUSE_LOCATION (c),
+						       OMP_CLAUSE_PRIVATE);
+		OMP_CLAUSE_DECL (*gforo_clauses_ptr) = OMP_CLAUSE_DECL (c);
+		OMP_CLAUSE_PRIVATE_TASKLOOP_IV (*gforo_clauses_ptr) = 1;
+		TREE_TYPE (*gforo_clauses_ptr) = TREE_TYPE (c);
+		gforo_clauses_ptr = &OMP_CLAUSE_CHAIN (*gforo_clauses_ptr);
+	      }
+      decl = OMP_CLAUSE_DECL(c);
+      if(!omp_is_reference(decl) && !OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))
+      {
+        *gtask_clauses_ptr = c;
+        gtask_clauses_ptr = &OMP_CLAUSE_CHAIN (c);
+      }
+      else
+      {
+        *gfor_clauses_ptr = c;
+        gfor_clauses_ptr = &OMP_CLAUSE_CHAIN (c);
+      }
+	    *gtask_clauses_ptr
+	      = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_SHARED);
+	    OMP_CLAUSE_DECL (*gtask_clauses_ptr) = OMP_CLAUSE_DECL (c);
+	    if (OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c))
+	      OMP_CLAUSE_SHARED_FIRSTPRIVATE (*gtask_clauses_ptr) = 1;
+	    gtask_clauses_ptr
+	      = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);
+	    break;
+
+	  case OMP_CLAUSE_FIRSTPRIVATE:
+    case OMP_CLAUSE_REDUCTION:
+      decl = OMP_CLAUSE_DECL(c);
+      if(!omp_is_reference(decl) && !OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))
+      {
+        *gtask_clauses_ptr = c;
+        gtask_clauses_ptr = &OMP_CLAUSE_CHAIN (c);
+        if(flag_mpc_ws == 2)
+        {
+          fprintf(stderr,"Found reduction clause for var ");
+          print_generic_expr (stderr, decl, TDF_SLIM);fprintf(stderr,"\n");
+        }
+      }
+      else
+      {
+        if(flag_mpc_ws == 2)
+        {
+          fprintf(stderr,"Found reference or placeholder reduction clause for var ");
+          print_generic_expr (stderr, decl, TDF_SLIM);fprintf(stderr,"\n");
+        }
+        *gfor_clauses_ptr = c;
+        gfor_clauses_ptr = &OMP_CLAUSE_CHAIN (c);
+        *gtask_clauses_ptr
+          = build_omp_clause (OMP_CLAUSE_LOCATION (c),
+              OMP_CLAUSE_SHARED);
+        OMP_CLAUSE_DECL (*gtask_clauses_ptr) = OMP_CLAUSE_DECL (c);
+        gtask_clauses_ptr
+          = &OMP_CLAUSE_CHAIN (*gtask_clauses_ptr);
+      }
+      break;
 	  default:
 	    gcc_unreachable ();
 	  }
+      }
       *gfor_clauses_ptr = NULL_TREE;
       *gtask_clauses_ptr = NULL_TREE;
       *gforo_clauses_ptr = NULL_TREE;
       g = gimple_build_bind (NULL_TREE, gfor, NULL_TREE);
       g = gimple_build_omp_task (g, task_clauses, NULL_TREE, NULL_TREE,
 				 NULL_TREE, NULL_TREE, NULL_TREE);
-      gimple_omp_task_set_taskloop_p (g, true);
-      g = gimple_build_bind (NULL_TREE, g, NULL_TREE);
-      gomp_for *gforo
-	= gimple_build_omp_for (g, GF_OMP_FOR_KIND_TASKLOOP, outer_for_clauses,
+        gomp_for *gforo;
+      if(TREE_CODE (orig_for_stmt) == OMP_TASKLOOP)
+      {
+        gimple_omp_task_set_taskloop_p (g, true);
+        g = gimple_build_bind (NULL_TREE, g, NULL_TREE);
+	      gforo = gimple_build_omp_for (g, GF_OMP_FOR_KIND_TASKLOOP, outer_for_clauses,
+				gimple_omp_for_collapse (gfor),
+				gimple_omp_for_pre_body (gfor));
+      }
+      else /* MPC WS FOR */
+      {
+        gimple_omp_task_set_ws_for_p (g, true);
+        g = gimple_build_bind (NULL_TREE, g, NULL_TREE);
+	      gforo = gimple_build_omp_for (g, GF_OMP_FOR_KIND_WS_FOR, outer_for_clauses,
 				gimple_omp_for_collapse (gfor),
 				gimple_omp_for_pre_body (gfor));
+      }
+
       gimple_omp_for_set_pre_body (gfor, NULL);
       gimple_omp_for_set_combined_p (gforo, true);
       gimple_omp_for_set_combined_into_p (gfor, true);
@@ -10300,9 +10470,15 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)
 	  gimple_omp_for_set_clauses (gforo, t);
 	}
       gimplify_seq_add_stmt (pre_p, gforo);
+      if(flag_mpc_ws == 2)
+      {
+        fprintf(stderr,"In gimplify_omp_for gforo : \n");
+        print_gimple_stmt(stderr,gforo,1,TDF_SLIM);
+      }
     }
   else
     gimplify_seq_add_stmt (pre_p, gfor);
+
   if (ret != GS_ALL_DONE)
     return GS_ERROR;
   *expr_p = NULL_TREE;
@@ -11720,6 +11896,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,
 	case OMP_DISTRIBUTE:
 	case OMP_TASKLOOP:
 	case OACC_LOOP:
+  case WS_FOR:
 	  ret = gimplify_omp_for (expr_p, pre_p);
 	  break;
 
@@ -11761,6 +11938,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,
 	case OMP_TASKGROUP:
 	case OMP_ORDERED:
 	case OMP_CRITICAL:
+	case WS_CRITICAL:
 	  {
 	    gimple_seq body = NULL;
 	    gimple *g;
@@ -11791,6 +11969,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,
 		g = gimplify_omp_ordered (*expr_p, body);
 		break;
 	      case OMP_CRITICAL:
+	      case WS_CRITICAL:
 		gimplify_scan_omp_clauses (&OMP_CRITICAL_CLAUSES (*expr_p),
 					   pre_p, ORT_WORKSHARE, OMP_CRITICAL);
 		gimplify_adjust_omp_clauses (pre_p, body,
@@ -11799,6 +11978,11 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,
 		g = gimple_build_omp_critical (body,
 		    			       OMP_CRITICAL_NAME (*expr_p),
 		    			       OMP_CRITICAL_CLAUSES (*expr_p));
+    if(TREE_CODE (*expr_p) == WS_CRITICAL)
+    {
+      gimple_omp_critical_set_ws_p (g);
+    }
+
 		break;
 	      default:
 		gcc_unreachable ();
@@ -12153,6 +12337,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,
 		  && code != OACC_EXIT_DATA
 		  && code != OACC_CACHE
 		  && code != OMP_CRITICAL
+		  && code != WS_CRITICAL
 		  && code != OMP_FOR
 		  && code != OACC_LOOP
 		  && code != OMP_MASTER
@@ -12498,7 +12683,7 @@ gimplify_body (tree fndecl, bool do_parms)
       nonlocal_vlas = NULL;
     }
 
-  if ((flag_openacc || flag_openmp || flag_openmp_simd)
+  if ((flag_openacc || flag_openmp || flag_openmp_simd )
       && gimplify_omp_ctxp)
     {
       delete_omp_context (gimplify_omp_ctxp);
diff --git a/gcc/omp-builtins.def b/gcc/omp-builtins.def
index 69b73f4b8..958bd004f 100644
--- a/gcc/omp-builtins.def
+++ b/gcc/omp-builtins.def
@@ -360,3 +360,19 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TEAMS, "GOMP_teams",
 		  BT_FN_VOID_UINT_UINT, ATTR_NOTHROW_LIST)
 DEF_GOACC_BUILTIN (BUILT_IN_GOACC_DECLARE, "GOACC_declare",
 		   BT_FN_VOID_INT_SIZE_PTR_PTR_PTR, ATTR_NOTHROW_LIST)
+
+DEF_MPC_WS_BUILTIN (BUILT_IN_MPC_WS_ATOMIC_START, "mpc_lowcomm_workshare_atomic_start",
+		  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)
+DEF_MPC_WS_BUILTIN (BUILT_IN_MPC_WS_ATOMIC_END, "mpc_lowcomm_workshare_atomic_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)
+DEF_MPC_WS_BUILTIN (BUILT_IN_MPC_WS_CRITICAL_START, "mpc_lowcomm_workshare_critical_start",
+		  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)
+DEF_MPC_WS_BUILTIN (BUILT_IN_MPC_WS_CRITICAL_END, "mpc_lowcomm_workshare_critical_end",
+		  BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)
+DEF_MPC_WS_BUILTIN (BUILT_IN_MPC_WS_FOR, "mpc_lowcomm_workshare_start",
+		  BT_FN_VOID_OMPFN_PTR_LONG_LONG_LONG_INT_INT_INT_INT, ATTR_NOTHROW_LIST)
+DEF_MPC_WS_BUILTIN (BUILT_IN_MPC_WS_STOPSTEAL, "mpc_lowcomm_workshare_stop_stealing",
+      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)
+DEF_MPC_WS_BUILTIN (BUILT_IN_MPC_WS_RESTEAL, "mpc_lowcomm_workshare_resteal",
+      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)
+
diff --git a/gcc/omp-expand.c b/gcc/omp-expand.c
index a1e668d99..f1c265c38 100644
--- a/gcc/omp-expand.c
+++ b/gcc/omp-expand.c
@@ -731,6 +731,22 @@ expand_cilk_for_call (basic_block bb, gomp_parallel *entry_stmt,
 /* Build the function call to GOMP_task to actually
    generate the task operation.  BB is the block where to insert the code.  */
 
+static inline tree build_const_char_string(int len, const char *str)
+{ 
+  len++;
+  tree cstr, elem, index, type;
+  
+  cstr = build_string(len, str);
+  elem = build_type_variant(char_type_node, 1, 0);
+  index = build_index_type(size_int(len - 1));
+  type = build_array_type(elem, index);
+  TREE_TYPE(cstr) = type;
+  TREE_CONSTANT(cstr) = 1;
+  TREE_READONLY(cstr) = 1;
+  TREE_STATIC(cstr) = 1;
+  return cstr;
+} 
+
 static void
 expand_task_call (struct omp_region *region, basic_block bb,
 		  gomp_task *entry_stmt)
@@ -754,14 +770,16 @@ expand_task_call (struct omp_region *region, basic_block bb,
       | (depend ? GOMP_TASK_FLAG_DEPEND : 0);
 
   bool taskloop_p = gimple_omp_task_taskloop_p (entry_stmt);
+  bool ws_for_p = gimple_omp_task_ws_for_p (entry_stmt);
   tree startvar = NULL_TREE, endvar = NULL_TREE, step = NULL_TREE;
   tree num_tasks = NULL_TREE;
   bool ull = false;
-  if (taskloop_p)
+  if (taskloop_p || ws_for_p)
     {
       gimple *g = last_stmt (region->outer->entry);
       gcc_assert (gimple_code (g) == GIMPLE_OMP_FOR
-		  && gimple_omp_for_kind (g) == GF_OMP_FOR_KIND_TASKLOOP);
+		  && (gimple_omp_for_kind (g) == GF_OMP_FOR_KIND_TASKLOOP ||
+		  gimple_omp_for_kind (g) == GF_OMP_FOR_KIND_WS_FOR));
       struct omp_for_data fd;
       omp_extract_for_data (as_a <gomp_for *> (g), &fd, NULL);
       startvar = omp_find_clause (clauses, OMP_CLAUSE__LOOPTEMP_);
@@ -802,7 +820,7 @@ expand_task_call (struct omp_region *region, basic_block bb,
   tree cond = boolean_true_node;
   if (ifc)
     {
-      if (taskloop_p)
+      if (taskloop_p|| ws_for_p)
 	{
 	  tree t = gimple_boolify (OMP_CLAUSE_IF_EXPR (ifc));
 	  t = fold_build3_loc (loc, COND_EXPR, unsigned_type_node, t,
@@ -856,6 +874,93 @@ expand_task_call (struct omp_region *region, basic_block bb,
 			 gimple_omp_task_arg_size (entry_stmt),
 			 gimple_omp_task_arg_align (entry_stmt), flags,
 			 num_tasks, priority, startvar, endvar, step);
+  else if (ws_for_p)
+  {
+    tree chunk_size,chunk_expr = NULL_TREE; 
+    tree schedule = omp_find_clause (clauses, OMP_CLAUSE_SCHEDULE);
+    int schedule_kind;
+    if(schedule)
+    {
+      schedule_kind = OMP_CLAUSE_SCHEDULE_KIND(schedule);
+      if(schedule_kind == OMP_CLAUSE_SCHEDULE_GUIDED || schedule_kind == OMP_CLAUSE_SCHEDULE_DYNAMIC)
+      {
+        chunk_expr = OMP_CLAUSE_SCHEDULE_CHUNK_EXPR(schedule);
+
+      }
+    }
+    else
+    {
+      schedule_kind = OMP_CLAUSE_SCHEDULE_GUIDED;
+    }
+    if(chunk_expr != NULL_TREE)
+    {
+      chunk_size = chunk_expr;
+    }
+    else
+    {
+      chunk_size = build_int_cst (integer_type_node, 1);
+    }
+
+    tree steal_chunk_size,steal_chunk_expr = NULL_TREE; 
+    tree steal_schedule = omp_find_clause (clauses, OMP_CLAUSE_STEAL_SCHEDULE);
+    int steal_schedule_kind;
+    if(steal_schedule)
+    {
+      steal_schedule_kind = OMP_CLAUSE_STEAL_SCHEDULE_KIND(steal_schedule);
+      if(steal_schedule_kind == OMP_CLAUSE_SCHEDULE_GUIDED || steal_schedule_kind == OMP_CLAUSE_SCHEDULE_DYNAMIC)
+      {
+        steal_chunk_expr = OMP_CLAUSE_STEAL_SCHEDULE_CHUNK_EXPR(steal_schedule);
+      }
+    }
+    else
+    {
+      steal_schedule_kind = schedule_kind;
+    }
+    if(steal_chunk_expr != NULL_TREE)
+    {
+      steal_chunk_size = steal_chunk_expr;
+    }
+    else
+    {
+      steal_chunk_size = chunk_size;
+    }
+    tree scheduling_types = build_int_cst (integer_type_node, schedule_kind + (steal_schedule_kind << 3));
+    
+    tree nowait = omp_find_clause (clauses, OMP_CLAUSE_NOWAIT);
+    if(nowait)
+      nowait = build_int_cst (integer_type_node, 1);
+    else
+      nowait = build_int_cst (integer_type_node, 0);
+
+
+       if(flag_mpc_ws == 2) 
+       {
+         fprintf(stderr,"\033[1;36mCalling mpc_lowcomm_workshare_init with arguments below !\n\033[0;0m");
+         fprintf(stderr,"\nfunc : ");
+         print_generic_expr(stderr,t1,TDF_SLIM);fprintf(stderr,"\n");
+         fprintf(stderr,"\nshareds : ");
+         print_generic_expr(stderr,t2,TDF_SLIM);fprintf(stderr,"\n");
+         fprintf(stderr,"\nlb : ");
+         print_generic_expr(stderr,startvar,TDF_SLIM);fprintf(stderr,"\n");
+         fprintf(stderr,"\nub : ");
+         print_generic_expr(stderr,endvar,TDF_SLIM);fprintf(stderr,"\n");
+         fprintf(stderr,"\nincr : ");
+         print_generic_expr(stderr,step,TDF_SLIM);fprintf(stderr,"\n");
+         fprintf(stderr,"\nchunk_size : ");
+         print_generic_expr(stderr,chunk_size,TDF_SLIM);fprintf(stderr,"\n");
+         fprintf(stderr,"\nsteal chunk size : ");
+         print_generic_expr(stderr,steal_chunk_size,TDF_SLIM);fprintf(stderr,"\n");
+         fprintf(stderr,"\nscheduling types : ");
+         print_generic_expr(stderr,scheduling_types,TDF_SLIM);
+         fprintf(stderr," (schedule = %d steal schedule = %d)\n",schedule_kind,steal_schedule_kind);fprintf(stderr,"\n");
+         fprintf(stderr,"nowait : ");
+         print_generic_expr(stderr,nowait,TDF_SLIM);fprintf(stderr,"\n");
+       }
+
+   t = build_call_expr(builtin_decl_explicit(BUILT_IN_MPC_WS_FOR), 9, t1, t2, startvar, endvar, 
+       step, chunk_size,steal_chunk_size,scheduling_types,nowait);
+
+  }
   else
     t = build_call_expr (builtin_decl_explicit (BUILT_IN_GOMP_TASK),
 			 9, t1, t2, t3,
@@ -1122,6 +1227,8 @@ expand_omp_taskreg (struct omp_region *region)
   else
     exit_bb = region->exit;
 
+  bool ws_for_p = gimple_omp_task_ws_for_p (entry_stmt);
+
   bool is_cilk_for
     = (flag_cilkplus
        && gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL
@@ -1312,6 +1419,25 @@ expand_omp_taskreg (struct omp_region *region)
 	(*debug_hooks->early_global_decl) (cfun->decl);
 
       new_bb = move_sese_region_to_fn (child_cfun, entry_bb, exit_bb, block);
+
+      if(ws_for_p)
+      {
+        gsi = gsi_start_bb (entry_bb->next_bb);
+        stmt = gsi_stmt (gsi);
+        tree low_val,high_val;
+        for (t = DECL_ARGUMENTS (child_fn); t; t = TREE_CHAIN (t))
+        {
+          if (!strcmp (IDENTIFIER_POINTER (DECL_NAME (t)), "high"))
+            high_val = t;
+          else if (!strcmp (IDENTIFIER_POINTER (DECL_NAME (t)), "low"))
+            low_val = t;
+        }
+        gimple_assign_set_rhs1(stmt,low_val);
+        gsi_next(&gsi);
+        stmt = gsi_stmt (gsi);
+        gimple_assign_set_rhs1(stmt,high_val);
+      }
+
       if (exit_bb)
 	single_succ_edge (new_bb)->flags = EDGE_FALLTHRU;
       if (e2)
@@ -1358,7 +1484,7 @@ expand_omp_taskreg (struct omp_region *region)
       if (need_asm)
 	assign_assembler_name_if_needed (child_fn);
 
-      if (optimize)
+      if (optimize && !ws_for_p)
 	optimize_omp_library_calls (entry_stmt);
       cgraph_edge::rebuild_edges ();
 
@@ -1390,11 +1516,17 @@ expand_omp_taskreg (struct omp_region *region)
 	}
     }
 
+
+  if(flag_mpc_ws == 2 && ws_for_p)
+  {
+    fprintf(stderr,"Outlined function : \n");     
+    dump_function_to_file(child_fn,stderr,TDF_SLIM);fprintf(stderr,"\n");
+  }
   /* Emit a library call to launch the children threads.  */
   if (is_cilk_for)
     expand_cilk_for_call (new_bb,
 			  as_a <gomp_parallel *> (entry_stmt), ws_args);
-  else if (gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL)
+  else if (gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL && !gimple_omp_task_ws_for_p (entry_stmt))
     expand_parallel_call (region, new_bb,
 			  as_a <gomp_parallel *> (entry_stmt), ws_args);
   else
@@ -4883,7 +5015,8 @@ expand_omp_taskloop_for_outer (struct omp_region *region,
   gcc_assert (inner_stmt);
   gcc_assert (region->cont);
   gcc_assert (gimple_code (inner_stmt) == GIMPLE_OMP_TASK
-	      && gimple_omp_task_taskloop_p (inner_stmt));
+	      && (gimple_omp_task_taskloop_p (inner_stmt) ||
+	      gimple_omp_task_ws_for_p (inner_stmt)));
   type = TREE_TYPE (fd->loop.v);
 
   /* See if we need to bias by LLONG_MIN.  */
@@ -5826,7 +5959,7 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)
       gcc_assert (!inner_stmt);
       expand_oacc_for (region, &fd);
     }
-  else if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_TASKLOOP)
+  else if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_TASKLOOP || gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_WS_FOR)
     {
       if (gimple_omp_for_combined_into_p (fd.for_stmt))
 	expand_omp_taskloop_for_inner (region, &fd, inner_stmt);
@@ -8158,7 +8291,7 @@ public:
   virtual unsigned int execute (function *)
     {
       bool gate = ((flag_cilkplus != 0 || flag_openacc != 0 || flag_openmp != 0
-		    || flag_openmp_simd != 0)
+		    || flag_openmp_simd != 0 || flag_mpc_ws !=0)
 		   && !seen_error ());
 
       /* This pass always runs, to provide PROP_gimple_eomp.
diff --git a/gcc/omp-general.c b/gcc/omp-general.c
index 3f9aec8d6..fd3171abb 100644
--- a/gcc/omp-general.c
+++ b/gcc/omp-general.c
@@ -128,7 +128,8 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,
   bool distribute = gimple_omp_for_kind (for_stmt)
 		    == GF_OMP_FOR_KIND_DISTRIBUTE;
   bool taskloop = gimple_omp_for_kind (for_stmt)
-		  == GF_OMP_FOR_KIND_TASKLOOP;
+		  == GF_OMP_FOR_KIND_TASKLOOP || 
+   gimple_omp_for_kind (for_stmt) == GF_OMP_FOR_KIND_WS_FOR;
   tree iterv, countv;
 
   fd->for_stmt = for_stmt;
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
index 2d1ba3f52..acd883996 100644
--- a/gcc/omp-low.c
+++ b/gcc/omp-low.c
@@ -59,6 +59,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "gimple-pretty-print.h"
 #include "hsa-common.h"
 
+#include "tree-cfg.h"
 /* Lowering of OMP parallel and workshare constructs proceeds in two
    phases.  The first phase scans the function looking for OMP statements
    and then for variables that must be replaced to satisfy data sharing
@@ -281,7 +282,23 @@ is_taskloop_ctx (omp_context *ctx)
 	 && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_TASKLOOP;
 }
 
+/* Return true if CTX is for a ws for.  */
+static inline bool
+is_ws_ctx (omp_context *ctx)
+{
+  return gimple_code (ctx->stmt) == GIMPLE_OMP_FOR
+	 && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_WS_FOR;
+}
+
+/* Return true if CTX is the task context or the inner loop context of WS FOR */
+static inline bool
+is_in_ws_region (omp_context *ctx)
+{
+  if(is_ws_ctx(ctx) || (ctx->outer && is_ws_ctx(ctx->outer)))
+    return true;
 
+  return false;
+}
 /* Return true if CTX is for an omp parallel or omp task.  */
 
 static inline bool
@@ -524,9 +541,16 @@ build_outer_var_ref (tree var, omp_context *ctx,
 		     enum omp_clause_code code = OMP_CLAUSE_ERROR)
 {
   tree x;
-
-  if (is_global_var (maybe_lookup_decl_in_outer_ctx (var, ctx)))
+  if(flag_mpc_ws == 2)
+  {
+    fprintf(stderr,"Building outer var ref for var ");print_generic_expr (stderr, var, TDF_SLIM);
+    fprintf(stderr," with type ");print_generic_expr (stderr, TREE_TYPE(var), TDF_SLIM);
+    fprintf(stderr,"\n");
+  }
+  if (is_global_var (maybe_lookup_decl_in_outer_ctx (var, ctx)) && !is_in_ws_region(ctx))
+  {
     x = var;
+  }
   else if (is_variable_sized (var))
     {
       x = TREE_OPERAND (DECL_VALUE_EXPR (var), 0);
@@ -557,7 +581,7 @@ build_outer_var_ref (tree var, omp_context *ctx,
       if (x == NULL_TREE)
 	x = var;
     }
-  else if (code == OMP_CLAUSE_LASTPRIVATE && is_taskloop_ctx (ctx))
+  else if (code == OMP_CLAUSE_LASTPRIVATE && (is_taskloop_ctx (ctx) || is_ws_ctx(ctx)) )
     {
       gcc_assert (ctx->outer);
       splay_tree_node n
@@ -1007,38 +1031,44 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,
   for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))
     {
       bool by_ref;
-
       switch (OMP_CLAUSE_CODE (c))
 	{
 	case OMP_CLAUSE_PRIVATE:
 	  decl = OMP_CLAUSE_DECL (c);
 	  if (OMP_CLAUSE_PRIVATE_OUTER_REF (c))
+    {
 	    goto do_private;
+    }
 	  else if (!is_variable_sized (decl))
+    {
+
 	    install_var_local (decl, ctx);
+    }
+
 	  break;
 
 	case OMP_CLAUSE_SHARED:
 	  decl = OMP_CLAUSE_DECL (c);
 	  /* Ignore shared directives in teams construct.  */
-	  if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS)
+	  if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS )
 	    {
 	      /* Global variables don't need to be copied,
 		 the receiver side will use them directly.  */
 	      tree odecl = maybe_lookup_decl_in_outer_ctx (decl, ctx);
 	      if (is_global_var (odecl))
 		break;
-	      insert_decl_map (&ctx->cb, decl, odecl);
-	      break;
-	    }
-	  gcc_assert (is_taskreg_ctx (ctx));
-	  gcc_assert (!COMPLETE_TYPE_P (TREE_TYPE (decl))
+        insert_decl_map (&ctx->cb, decl, odecl);
+        break;
+      }
+
+    gcc_assert (is_taskreg_ctx (ctx));
+    gcc_assert (!COMPLETE_TYPE_P (TREE_TYPE (decl))
 		      || !is_variable_sized (decl));
 	  /* Global variables don't need to be copied,
 	     the receiver side will use them directly.  */
-	  if (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)))
+	  if (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)) && !is_in_ws_region(ctx))
 	    break;
-	  if (OMP_CLAUSE_SHARED_FIRSTPRIVATE (c))
+	  if (OMP_CLAUSE_SHARED_FIRSTPRIVATE (c) )
 	    {
 	      use_pointer_for_field (decl, ctx);
 	      break;
@@ -1070,9 +1100,14 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,
 		  || TREE_CODE (t) == ADDR_EXPR)
 		t = TREE_OPERAND (t, 0);
 	      install_var_local (t, ctx);
+        if(flag_mpc_ws == 2)
+        {
+          fprintf(stderr,"In scansharing for reduction with a memref var\n");
+          print_generic_expr (stderr, t, TDF_SLIM);fprintf(stderr," \n");
+        }
 	      if (is_taskreg_ctx (ctx)
 		  && !is_global_var (maybe_lookup_decl_in_outer_ctx (t, ctx))
-		  && !is_variable_sized (t))
+		  && !is_variable_sized (t) )
 		{
 		  by_ref = use_pointer_for_field (t, ctx);
 		  install_var_field (t, by_ref, 3, ctx);
@@ -1112,9 +1147,8 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,
 	  else if (is_taskreg_ctx (ctx))
 	    {
 	      bool global
-		= is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx));
+		= is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)) && !is_in_ws_region(ctx);
 	      by_ref = use_pointer_for_field (decl, NULL);
-
 	      if (is_task_ctx (ctx)
 		  && (global || by_ref || omp_is_reference (decl)))
 		{
@@ -1175,6 +1209,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,
 	case OMP_CLAUSE_THREAD_LIMIT:
 	case OMP_CLAUSE_DEVICE:
 	case OMP_CLAUSE_SCHEDULE:
+	case OMP_CLAUSE_STEAL_SCHEDULE:
 	case OMP_CLAUSE_DIST_SCHEDULE:
 	case OMP_CLAUSE_DEPEND:
 	case OMP_CLAUSE_PRIORITY:
@@ -1468,6 +1503,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,
 	case OMP_CLAUSE_THREAD_LIMIT:
 	case OMP_CLAUSE_DEVICE:
 	case OMP_CLAUSE_SCHEDULE:
+	case OMP_CLAUSE_STEAL_SCHEDULE:
 	case OMP_CLAUSE_DIST_SCHEDULE:
 	case OMP_CLAUSE_NOWAIT:
 	case OMP_CLAUSE_ORDERED:
@@ -1596,9 +1632,12 @@ create_omp_child_function (omp_context *ctx, bool task_copy)
       ? omp_find_clause (gimple_omp_parallel_clauses (ctx->stmt),
 			 OMP_CLAUSE__CILK_FOR_COUNT_) : NULL_TREE;
   tree cilk_var_type = NULL_TREE;
-
-  name = create_omp_child_function_name (task_copy,
+  bool ws_for_p = gimple_omp_task_ws_for_p (ctx->stmt);
+  if(!ws_for_p)
+    name = create_omp_child_function_name (task_copy,
 					 cilk_for_count != NULL_TREE);
+  else 
+    name = clone_function_name (current_function_decl, "_ws_fn");
   if (task_copy)
     type = build_function_type_list (void_type_node, ptr_type_node,
 				     ptr_type_node, NULL_TREE);
@@ -1609,6 +1648,8 @@ create_omp_child_function (omp_context *ctx, bool task_copy)
       type = build_function_type_list (void_type_node, ptr_type_node,
 				       cilk_var_type, cilk_var_type, NULL_TREE);
     }
+  else if(ws_for_p)
+    type = build_function_type_list (void_type_node, ptr_type_node,long_long_integer_type_node,long_long_integer_type_node, NULL_TREE);
   else
     type = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);
 
@@ -1683,6 +1724,29 @@ create_omp_child_function (omp_context *ctx, bool task_copy)
       DECL_ARGUMENTS (decl) = t;
     }
 
+  if(ws_for_p)
+  {
+      t = build_decl (DECL_SOURCE_LOCATION (decl),
+		      PARM_DECL, get_identifier ("high"), long_long_integer_type_node);
+      DECL_ARTIFICIAL (t) = 1;
+      DECL_NAMELESS (t) = 1;
+      DECL_ARG_TYPE (t) = ptr_type_node;
+      DECL_CONTEXT (t) = current_function_decl;
+      TREE_USED (t) = 1;
+      DECL_CHAIN (t) = DECL_ARGUMENTS (decl);
+      DECL_ARGUMENTS (decl) = t;
+
+      t = build_decl (DECL_SOURCE_LOCATION (decl),
+		      PARM_DECL, get_identifier ("low"), long_long_integer_type_node);
+      DECL_ARTIFICIAL (t) = 1;
+      DECL_NAMELESS (t) = 1;
+      DECL_ARG_TYPE (t) = ptr_type_node;
+      DECL_CONTEXT (t) = current_function_decl;
+      TREE_USED (t) = 1;
+      DECL_CHAIN (t) = DECL_ARGUMENTS (decl);
+      DECL_ARGUMENTS (decl) = t;
+  }
+
   tree data_name = get_identifier (".omp_data_i");
   t = build_decl (DECL_SOURCE_LOCATION (decl), PARM_DECL, data_name,
 		  ptr_type_node);
@@ -1692,7 +1756,7 @@ create_omp_child_function (omp_context *ctx, bool task_copy)
   DECL_CONTEXT (t) = current_function_decl;
   TREE_USED (t) = 1;
   TREE_READONLY (t) = 1;
-  if (cilk_for_count)
+  if (cilk_for_count || ws_for_p)
     DECL_CHAIN (t) = DECL_ARGUMENTS (decl);
   DECL_ARGUMENTS (decl) = t;
   if (!task_copy)
@@ -1871,6 +1935,8 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)
 
   if (gimple_omp_task_taskloop_p (stmt))
     add_taskreg_looptemp_clauses (GF_OMP_FOR_KIND_TASKLOOP, stmt, outer_ctx);
+  if (gimple_omp_task_ws_for_p (stmt))
+    add_taskreg_looptemp_clauses (GF_OMP_FOR_KIND_WS_FOR, stmt, outer_ctx);
 
   ctx = new_omp_context (stmt, outer_ctx);
   taskreg_contexts.safe_push (ctx);
@@ -1966,7 +2032,7 @@ finish_taskreg_scan (omp_context *ctx)
 
 	    /* Global variables don't need to be copied,
 	       the receiver side will use them directly.  */
-	    if (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)))
+	    if (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)) && !is_in_ws_region(ctx))
 	      continue;
 	    if (!bitmap_bit_p (task_shared_vars, DECL_UID (decl))
 		|| !use_pointer_for_field (decl, ctx))
@@ -2017,7 +2083,7 @@ finish_taskreg_scan (omp_context *ctx)
 	else
 	  p = &DECL_CHAIN (*p);
       *p = vla_fields;
-      if (gimple_omp_task_taskloop_p (ctx->stmt))
+      if (gimple_omp_task_taskloop_p (ctx->stmt) || gimple_omp_task_ws_for_p (ctx->stmt))
 	{
 	  /* Move fields corresponding to first and second _looptemp_
 	     clause first.  There are filled by GOMP_taskloop
@@ -2548,7 +2614,7 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)
 	  return true;
 	}
       /* We split taskloop into task and nested taskloop in it.  */
-      if (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_TASKLOOP)
+      if (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_TASKLOOP || gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_WS_FOR)
 	return true;
       if (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_OACC_LOOP)
 	{
@@ -2730,7 +2796,7 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)
 	  {
 	  case GIMPLE_OMP_FOR:
 	    if (gimple_omp_for_kind (ctx->stmt) != GF_OMP_FOR_KIND_FOR
-		&& gimple_omp_for_kind (ctx->stmt) != GF_OMP_FOR_KIND_TASKLOOP)
+		&& (gimple_omp_for_kind (ctx->stmt) != GF_OMP_FOR_KIND_TASKLOOP || gimple_omp_for_kind (ctx->stmt) != GF_OMP_FOR_KIND_WS_FOR))
 	      break;
 	    /* FALLTHRU */
 	  case GIMPLE_OMP_SECTIONS:
@@ -2774,7 +2840,7 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)
 	  {
 	  case GIMPLE_OMP_FOR:
 	    if (gimple_omp_for_kind (ctx->stmt) != GF_OMP_FOR_KIND_FOR
-		&& gimple_omp_for_kind (ctx->stmt) != GF_OMP_FOR_KIND_TASKLOOP)
+		&& (gimple_omp_for_kind (ctx->stmt) != GF_OMP_FOR_KIND_TASKLOOP || gimple_omp_for_kind (ctx->stmt) != GF_OMP_FOR_KIND_WS_FOR))
 	      break;
 	    /* FALLTHRU */
 	  case GIMPLE_OMP_SECTIONS:
@@ -2883,7 +2949,7 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)
 		      "%<taskloop%> region");
 	    return false;
 	  case GIMPLE_OMP_FOR:
-	    if (gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_TASKLOOP)
+	    if (gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_TASKLOOP || gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_WS_FOR)
 	      goto ordered_in_taskloop;
 	    if (omp_find_clause (gimple_omp_for_clauses (ctx->stmt),
 				 OMP_CLAUSE_ORDERED) == NULL)
@@ -3148,6 +3214,7 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,
 	    switch (DECL_FUNCTION_CODE (fndecl))
 	      {
 	      case BUILT_IN_GOMP_BARRIER:
+	      case BUILT_IN_MPC_WS_STOPSTEAL:
 	      case BUILT_IN_GOMP_CANCEL:
 	      case BUILT_IN_GOMP_CANCELLATION_POINT:
 	      case BUILT_IN_GOMP_TASKYIELD:
@@ -3765,6 +3832,12 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,
 	  if (c_kind != OMP_CLAUSE_COPYIN)
 	    new_var = lookup_decl (var, ctx);
 
+    if(flag_mpc_ws == 2)
+    {
+      fprintf(stderr,"Lowering clause ");print_generic_expr (stderr, c, TDF_SLIM);fprintf(stderr," for var ");
+      print_generic_expr (stderr, new_var, TDF_SLIM);fprintf(stderr,"\n");
+    }
+
 	  if (c_kind == OMP_CLAUSE_SHARED || c_kind == OMP_CLAUSE_COPYIN)
 	    {
 	      if (pass != 0)
@@ -4084,8 +4157,16 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,
 		continue;
 
 	      x = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (new_var)));
-	      if (c_kind == OMP_CLAUSE_FIRSTPRIVATE && is_task_ctx (ctx))
+
+        if(flag_mpc_ws == 2)
+        {
+          fprintf(stderr,"\nLowering reference var ");print_generic_expr (stderr, var, TDF_SLIM);
+          fprintf(stderr," with type ");print_generic_expr (stderr, TREE_TYPE(var), TDF_SLIM);
+          fprintf(stderr,"\n");
+        }
+	      if (c_kind == OMP_CLAUSE_FIRSTPRIVATE && is_task_ctx (ctx) )
 		{
+
 		  x = build_receiver_ref (var, false, ctx);
 		  x = build_fold_addr_expr_loc (clause_loc, x);
 		}
@@ -4680,9 +4761,39 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,
 	  gimple_omp_for_set_clauses (ctx->stmt, c);
 	}
     }
-}
 
+}
 
+static void 
+lower_ws_global_vars(tree clauses, gimple_seq *ilist, gimple_seq *olist,
+			 omp_context *ctx)
+{
+  tree c,var,x;
+  bool by_ref;
+  for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))
+  {
+    enum omp_clause_code c_kind = OMP_CLAUSE_CODE (c);
+    if(c_kind == OMP_CLAUSE_SHARED)
+    {
+      var = OMP_CLAUSE_DECL(c);
+      if (is_global_var (var))
+      {
+        if(flag_mpc_ws == 2)
+        {
+          fprintf(stderr,"Lowering global var ");
+          print_generic_expr (stderr, var, TDF_SLIM);fprintf(stderr," clause ");
+          print_generic_expr (stderr, c, TDF_SLIM);fprintf(stderr,"\n");
+        }
+        by_ref = use_pointer_for_field (var, ctx);
+        x = build_receiver_ref(var,by_ref,ctx);
+        tree tmp_var = create_tmp_var_raw (TREE_TYPE(var), get_name (var));
+        gimplify_assign(tmp_var, var, ilist);
+        gimplify_assign(var, x, ilist);
+        gimplify_assign(var, tmp_var, olist);
+      }
+    }
+  }
+}
 /* Generate code to implement the LASTPRIVATE clauses.  This is used for
    both parallel and workshare constructs.  PREDICATE may be NULL if it's
    always true.   */
@@ -5170,11 +5281,21 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)
       if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)
 	continue;
 
+      if(flag_mpc_ws == 2)
+      {
+        fprintf(stderr,"Lowering reduction for clause ");
+        print_generic_expr (stderr, c, TDF_SLIM);fprintf(stderr," \n");
+      }
       enum omp_clause_code ccode = OMP_CLAUSE_REDUCTION;
       orig_var = var = OMP_CLAUSE_DECL (c);
       if (TREE_CODE (var) == MEM_REF)
 	{
 	  var = TREE_OPERAND (var, 0);
+    if(flag_mpc_ws == 2)
+    {
+      fprintf(stderr,"Reduction mem ref for var ");
+      print_generic_expr (stderr, var, TDF_SLIM);fprintf(stderr," \n");
+    }
 	  if (TREE_CODE (var) == POINTER_PLUS_EXPR)
 	    var = TREE_OPERAND (var, 0);
 	  if (TREE_CODE (var) == ADDR_EXPR)
@@ -5354,21 +5475,42 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)
 	}
       else
 	{
+
 	  x = build2 (code, TREE_TYPE (ref), ref, new_var);
-	  ref = build_outer_var_ref (var, ctx);
+    ref = build_outer_var_ref (var, ctx,ccode);
 	  gimplify_assign (ref, x, &sub_seq);
 	}
+
+  if(flag_mpc_ws == 2)
+  {
+    fprintf(stderr,"Finished lowering reduction : ref ");
+    print_generic_expr (stderr, ref, TDF_SLIM);
+    fprintf(stderr," new_var : ");print_generic_expr (stderr, new_var, TDF_SLIM);
+    fprintf(stderr," \n");
+  }
     }
 
-  stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_START),
-			    0);
+
+
+  if(!is_in_ws_region(ctx))
+    stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_START),
+        0);
+  else
+    stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_MPC_WS_ATOMIC_START),
+        0);
   gimple_seq_add_stmt (stmt_seqp, stmt);
 
   gimple_seq_add_seq (stmt_seqp, sub_seq);
 
-  stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_END),
+  if(!is_in_ws_region(ctx))
+    stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_END),
+        0);
+  else
+    stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_MPC_WS_ATOMIC_END),
 			    0);
+
   gimple_seq_add_stmt (stmt_seqp, stmt);
+
 }
 
 
@@ -5434,7 +5576,7 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,
 
   /* For taskloop, ignore first two _looptemp_ clauses, those are initialized
      by GOMP_taskloop.  */
-  if (is_task_ctx (ctx) && gimple_omp_task_taskloop_p (ctx->stmt))
+  if (is_task_ctx (ctx) && (gimple_omp_task_taskloop_p (ctx->stmt) || gimple_omp_task_ws_for_p (ctx->stmt)))
     {
       ignored_looptemp = 2;
       is_taskloop = true;
@@ -5497,7 +5639,7 @@ lower_send_clauses (tree clauses, gimple_seq *ilist, gimple_seq *olist,
       var = lookup_decl_in_outer_ctx (val, ctx_for_o);
 
       if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_COPYIN
-	  && is_global_var (var))
+	  && (is_global_var (var) && !is_in_ws_region(ctx)))
 	continue;
 
       t = omp_member_access_dummy_var (var);
@@ -6646,29 +6788,38 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)
       if (cgraph_node::get (current_function_decl)->offloadable)
 	varpool_node::get_create (decl)->offloadable = 1;
       else
-	for (octx = ctx->outer; octx; octx = octx->outer)
-	  if (is_gimple_omp_offloaded (octx->stmt))
-	    {
-	      varpool_node::get_create (decl)->offloadable = 1;
-	      break;
-	    }
+        for (octx = ctx->outer; octx; octx = octx->outer)
+          if (is_gimple_omp_offloaded (octx->stmt))
+          {
+            varpool_node::get_create (decl)->offloadable = 1;
+            break;
+          }
 
       lock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_NAME_START);
       lock = build_call_expr_loc (loc, lock, 1,
-				  build_fold_addr_expr_loc (loc, decl));
+          build_fold_addr_expr_loc (loc, decl));
 
       unlock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_NAME_END);
+
       unlock = build_call_expr_loc (loc, unlock, 1,
-				build_fold_addr_expr_loc (loc, decl));
+          build_fold_addr_expr_loc (loc, decl));
     }
   else
-    {
+  {
+    if(!gimple_omp_critical_ws_p(stmt))
       lock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_START);
-      lock = build_call_expr_loc (loc, lock, 0);
+    else
+      lock = builtin_decl_explicit (BUILT_IN_MPC_WS_CRITICAL_START);
 
+    lock = build_call_expr_loc (loc, lock, 0);
+
+    if(!gimple_omp_critical_ws_p(stmt))
       unlock = builtin_decl_explicit (BUILT_IN_GOMP_CRITICAL_END);
-      unlock = build_call_expr_loc (loc, unlock, 0);
-    }
+    else
+      unlock = builtin_decl_explicit (BUILT_IN_MPC_WS_CRITICAL_END);
+
+    unlock = build_call_expr_loc (loc, unlock, 0);
+  }
 
   push_gimplify_context ();
 
@@ -6753,7 +6904,7 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,
 		      n2 = fold_convert (TREE_TYPE (n2), outer_fd.loop.n2);
 		    }
 		}
-	      else if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_TASKLOOP)
+	      else if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_TASKLOOP || gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_WS_FOR)
 		taskreg_ctx = ctx->outer->outer;
 	    }
 	  else if (is_taskreg_ctx (ctx->outer))
@@ -6863,7 +7014,8 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)
 	count += fd.collapse - 1;
       bool taskreg_for
 	= (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_FOR
-	   || gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_TASKLOOP);
+     || gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_TASKLOOP
+	   || gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_WS_FOR);
       tree outerc = NULL, *pc = gimple_omp_for_clauses_ptr (stmt);
       tree simtc = NULL;
       tree clauses = *pc;
@@ -7396,7 +7548,7 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)
   tree child_fn, t;
   gimple *stmt = gsi_stmt (*gsi_p);
   gbind *par_bind, *bind, *dep_bind = NULL;
-  gimple_seq par_body, olist, ilist, par_olist, par_rlist, par_ilist, new_body;
+  gimple_seq par_body, olist, ilist, par_olist, par_rlist, par_ilist, new_body,ws_ilist,ws_olist;
   location_t loc = gimple_location (stmt);
 
   clauses = gimple_omp_taskreg_clauses (stmt);
@@ -7436,6 +7588,8 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)
   par_olist = NULL;
   par_ilist = NULL;
   par_rlist = NULL;
+  ws_ilist = NULL;
+  ws_olist = NULL;
   bool phony_construct = gimple_code (stmt) == GIMPLE_OMP_PARALLEL
     && gimple_omp_parallel_grid_phony (as_a <gomp_parallel *> (stmt));
   if (phony_construct && ctx->record_type)
@@ -7447,8 +7599,10 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)
 	(build_reference_type (ctx->record_type), ".omp_rec");
     }
   lower_rec_input_clauses (clauses, &par_ilist, &par_olist, ctx, NULL);
+  if(is_in_ws_region(ctx))
+    lower_ws_global_vars(clauses,&ws_ilist,&ws_olist,ctx);
   lower_omp (&par_body, ctx);
-  if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL)
+  if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL || (ctx->outer && is_ws_ctx(ctx->outer)))
     lower_reduction_clauses (clauses, &par_rlist, ctx);
 
   /* Declare all the variables created by mapping and the variables
@@ -7479,7 +7633,13 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)
 
   /* Once all the expansions are done, sequence all the different
      fragments inside gimple_omp_body.  */
+  if(flag_mpc_ws == 2)
+  {
+    fprintf(stderr,"Lowering taskreg : par_ilist = \n");
+    print_gimple_seq(stderr,par_ilist,1,TDF_SLIM);fprintf(stderr,"and ilist = \n");
+    print_gimple_seq(stderr,ilist,1,TDF_SLIM);fprintf(stderr,"\n");
 
+  }
   new_body = NULL;
 
   if (ctx->record_type)
@@ -7492,8 +7652,10 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)
     }
 
   gimple_seq_add_seq (&new_body, par_ilist);
+  gimple_seq_add_seq (&new_body, ws_ilist);
   gimple_seq_add_seq (&new_body, par_body);
   gimple_seq_add_seq (&new_body, par_rlist);
+  gimple_seq_add_seq (&new_body, ws_olist);
   if (ctx->cancellable)
     gimple_seq_add_stmt (&new_body, gimple_build_label (ctx->cancel_label));
   gimple_seq_add_seq (&new_body, par_olist);
@@ -8890,6 +9052,7 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)
 	switch (DECL_FUNCTION_CODE (fndecl))
 	  {
 	  case BUILT_IN_GOMP_BARRIER:
+	  case BUILT_IN_MPC_WS_STOPSTEAL:
 	    if (ctx == NULL)
 	      break;
 	    /* FALLTHRU */
@@ -8983,7 +9146,7 @@ execute_lower_omp (void)
   /* This pass always runs, to provide PROP_gimple_lomp.
      But often, there is nothing to do.  */
   if (flag_cilkplus == 0 && flag_openacc == 0 && flag_openmp == 0
-      && flag_openmp_simd == 0)
+      && flag_openmp_simd == 0 && flag_mpc_ws == 0)
     return 0;
 
   all_contexts = splay_tree_new (splay_tree_compare_pointers, 0,
@@ -9355,7 +9518,7 @@ public:
   /* opt_pass methods: */
   virtual bool gate (function *)
   {
-    return flag_cilkplus || flag_openacc || flag_openmp || flag_openmp_simd;
+    return flag_cilkplus || flag_openacc || flag_openmp || flag_openmp_simd || flag_mpc_ws;
   }
   virtual unsigned int execute (function *)
     {
diff --git a/gcc/tree-core.h b/gcc/tree-core.h
index a646ecb5c..4e2947bcd 100644
--- a/gcc/tree-core.h
+++ b/gcc/tree-core.h
@@ -435,6 +435,9 @@ enum omp_clause_code {
   /* OpenMP clause: defaultmap (tofrom: scalar).  */
   OMP_CLAUSE_DEFAULTMAP,
 
+  /* MPC WS clause: used to specify the scheduling of stealing processes */
+  OMP_CLAUSE_STEAL_SCHEDULE,
+
   /* Internally used only clause, holding SIMD uid.  */
   OMP_CLAUSE__SIMDUID_,
 
diff --git a/gcc/tree-pretty-print.c b/gcc/tree-pretty-print.c
index d823c2e12..ba32f6f13 100644
--- a/gcc/tree-pretty-print.c
+++ b/gcc/tree-pretty-print.c
@@ -559,6 +559,53 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)
       pp_right_paren (pp);
       break;
 
+    case OMP_CLAUSE_STEAL_SCHEDULE:
+      pp_string (pp, "steal_schedule(");
+      if (OMP_CLAUSE_SCHEDULE_KIND (clause)
+	  & (OMP_CLAUSE_SCHEDULE_MONOTONIC
+	     | OMP_CLAUSE_SCHEDULE_NONMONOTONIC))
+	{
+	  if (OMP_CLAUSE_SCHEDULE_KIND (clause)
+	      & OMP_CLAUSE_SCHEDULE_MONOTONIC)
+	    pp_string (pp, "monotonic");
+	  else
+	    pp_string (pp, "nonmonotonic");
+	  if (OMP_CLAUSE_SCHEDULE_SIMD (clause))
+	    pp_comma (pp);
+	  else
+	    pp_colon (pp);
+	}
+      if (OMP_CLAUSE_SCHEDULE_SIMD (clause))
+	pp_string (pp, "simd:");
+
+      switch (OMP_CLAUSE_SCHEDULE_KIND (clause) & OMP_CLAUSE_SCHEDULE_MASK)
+	{
+	case OMP_CLAUSE_SCHEDULE_STATIC:
+	  pp_string (pp, "static");
+	  break;
+	case OMP_CLAUSE_SCHEDULE_DYNAMIC:
+	  pp_string (pp, "dynamic");
+	  break;
+	case OMP_CLAUSE_SCHEDULE_GUIDED:
+	  pp_string (pp, "guided");
+	  break;
+	case OMP_CLAUSE_SCHEDULE_RUNTIME:
+	  pp_string (pp, "runtime");
+	  break;
+	case OMP_CLAUSE_SCHEDULE_AUTO:
+	  pp_string (pp, "auto");
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+      if (OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clause))
+	{
+	  pp_comma (pp);
+	  dump_generic_node (pp, OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clause),
+			     spc, flags, false);
+	}
+      pp_right_paren (pp);
+      break;
     case OMP_CLAUSE_UNTIED:
       pp_string (pp, "untied");
       break;
diff --git a/gcc/tree-ssa-alias.c b/gcc/tree-ssa-alias.c
index 4cedcb239..6de19b421 100644
--- a/gcc/tree-ssa-alias.c
+++ b/gcc/tree-ssa-alias.c
@@ -1816,6 +1816,7 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref)
 	case BUILT_IN_GOMP_ATOMIC_START:
 	case BUILT_IN_GOMP_ATOMIC_END:
 	case BUILT_IN_GOMP_BARRIER:
+  case BUILT_IN_MPC_WS_STOPSTEAL:
 	case BUILT_IN_GOMP_BARRIER_CANCEL:
 	case BUILT_IN_GOMP_TASKWAIT:
 	case BUILT_IN_GOMP_TASKGROUP_END:
@@ -2204,6 +2205,7 @@ call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref)
 	case BUILT_IN_GOMP_ATOMIC_START:
 	case BUILT_IN_GOMP_ATOMIC_END:
 	case BUILT_IN_GOMP_BARRIER:
+  case BUILT_IN_MPC_WS_STOPSTEAL:
 	case BUILT_IN_GOMP_BARRIER_CANCEL:
 	case BUILT_IN_GOMP_TASKWAIT:
 	case BUILT_IN_GOMP_TASKGROUP_END:
diff --git a/gcc/tree.c b/gcc/tree.c
index 698213c35..71c09cac6 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "print-tree.h"
 #include "ipa-utils.h"
 #include "selftest.h"
+#include "gimple-pretty-print.h"
 
 /* Tree code classes.  */
 
@@ -11981,6 +11982,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,
 	case OMP_CLAUSE__LOOPTEMP_:
 	case OMP_CLAUSE__SIMDUID_:
 	case OMP_CLAUSE__CILK_FOR_COUNT_:
+  case OMP_CLAUSE_STEAL_SCHEDULE:
 	  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 0));
 	  /* FALLTHRU */
 
diff --git a/gcc/tree.def b/gcc/tree.def
index 0ec805903..b520faaee 100644
--- a/gcc/tree.def
+++ b/gcc/tree.def
@@ -1143,6 +1143,10 @@ DEFTREECODE (OMP_DISTRIBUTE, "omp_distribute", tcc_statement, 7)
    Operands like for OMP_FOR.  */
 DEFTREECODE (OMP_TASKLOOP, "omp_taskloop", tcc_statement, 7)
 
+/* MPC Workshare - #pragma ws for [clause1 ... clauseN]
+   Operands like for OMP_FOR.  */
+DEFTREECODE (WS_FOR, "ws_for", tcc_statement, 7)
+
 /* OpenMP - #pragma acc loop [clause1 ... clauseN]
    Operands like for OMP_FOR.  */
 DEFTREECODE (OACC_LOOP, "oacc_loop", tcc_statement, 7)
@@ -1178,6 +1182,10 @@ DEFTREECODE (OMP_ORDERED, "omp_ordered", tcc_statement, 2)
    Operand 2: OMP_CRITICAL_NAME: Identifier for critical section.  */
 DEFTREECODE (OMP_CRITICAL, "omp_critical", tcc_statement, 3)
 
+/* MPC Workshare - #pragma ws critical [name]
+   Operands like for omp critical. */
+DEFTREECODE (WS_CRITICAL, "ws_critical", tcc_statement, 3)
+
 /* OpenMP - #pragma omp single
    Operand 0: OMP_SINGLE_BODY: Single section body.
    Operand 1: OMP_SINGLE_CLAUSES: List of clauses.  */
diff --git a/gcc/tree.h b/gcc/tree.h
index f20b77f17..cca5e2b92 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -1667,6 +1667,12 @@ extern void protected_set_expr_location (tree, location_t);
 #define OMP_CLAUSE__GRIDDIM__GROUP(NODE) \
   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__GRIDDIM_), 1)
 
+#define OMP_CLAUSE_STEAL_SCHEDULE_KIND(NODE) \
+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_STEAL_SCHEDULE)->omp_clause.subcode.schedule_kind)
+#define OMP_CLAUSE_STEAL_SCHEDULE_SIMD(NODE) \
+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_STEAL_SCHEDULE)->base.public_flag)
+#define OMP_CLAUSE_STEAL_SCHEDULE_CHUNK_EXPR(NODE) \
+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_STEAL_SCHEDULE), 0)
 /* SSA_NAME accessors.  */
 
 /* Whether SSA_NAME NODE is a virtual operand.  This simply caches the
